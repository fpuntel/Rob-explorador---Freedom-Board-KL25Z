   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"SS1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	36
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.text.SS1_Init,"ax",%progbits
  24              		.align	2
  25              		.global	SS1_Init
  26              		.code	16
  27              		.thumb_func
  29              	SS1_Init:
  30              	.LFB0:
  31              		.file 1 "../Generated_Code/SS1.c"
   1:../Generated_Code/SS1.c **** /** ###################################################################
   2:../Generated_Code/SS1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/SS1.c **** **     Filename    : SS1.c
   4:../Generated_Code/SS1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/SS1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/SS1.c **** **     Component   : SPISlave_LDD
   7:../Generated_Code/SS1.c **** **     Version     : Component 01.035, Driver 01.02, CPU db: 3.00.000
   8:../Generated_Code/SS1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/SS1.c **** **     Date/Time   : 2013-09-09, 14:34, # CodeGen: 47
  10:../Generated_Code/SS1.c **** **     Abstract    :
  11:../Generated_Code/SS1.c **** **         This component "SPISlave_LDD" implements SLAVE part of synchronous
  12:../Generated_Code/SS1.c **** **         serial master-slave communication.
  13:../Generated_Code/SS1.c **** **     Settings    :
  14:../Generated_Code/SS1.c **** **          Component name                                 : SS1
  15:../Generated_Code/SS1.c **** **          Device                                         : SPI0
  16:../Generated_Code/SS1.c **** **          Interrupt service/event                        : Enabled
  17:../Generated_Code/SS1.c **** **            Input interrupt                              : INT_SPI0
  18:../Generated_Code/SS1.c **** **            Input interrupt priority                     : medium priority
  19:../Generated_Code/SS1.c **** **            Output interrupt                             : INT_SPI0
  20:../Generated_Code/SS1.c **** **            Output interrupt priority                    : medium priority
  21:../Generated_Code/SS1.c **** **          Settings                                       : 
  22:../Generated_Code/SS1.c **** **            Input pin                                    : Enabled
  23:../Generated_Code/SS1.c **** **              Pin                                        : CMP0_IN0/PTC6/LLWU_P10/SPI0_MOSI/EXTRG
  24:../Generated_Code/SS1.c **** **              Pin signal                                 : 
  25:../Generated_Code/SS1.c **** **            Output pin                                   : Enabled
  26:../Generated_Code/SS1.c **** **              Pin                                        : CMP0_IN1/PTC7/SPI0_MISO/SPI0_MOSI
  27:../Generated_Code/SS1.c **** **              Pin signal                                 : 
  28:../Generated_Code/SS1.c **** **            Clock pin                                    : 
  29:../Generated_Code/SS1.c **** **              Pin                                        : PTC5/LLWU_P9/SPI0_SCK/LPTMR0_ALT2/CMP0
  30:../Generated_Code/SS1.c **** **              Pin signal                                 : 
  31:../Generated_Code/SS1.c **** **            Slave select                                 : 
  32:../Generated_Code/SS1.c **** **              Pin                                        : PTC4/LLWU_P8/SPI0_PCS0/UART1_TX/TPM0_C
  33:../Generated_Code/SS1.c **** **              Pin signal                                 : 
  34:../Generated_Code/SS1.c **** **              Active level                               : Low
  35:../Generated_Code/SS1.c **** **            Attribute set                                : 
  36:../Generated_Code/SS1.c **** **              Width                                      : 8 bits
  37:../Generated_Code/SS1.c **** **              MSB first                                  : yes
  38:../Generated_Code/SS1.c **** **              Clock polarity                             : Low
  39:../Generated_Code/SS1.c **** **              Clock phase                                : Capture on leading edge
  40:../Generated_Code/SS1.c **** **              Parity                                     : None
  41:../Generated_Code/SS1.c **** **            HW input buffer size                         : 1
  42:../Generated_Code/SS1.c **** **            HW input watermark                           : 1
  43:../Generated_Code/SS1.c **** **            HW output buffer size                        : 1
  44:../Generated_Code/SS1.c **** **            HW output watermark                          : 1
  45:../Generated_Code/SS1.c **** **          Initialization                                 : 
  46:../Generated_Code/SS1.c **** **            Enabled in init. code                        : yes
  47:../Generated_Code/SS1.c **** **            Auto initialization                          : no
  48:../Generated_Code/SS1.c **** **            Event mask                                   : 
  49:../Generated_Code/SS1.c **** **              OnBlockSent                                : Enabled
  50:../Generated_Code/SS1.c **** **              OnBlockReceived                            : Enabled
  51:../Generated_Code/SS1.c **** **              OnError                                    : Disabled
  52:../Generated_Code/SS1.c **** **     Contents    :
  53:../Generated_Code/SS1.c **** **         Init               - LDD_TDeviceData* SS1_Init(LDD_TUserData *UserDataPtr);
  54:../Generated_Code/SS1.c **** **         Deinit             - void SS1_Deinit(LDD_TDeviceData *DeviceDataPtr);
  55:../Generated_Code/SS1.c **** **         SendBlock          - LDD_TError SS1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData.
  56:../Generated_Code/SS1.c **** **         ReceiveBlock       - LDD_TError SS1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TDa
  57:../Generated_Code/SS1.c **** **         GetSentDataNum     - uint16_t SS1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr);
  58:../Generated_Code/SS1.c **** **         GetReceivedDataNum - uint16_t SS1_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr);
  59:../Generated_Code/SS1.c **** **
  60:../Generated_Code/SS1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  61:../Generated_Code/SS1.c **** **     
  62:../Generated_Code/SS1.c **** **     http      : www.freescale.com
  63:../Generated_Code/SS1.c **** **     mail      : support@freescale.com
  64:../Generated_Code/SS1.c **** ** ###################################################################*/
  65:../Generated_Code/SS1.c **** 
  66:../Generated_Code/SS1.c **** /* MODULE SS1. */
  67:../Generated_Code/SS1.c **** /*lint -save  -e926 -e927 -e928 -e929 Disable MISRA rule (11.4) checking. */
  68:../Generated_Code/SS1.c **** 
  69:../Generated_Code/SS1.c **** #include "Events.h"
  70:../Generated_Code/SS1.c **** #include "SS1.h"
  71:../Generated_Code/SS1.c **** /* MQX Lite include files */
  72:../Generated_Code/SS1.c **** #include "mqxlite.h"
  73:../Generated_Code/SS1.c **** #include "mqxlite_prv.h"
  74:../Generated_Code/SS1.c **** 
  75:../Generated_Code/SS1.c **** #define AVAILABLE_EVENTS_MASK (LDD_SPISLAVE_ON_BLOCK_RECEIVED | LDD_SPISLAVE_ON_BLOCK_SENT)
  76:../Generated_Code/SS1.c **** 
  77:../Generated_Code/SS1.c **** /* These constants contain pins masks */
  78:../Generated_Code/SS1.c **** #define SS1_AVAILABLE_PIN_MASK (LDD_SPISLAVE_INPUT_PIN | LDD_SPISLAVE_OUTPUT_PIN | LDD_SPISLAVE_CLK
  79:../Generated_Code/SS1.c **** 
  80:../Generated_Code/SS1.c **** 
  81:../Generated_Code/SS1.c **** typedef struct {
  82:../Generated_Code/SS1.c ****   LDD_SPISLAVE_TError ErrFlag;         /* Error flags */
  83:../Generated_Code/SS1.c ****   uint16_t InpRecvDataNum;             /* The counter of received characters */
  84:../Generated_Code/SS1.c ****   uint8_t *InpDataPtr;                 /* The buffer pointer for received characters */
  85:../Generated_Code/SS1.c ****   uint16_t InpDataNumReq;              /* The counter of characters to receive by ReceiveBlock() */
  86:../Generated_Code/SS1.c ****   uint16_t OutSentDataNum;             /* The counter of sent characters */
  87:../Generated_Code/SS1.c ****   uint8_t *OutDataPtr;                 /* The buffer pointer for data to be transmitted */
  88:../Generated_Code/SS1.c ****   uint16_t OutDataNumReq;              /* The counter of characters to be send by SendBlock() */
  89:../Generated_Code/SS1.c ****   LDD_RTOS_TISRVectorSettings SavedISRSettings_Interrupt; /* {MQXLite RTOS Adapter} Saved settings 
  90:../Generated_Code/SS1.c ****   LDD_TUserData *UserData;             /* User device data structure */
  91:../Generated_Code/SS1.c **** } SS1_TDeviceData;                     /* Device data structure type */
  92:../Generated_Code/SS1.c **** 
  93:../Generated_Code/SS1.c **** typedef SS1_TDeviceData* SS1_TDeviceDataPtr ; /* Pointer to the device data structure. */
  94:../Generated_Code/SS1.c **** 
  95:../Generated_Code/SS1.c **** /* {MQXLite RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
  96:../Generated_Code/SS1.c **** static SS1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  97:../Generated_Code/SS1.c **** /* Internal method prototypes */
  98:../Generated_Code/SS1.c **** 
  99:../Generated_Code/SS1.c **** /*
 100:../Generated_Code/SS1.c **** ** ===================================================================
 101:../Generated_Code/SS1.c **** **     Method      :  SS1_Init (component SPISlave_LDD)
 102:../Generated_Code/SS1.c **** **
 103:../Generated_Code/SS1.c **** **     Description :
 104:../Generated_Code/SS1.c **** **         Initializes the device. Allocates memory for the device data
 105:../Generated_Code/SS1.c **** **         structure, allocates interrupt vectors and sets interrupt
 106:../Generated_Code/SS1.c **** **         priority, sets pin routing, sets timing, etc.
 107:../Generated_Code/SS1.c **** **         If the "Enable in init. code" is set to "yes" value then the
 108:../Generated_Code/SS1.c **** **         device is also enabled(see the description of the Enable()
 109:../Generated_Code/SS1.c **** **         method). In this case the Enable() method is not necessary
 110:../Generated_Code/SS1.c **** **         and needn't to be generated. 
 111:../Generated_Code/SS1.c **** **         This method can be called only once. Before the second call
 112:../Generated_Code/SS1.c **** **         of Init() the Deinit() must be called first.
 113:../Generated_Code/SS1.c **** **     Parameters  :
 114:../Generated_Code/SS1.c **** **         NAME            - DESCRIPTION
 115:../Generated_Code/SS1.c **** **       * UserDataPtr     - Pointer to the user or
 116:../Generated_Code/SS1.c **** **                           RTOS specific data. This pointer will be
 117:../Generated_Code/SS1.c **** **                           passed as an event or callback parameter.
 118:../Generated_Code/SS1.c **** **     Returns     :
 119:../Generated_Code/SS1.c **** **         ---             - Device data structure pointer.
 120:../Generated_Code/SS1.c **** ** ===================================================================
 121:../Generated_Code/SS1.c **** */
 122:../Generated_Code/SS1.c **** LDD_TDeviceData* SS1_Init(LDD_TUserData *UserDataPtr)
 123:../Generated_Code/SS1.c **** {
  32              		.loc 1 123 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 84B0     		sub	sp, sp, #16
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 24
  42 0004 00AF     		add	r7, sp, #0
  43              	.LCFI2:
  44              		.cfi_def_cfa_register 7
  45 0006 7860     		str	r0, [r7, #4]
 124:../Generated_Code/SS1.c ****   /* Allocate LDD device structure */
 125:../Generated_Code/SS1.c ****   SS1_TDeviceDataPtr DeviceDataPrv;
 126:../Generated_Code/SS1.c **** 
 127:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 128:../Generated_Code/SS1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  46              		.loc 1 128 0
  47 0008 454B     		ldr	r3, .L2
  48 000a FB60     		str	r3, [r7, #12]
 129:../Generated_Code/SS1.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  49              		.loc 1 129 0
  50 000c FB68     		ldr	r3, [r7, #12]
  51 000e 7A68     		ldr	r2, [r7, #4]
  52 0010 1A62     		str	r2, [r3, #32]
 130:../Generated_Code/SS1.c ****   /* Interrupt vector(s) allocation */
 131:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} Save old and set new interrupt vector (function handler and ISR paramet
 132:../Generated_Code/SS1.c ****   /* Note: Exception handler for interrupt is not saved, because it is not modified */
 133:../Generated_Code/SS1.c ****   DeviceDataPrv->SavedISRSettings_Interrupt.isrData = _int_get_isr_data(LDD_ivIndex_INT_SPI0);
  53              		.loc 1 133 0
  54 0012 1A20     		mov	r0, #26
  55 0014 FFF7FEFF 		bl	_int_get_isr_data
  56 0018 021C     		mov	r2, r0
  57 001a FB68     		ldr	r3, [r7, #12]
  58 001c DA61     		str	r2, [r3, #28]
 134:../Generated_Code/SS1.c ****   DeviceDataPrv->SavedISRSettings_Interrupt.isrFunction = _int_install_isr(LDD_ivIndex_INT_SPI0, SS
  59              		.loc 1 134 0
  60 001e 414A     		ldr	r2, .L2+4
  61 0020 FB68     		ldr	r3, [r7, #12]
  62 0022 1A20     		mov	r0, #26
  63 0024 111C     		mov	r1, r2
  64 0026 1A1C     		mov	r2, r3
  65 0028 FFF7FEFF 		bl	_int_install_isr
  66 002c 021C     		mov	r2, r0
  67 002e FB68     		ldr	r3, [r7, #12]
  68 0030 9A61     		str	r2, [r3, #24]
 135:../Generated_Code/SS1.c ****   DeviceDataPrv->ErrFlag = 0x00U;      /* Clear error flags */
  69              		.loc 1 135 0
  70 0032 FB68     		ldr	r3, [r7, #12]
  71 0034 0022     		mov	r2, #0
  72 0036 1A60     		str	r2, [r3]
 136:../Generated_Code/SS1.c ****   /* Clear the receive counters and pointer */
 137:../Generated_Code/SS1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Clear the counter of received characters */
  73              		.loc 1 137 0
  74 0038 FB68     		ldr	r3, [r7, #12]
  75 003a 0022     		mov	r2, #0
  76 003c 9A80     		strh	r2, [r3, #4]
 138:../Generated_Code/SS1.c ****   DeviceDataPrv->InpDataNumReq = 0x00U; /* Clear the counter of characters to receive by ReceiveBlo
  77              		.loc 1 138 0
  78 003e FB68     		ldr	r3, [r7, #12]
  79 0040 0022     		mov	r2, #0
  80 0042 9A81     		strh	r2, [r3, #12]
 139:../Generated_Code/SS1.c ****   DeviceDataPrv->InpDataPtr = NULL;    /* Clear the buffer pointer for received characters */
  81              		.loc 1 139 0
  82 0044 FB68     		ldr	r3, [r7, #12]
  83 0046 0022     		mov	r2, #0
  84 0048 9A60     		str	r2, [r3, #8]
 140:../Generated_Code/SS1.c ****   /* Clear the transmit counters and pointer */
 141:../Generated_Code/SS1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters */
  85              		.loc 1 141 0
  86 004a FB68     		ldr	r3, [r7, #12]
  87 004c 0022     		mov	r2, #0
  88 004e DA81     		strh	r2, [r3, #14]
 142:../Generated_Code/SS1.c ****   DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBlock(
  89              		.loc 1 142 0
  90 0050 FB68     		ldr	r3, [r7, #12]
  91 0052 0022     		mov	r2, #0
  92 0054 9A82     		strh	r2, [r3, #20]
 143:../Generated_Code/SS1.c ****   DeviceDataPrv->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  93              		.loc 1 143 0
  94 0056 FB68     		ldr	r3, [r7, #12]
  95 0058 0022     		mov	r2, #0
  96 005a 1A61     		str	r2, [r3, #16]
 144:../Generated_Code/SS1.c ****   /* SIM_SCGC4: SPI0=1 */
 145:../Generated_Code/SS1.c ****   SIM_SCGC4 |= SIM_SCGC4_SPI0_MASK;                                                   
  97              		.loc 1 145 0
  98 005c 324A     		ldr	r2, .L2+8
  99 005e 3249     		ldr	r1, .L2+8
 100 0060 324B     		ldr	r3, .L2+12
 101 0062 CB58     		ldr	r3, [r1, r3]
 102 0064 8021     		mov	r1, #128
 103 0066 C903     		lsl	r1, r1, #15
 104 0068 1943     		orr	r1, r3
 105 006a 304B     		ldr	r3, .L2+12
 106 006c D150     		str	r1, [r2, r3]
 146:../Generated_Code/SS1.c ****   /* SPI0_C1: SPIE=0,SPE=0,SPTIE=0,MSTR=0,CPOL=0,CPHA=1,SSOE=0,LSBFE=0 */
 147:../Generated_Code/SS1.c ****   SPI0_C1 = SPI_C1_CPHA_MASK;          /* Clear control register */
 107              		.loc 1 147 0
 108 006e 304B     		ldr	r3, .L2+16
 109 0070 0422     		mov	r2, #4
 110 0072 1A70     		strb	r2, [r3]
 148:../Generated_Code/SS1.c ****   /* Interrupt vector(s) priority setting */
 149:../Generated_Code/SS1.c ****   /* NVIC_IPR2: PRI_10=0x80 */
 150:../Generated_Code/SS1.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 111              		.loc 1 150 0
 112 0074 2F4A     		ldr	r2, .L2+20
 113 0076 2F49     		ldr	r1, .L2+20
 114 0078 C223     		mov	r3, #194
 115 007a 9B00     		lsl	r3, r3, #2
 116 007c CB58     		ldr	r3, [r1, r3]
 117 007e 191C     		mov	r1, r3
 118 0080 2D4B     		ldr	r3, .L2+24
 119 0082 0B40     		and	r3, r1
 120 0084 8021     		mov	r1, #128
 121 0086 0904     		lsl	r1, r1, #16
 122 0088 1943     		orr	r1, r3
 123 008a C223     		mov	r3, #194
 124 008c 9B00     		lsl	r3, r3, #2
 125 008e D150     		str	r1, [r2, r3]
 151:../Generated_Code/SS1.c ****                NVIC_IP_PRI_10(0x7F)
 152:../Generated_Code/SS1.c ****               )) | (uint32_t)(
 153:../Generated_Code/SS1.c ****                NVIC_IP_PRI_10(0x80)
 154:../Generated_Code/SS1.c ****               ));                                                  
 155:../Generated_Code/SS1.c ****   /* NVIC_ISER: SETENA|=0x0400 */
 156:../Generated_Code/SS1.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0400);                                                   
 126              		.loc 1 156 0
 127 0090 284B     		ldr	r3, .L2+20
 128 0092 284A     		ldr	r2, .L2+20
 129 0094 1268     		ldr	r2, [r2]
 130 0096 8021     		mov	r1, #128
 131 0098 C900     		lsl	r1, r1, #3
 132 009a 0A43     		orr	r2, r1
 133 009c 1A60     		str	r2, [r3]
 157:../Generated_Code/SS1.c ****   /* PORTC_PCR6: ISF=0,MUX=2 */
 158:../Generated_Code/SS1.c ****   PORTC_PCR6 = (uint32_t)((PORTC_PCR6 & (uint32_t)~(uint32_t)(
 134              		.loc 1 158 0
 135 009e 274B     		ldr	r3, .L2+28
 136 00a0 264A     		ldr	r2, .L2+28
 137 00a2 9269     		ldr	r2, [r2, #24]
 138 00a4 111C     		mov	r1, r2
 139 00a6 264A     		ldr	r2, .L2+32
 140 00a8 0A40     		and	r2, r1
 141 00aa 8021     		mov	r1, #128
 142 00ac 8900     		lsl	r1, r1, #2
 143 00ae 0A43     		orr	r2, r1
 144 00b0 9A61     		str	r2, [r3, #24]
 159:../Generated_Code/SS1.c ****                 PORT_PCR_ISF_MASK |
 160:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x05)
 161:../Generated_Code/SS1.c ****                )) | (uint32_t)(
 162:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x02)
 163:../Generated_Code/SS1.c ****                ));                                                  
 164:../Generated_Code/SS1.c ****   /* PORTC_PCR7: ISF=0,MUX=2 */
 165:../Generated_Code/SS1.c ****   PORTC_PCR7 = (uint32_t)((PORTC_PCR7 & (uint32_t)~(uint32_t)(
 145              		.loc 1 165 0
 146 00b2 224B     		ldr	r3, .L2+28
 147 00b4 214A     		ldr	r2, .L2+28
 148 00b6 D269     		ldr	r2, [r2, #28]
 149 00b8 111C     		mov	r1, r2
 150 00ba 214A     		ldr	r2, .L2+32
 151 00bc 0A40     		and	r2, r1
 152 00be 8021     		mov	r1, #128
 153 00c0 8900     		lsl	r1, r1, #2
 154 00c2 0A43     		orr	r2, r1
 155 00c4 DA61     		str	r2, [r3, #28]
 166:../Generated_Code/SS1.c ****                 PORT_PCR_ISF_MASK |
 167:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x05)
 168:../Generated_Code/SS1.c ****                )) | (uint32_t)(
 169:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x02)
 170:../Generated_Code/SS1.c ****                ));                                                  
 171:../Generated_Code/SS1.c ****   /* PORTC_PCR5: ISF=0,MUX=2 */
 172:../Generated_Code/SS1.c ****   PORTC_PCR5 = (uint32_t)((PORTC_PCR5 & (uint32_t)~(uint32_t)(
 156              		.loc 1 172 0
 157 00c6 1D4B     		ldr	r3, .L2+28
 158 00c8 1C4A     		ldr	r2, .L2+28
 159 00ca 5269     		ldr	r2, [r2, #20]
 160 00cc 111C     		mov	r1, r2
 161 00ce 1C4A     		ldr	r2, .L2+32
 162 00d0 0A40     		and	r2, r1
 163 00d2 8021     		mov	r1, #128
 164 00d4 8900     		lsl	r1, r1, #2
 165 00d6 0A43     		orr	r2, r1
 166 00d8 5A61     		str	r2, [r3, #20]
 173:../Generated_Code/SS1.c ****                 PORT_PCR_ISF_MASK |
 174:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x05)
 175:../Generated_Code/SS1.c ****                )) | (uint32_t)(
 176:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x02)
 177:../Generated_Code/SS1.c ****                ));                                                  
 178:../Generated_Code/SS1.c ****   /* PORTC_PCR4: ISF=0,MUX=2 */
 179:../Generated_Code/SS1.c ****   PORTC_PCR4 = (uint32_t)((PORTC_PCR4 & (uint32_t)~(uint32_t)(
 167              		.loc 1 179 0
 168 00da 184B     		ldr	r3, .L2+28
 169 00dc 174A     		ldr	r2, .L2+28
 170 00de 1269     		ldr	r2, [r2, #16]
 171 00e0 111C     		mov	r1, r2
 172 00e2 174A     		ldr	r2, .L2+32
 173 00e4 0A40     		and	r2, r1
 174 00e6 8021     		mov	r1, #128
 175 00e8 8900     		lsl	r1, r1, #2
 176 00ea 0A43     		orr	r2, r1
 177 00ec 1A61     		str	r2, [r3, #16]
 180:../Generated_Code/SS1.c ****                 PORT_PCR_ISF_MASK |
 181:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x05)
 182:../Generated_Code/SS1.c ****                )) | (uint32_t)(
 183:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x02)
 184:../Generated_Code/SS1.c ****                ));                                                  
 185:../Generated_Code/SS1.c ****   /* SPI0_C1: SPIE=1,SPE=0,SPTIE=0,MSTR=0,CPOL=0,CPHA=0,SSOE=0,LSBFE=0 */
 186:../Generated_Code/SS1.c ****   SPI0_C1 = SPI_C1_SPIE_MASK;          /* Set Configuration register */
 178              		.loc 1 186 0
 179 00ee 104B     		ldr	r3, .L2+16
 180 00f0 8022     		mov	r2, #128
 181 00f2 1A70     		strb	r2, [r3]
 187:../Generated_Code/SS1.c ****   /* SPI0_C2: SPMIE=0,??=0,TXDMAE=0,MODFEN=0,BIDIROE=0,RXDMAE=0,SPISWAI=0,SPC0=0 */
 188:../Generated_Code/SS1.c ****   SPI0_C2 = 0x00U;                     /* Set Configuration register */
 182              		.loc 1 188 0
 183 00f4 0E4B     		ldr	r3, .L2+16
 184 00f6 0022     		mov	r2, #0
 185 00f8 5A70     		strb	r2, [r3, #1]
 189:../Generated_Code/SS1.c ****   /* SPI0_BR: ??=0,SPPR=0,SPR=0 */
 190:../Generated_Code/SS1.c ****   SPI0_BR = 0x00U;                     /* Set baud rate register */
 186              		.loc 1 190 0
 187 00fa 0D4B     		ldr	r3, .L2+16
 188 00fc 0022     		mov	r2, #0
 189 00fe 9A70     		strb	r2, [r3, #2]
 191:../Generated_Code/SS1.c ****   /* SPI0_C1: SPE=1 */
 192:../Generated_Code/SS1.c ****   SPI0_C1 |= SPI_C1_SPE_MASK;          /* Enable device */
 190              		.loc 1 192 0
 191 0100 0B4B     		ldr	r3, .L2+16
 192 0102 0B4A     		ldr	r2, .L2+16
 193 0104 1278     		ldrb	r2, [r2]
 194 0106 D2B2     		uxtb	r2, r2
 195 0108 4021     		mov	r1, #64
 196 010a 0A43     		orr	r2, r1
 197 010c D2B2     		uxtb	r2, r2
 198 010e 1A70     		strb	r2, [r3]
 193:../Generated_Code/SS1.c ****   /* Registration of the device structure */
 194:../Generated_Code/SS1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_SS1_ID,DeviceDataPrv);
 199              		.loc 1 194 0
 200 0110 0C4B     		ldr	r3, .L2+36
 201 0112 FA68     		ldr	r2, [r7, #12]
 202 0114 5A64     		str	r2, [r3, #68]
 195:../Generated_Code/SS1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 203              		.loc 1 195 0
 204 0116 FB68     		ldr	r3, [r7, #12]
 196:../Generated_Code/SS1.c **** }
 205              		.loc 1 196 0
 206 0118 181C     		mov	r0, r3
 207 011a BD46     		mov	sp, r7
 208 011c 04B0     		add	sp, sp, #16
 209              		@ sp needed for prologue
 210 011e 80BD     		pop	{r7, pc}
 211              	.L3:
 212              		.align	2
 213              	.L2:
 214 0120 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 215 0124 00000000 		.word	SS1_Interrupt
 216 0128 00700440 		.word	1074032640
 217 012c 34100000 		.word	4148
 218 0130 00600740 		.word	1074225152
 219 0134 00E100E0 		.word	-536813312
 220 0138 FFFF00FF 		.word	-16711681
 221 013c 00B00440 		.word	1074049024
 222 0140 FFF8FFFE 		.word	-16779009
 223 0144 00000000 		.word	PE_LDD_DeviceDataList
 224              		.cfi_endproc
 225              	.LFE0:
 227              		.section	.text.SS1_Deinit,"ax",%progbits
 228              		.align	2
 229              		.global	SS1_Deinit
 230              		.code	16
 231              		.thumb_func
 233              	SS1_Deinit:
 234              	.LFB1:
 197:../Generated_Code/SS1.c **** 
 198:../Generated_Code/SS1.c **** /*
 199:../Generated_Code/SS1.c **** ** ===================================================================
 200:../Generated_Code/SS1.c **** **     Method      :  SS1_Deinit (component SPISlave_LDD)
 201:../Generated_Code/SS1.c **** **
 202:../Generated_Code/SS1.c **** **     Description :
 203:../Generated_Code/SS1.c **** **         This method deinitializes the device. It switches off the
 204:../Generated_Code/SS1.c **** **         device, frees the device data structure memory, interrupts
 205:../Generated_Code/SS1.c **** **         vectors, etc.
 206:../Generated_Code/SS1.c **** **     Parameters  :
 207:../Generated_Code/SS1.c **** **         NAME            - DESCRIPTION
 208:../Generated_Code/SS1.c **** **       * DeviceDataPtr   - Device data structure
 209:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 210:../Generated_Code/SS1.c **** **     Returns     : Nothing
 211:../Generated_Code/SS1.c **** ** ===================================================================
 212:../Generated_Code/SS1.c **** */
 213:../Generated_Code/SS1.c **** void SS1_Deinit(LDD_TDeviceData *DeviceDataPtr)
 214:../Generated_Code/SS1.c **** {
 235              		.loc 1 214 0
 236              		.cfi_startproc
 237 0000 80B5     		push	{r7, lr}
 238              	.LCFI3:
 239              		.cfi_def_cfa_offset 8
 240              		.cfi_offset 7, -8
 241              		.cfi_offset 14, -4
 242 0002 82B0     		sub	sp, sp, #8
 243              	.LCFI4:
 244              		.cfi_def_cfa_offset 16
 245 0004 00AF     		add	r7, sp, #0
 246              	.LCFI5:
 247              		.cfi_def_cfa_register 7
 248 0006 7860     		str	r0, [r7, #4]
 215:../Generated_Code/SS1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 216:../Generated_Code/SS1.c ****   /* SPI0_C1: SPIE=0,SPE=0,SPTIE=0,MSTR=0,CPOL=0,CPHA=1,SSOE=0,LSBFE=0 */
 217:../Generated_Code/SS1.c ****   SPI0_C1 = SPI_C1_CPHA_MASK;          /* Disable device */
 249              		.loc 1 217 0
 250 0008 0D4B     		ldr	r3, .L5
 251 000a 0422     		mov	r2, #4
 252 000c 1A70     		strb	r2, [r3]
 218:../Generated_Code/SS1.c ****   /* Restoring the interrupt vector */
 219:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} Restore interrupt vector (function handler and ISR parameter) */
 220:../Generated_Code/SS1.c ****   /* Note: Exception handler for interrupt is not restored, because it was not modified */
 221:../Generated_Code/SS1.c ****   (void)_int_install_isr(LDD_ivIndex_INT_SPI0, ((SS1_TDeviceDataPtr)DeviceDataPtr)->SavedISRSetting
 253              		.loc 1 221 0
 254 000e 7B68     		ldr	r3, [r7, #4]
 255 0010 9A69     		ldr	r2, [r3, #24]
 256 0012 7B68     		ldr	r3, [r7, #4]
 257 0014 DB69     		ldr	r3, [r3, #28]
 258 0016 1A20     		mov	r0, #26
 259 0018 111C     		mov	r1, r2
 260 001a 1A1C     		mov	r2, r3
 261 001c FFF7FEFF 		bl	_int_install_isr
 222:../Generated_Code/SS1.c ****   /* Unregistration of the device structure */
 223:../Generated_Code/SS1.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_SS1_ID);
 262              		.loc 1 223 0
 263 0020 084B     		ldr	r3, .L5+4
 264 0022 0022     		mov	r2, #0
 265 0024 5A64     		str	r2, [r3, #68]
 224:../Generated_Code/SS1.c ****   /* Deallocation of the device structure */
 225:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 226:../Generated_Code/SS1.c ****   /* SIM_SCGC4: SPI0=0 */
 227:../Generated_Code/SS1.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_SPI0_MASK);                                         
 266              		.loc 1 227 0
 267 0026 084A     		ldr	r2, .L5+8
 268 0028 0749     		ldr	r1, .L5+8
 269 002a 084B     		ldr	r3, .L5+12
 270 002c CB58     		ldr	r3, [r1, r3]
 271 002e 191C     		mov	r1, r3
 272 0030 074B     		ldr	r3, .L5+16
 273 0032 1940     		and	r1, r3
 274 0034 054B     		ldr	r3, .L5+12
 275 0036 D150     		str	r1, [r2, r3]
 228:../Generated_Code/SS1.c **** }
 276              		.loc 1 228 0
 277 0038 BD46     		mov	sp, r7
 278 003a 02B0     		add	sp, sp, #8
 279              		@ sp needed for prologue
 280 003c 80BD     		pop	{r7, pc}
 281              	.L6:
 282 003e C046     		.align	2
 283              	.L5:
 284 0040 00600740 		.word	1074225152
 285 0044 00000000 		.word	PE_LDD_DeviceDataList
 286 0048 00700440 		.word	1074032640
 287 004c 34100000 		.word	4148
 288 0050 FFFFBFFF 		.word	-4194305
 289              		.cfi_endproc
 290              	.LFE1:
 292              		.section	.text.SS1_ReceiveBlock,"ax",%progbits
 293              		.align	2
 294              		.global	SS1_ReceiveBlock
 295              		.code	16
 296              		.thumb_func
 298              	SS1_ReceiveBlock:
 299              	.LFB2:
 229:../Generated_Code/SS1.c **** 
 230:../Generated_Code/SS1.c **** /*
 231:../Generated_Code/SS1.c **** ** ===================================================================
 232:../Generated_Code/SS1.c **** **     Method      :  SS1_ReceiveBlock (component SPISlave_LDD)
 233:../Generated_Code/SS1.c **** **
 234:../Generated_Code/SS1.c **** **     Description :
 235:../Generated_Code/SS1.c **** **         This method specifies the number of data to receive. The
 236:../Generated_Code/SS1.c **** **         method returns ERR_BUSY until the specified number of
 237:../Generated_Code/SS1.c **** **         characters is received. The method <CancelBlockReception>
 238:../Generated_Code/SS1.c **** **         can be used to cancel a running receive operation.
 239:../Generated_Code/SS1.c **** **     Parameters  :
 240:../Generated_Code/SS1.c **** **         NAME            - DESCRIPTION
 241:../Generated_Code/SS1.c **** **       * DeviceDataPtr   - Device data structure
 242:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 243:../Generated_Code/SS1.c **** **       * BufferPtr       - Pointer to A buffer where
 244:../Generated_Code/SS1.c **** **                           received characters will be stored.
 245:../Generated_Code/SS1.c **** **         Size            - Size of the block
 246:../Generated_Code/SS1.c **** **     Returns     :
 247:../Generated_Code/SS1.c **** **         ---             - Error code, possible codes:
 248:../Generated_Code/SS1.c **** **                           ERR_OK - OK
 249:../Generated_Code/SS1.c **** **                           ERR_DISABLED - Component is disabled
 250:../Generated_Code/SS1.c **** **                           ERR_BUSY - The previous receive request is
 251:../Generated_Code/SS1.c **** **                           pending
 252:../Generated_Code/SS1.c **** ** ===================================================================
 253:../Generated_Code/SS1.c **** */
 254:../Generated_Code/SS1.c **** LDD_TError SS1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 255:../Generated_Code/SS1.c **** {
 300              		.loc 1 255 0
 301              		.cfi_startproc
 302 0000 80B5     		push	{r7, lr}
 303              	.LCFI6:
 304              		.cfi_def_cfa_offset 8
 305              		.cfi_offset 7, -8
 306              		.cfi_offset 14, -4
 307 0002 84B0     		sub	sp, sp, #16
 308              	.LCFI7:
 309              		.cfi_def_cfa_offset 24
 310 0004 00AF     		add	r7, sp, #0
 311              	.LCFI8:
 312              		.cfi_def_cfa_register 7
 313 0006 F860     		str	r0, [r7, #12]
 314 0008 B960     		str	r1, [r7, #8]
 315 000a BB1D     		add	r3, r7, #6
 316 000c 1A80     		strh	r2, [r3]
 256:../Generated_Code/SS1.c ****   if (((SS1_TDeviceDataPtr)DeviceDataPtr)->InpDataNumReq != 0x00U) { /* Is the previous receive ope
 317              		.loc 1 256 0
 318 000e FB68     		ldr	r3, [r7, #12]
 319 0010 9B89     		ldrh	r3, [r3, #12]
 320 0012 002B     		cmp	r3, #0
 321 0014 01D0     		beq	.L8
 257:../Generated_Code/SS1.c ****     return ERR_BUSY;                   /* If yes then error */
 322              		.loc 1 257 0
 323 0016 0823     		mov	r3, #8
 324 0018 17E0     		b	.L9
 325              	.L8:
 258:../Generated_Code/SS1.c ****   }
 259:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} Critical section begin (RTOS function call is defined by MQXLite RTOS A
 260:../Generated_Code/SS1.c ****   _int_disable();
 326              		.loc 1 260 0
 327 001a FFF7FEFF 		bl	_int_disable
 261:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->InpDataPtr = BufferPtr; /* Store a pointer to the input data
 328              		.loc 1 261 0
 329 001e FB68     		ldr	r3, [r7, #12]
 330 0020 BA68     		ldr	r2, [r7, #8]
 331 0022 9A60     		str	r2, [r3, #8]
 262:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->InpDataNumReq = Size; /* Store a number of characters to be 
 332              		.loc 1 262 0
 333 0024 FB68     		ldr	r3, [r7, #12]
 334 0026 BA1D     		add	r2, r7, #6
 335 0028 1288     		ldrh	r2, [r2]
 336 002a 9A81     		strh	r2, [r3, #12]
 263:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->InpRecvDataNum = 0x00U; /* Set number of received characters
 337              		.loc 1 263 0
 338 002c FB68     		ldr	r3, [r7, #12]
 339 002e 0022     		mov	r2, #0
 340 0030 9A80     		strh	r2, [r3, #4]
 264:../Generated_Code/SS1.c ****   SPI_PDD_EnableInterruptMask(SPI0_BASE_PTR, SPI_PDD_RX_BUFFER_FULL_OR_FAULT); /* Enable Rx buffer 
 341              		.loc 1 264 0
 342 0032 084B     		ldr	r3, .L10
 343 0034 074A     		ldr	r2, .L10
 344 0036 1278     		ldrb	r2, [r2]
 345 0038 D2B2     		uxtb	r2, r2
 346 003a 8021     		mov	r1, #128
 347 003c 4942     		neg	r1, r1
 348 003e 0A43     		orr	r2, r1
 349 0040 D2B2     		uxtb	r2, r2
 350 0042 1A70     		strb	r2, [r3]
 265:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} Critical section ends (RTOS function call is defined by MQXLite RTOS Ad
 266:../Generated_Code/SS1.c ****   _int_enable();
 351              		.loc 1 266 0
 352 0044 FFF7FEFF 		bl	_int_enable
 267:../Generated_Code/SS1.c ****   return ERR_OK;                       /* OK */
 353              		.loc 1 267 0
 354 0048 0023     		mov	r3, #0
 355              	.L9:
 268:../Generated_Code/SS1.c **** }
 356              		.loc 1 268 0
 357 004a 181C     		mov	r0, r3
 358 004c BD46     		mov	sp, r7
 359 004e 04B0     		add	sp, sp, #16
 360              		@ sp needed for prologue
 361 0050 80BD     		pop	{r7, pc}
 362              	.L11:
 363 0052 C046     		.align	2
 364              	.L10:
 365 0054 00600740 		.word	1074225152
 366              		.cfi_endproc
 367              	.LFE2:
 369              		.section	.text.SS1_SendBlock,"ax",%progbits
 370              		.align	2
 371              		.global	SS1_SendBlock
 372              		.code	16
 373              		.thumb_func
 375              	SS1_SendBlock:
 376              	.LFB3:
 269:../Generated_Code/SS1.c **** 
 270:../Generated_Code/SS1.c **** /*
 271:../Generated_Code/SS1.c **** ** ===================================================================
 272:../Generated_Code/SS1.c **** **     Method      :  SS1_SendBlock (component SPISlave_LDD)
 273:../Generated_Code/SS1.c **** **
 274:../Generated_Code/SS1.c **** **     Description :
 275:../Generated_Code/SS1.c **** **         This method sends a block of characters. The method returns
 276:../Generated_Code/SS1.c **** **         ERR_BUSY when the previous block transmission is not
 277:../Generated_Code/SS1.c **** **         completed. The method <CancelBlockTransmission> can be used
 278:../Generated_Code/SS1.c **** **         to cancel a transmit operation.
 279:../Generated_Code/SS1.c **** **     Parameters  :
 280:../Generated_Code/SS1.c **** **         NAME            - DESCRIPTION
 281:../Generated_Code/SS1.c **** **       * DeviceDataPtr   - Device data structure
 282:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 283:../Generated_Code/SS1.c **** **       * BufferPtr       - Pointer to the block of data
 284:../Generated_Code/SS1.c **** **                           to send.
 285:../Generated_Code/SS1.c **** **         Size            - Number of characters in the buffer.
 286:../Generated_Code/SS1.c **** **     Returns     :
 287:../Generated_Code/SS1.c **** **         ---             - Error code, possible codes:
 288:../Generated_Code/SS1.c **** **                           ERR_OK - OK
 289:../Generated_Code/SS1.c **** **                           ERR_DISABLED - Component is disabled
 290:../Generated_Code/SS1.c **** **                           ERR_BUSY - The previous transmit request is
 291:../Generated_Code/SS1.c **** **                           pending
 292:../Generated_Code/SS1.c **** ** ===================================================================
 293:../Generated_Code/SS1.c **** */
 294:../Generated_Code/SS1.c **** LDD_TError SS1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 295:../Generated_Code/SS1.c **** {
 377              		.loc 1 295 0
 378              		.cfi_startproc
 379 0000 80B5     		push	{r7, lr}
 380              	.LCFI9:
 381              		.cfi_def_cfa_offset 8
 382              		.cfi_offset 7, -8
 383              		.cfi_offset 14, -4
 384 0002 84B0     		sub	sp, sp, #16
 385              	.LCFI10:
 386              		.cfi_def_cfa_offset 24
 387 0004 00AF     		add	r7, sp, #0
 388              	.LCFI11:
 389              		.cfi_def_cfa_register 7
 390 0006 F860     		str	r0, [r7, #12]
 391 0008 B960     		str	r1, [r7, #8]
 392 000a BB1D     		add	r3, r7, #6
 393 000c 1A80     		strh	r2, [r3]
 296:../Generated_Code/SS1.c ****   if (((SS1_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq != 0x00U) { /* Is the previous transmit op
 394              		.loc 1 296 0
 395 000e FB68     		ldr	r3, [r7, #12]
 396 0010 9B8A     		ldrh	r3, [r3, #20]
 397 0012 002B     		cmp	r3, #0
 398 0014 01D0     		beq	.L13
 297:../Generated_Code/SS1.c ****     return ERR_BUSY;                   /* If yes then error */
 399              		.loc 1 297 0
 400 0016 0823     		mov	r3, #8
 401 0018 16E0     		b	.L14
 402              	.L13:
 298:../Generated_Code/SS1.c ****   }
 299:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} Critical section begin (RTOS function call is defined by MQXLite RTOS A
 300:../Generated_Code/SS1.c ****   _int_disable();
 403              		.loc 1 300 0
 404 001a FFF7FEFF 		bl	_int_disable
 301:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->OutDataPtr = BufferPtr; /* Set a pointer to the output data.
 405              		.loc 1 301 0
 406 001e FB68     		ldr	r3, [r7, #12]
 407 0020 BA68     		ldr	r2, [r7, #8]
 408 0022 1A61     		str	r2, [r3, #16]
 302:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq = Size; /* Set the counter of characters to be
 409              		.loc 1 302 0
 410 0024 FB68     		ldr	r3, [r7, #12]
 411 0026 BA1D     		add	r2, r7, #6
 412 0028 1288     		ldrh	r2, [r2]
 413 002a 9A82     		strh	r2, [r3, #20]
 303:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->OutSentDataNum = 0x00U; /* Clear the counter of sent charact
 414              		.loc 1 303 0
 415 002c FB68     		ldr	r3, [r7, #12]
 416 002e 0022     		mov	r2, #0
 417 0030 DA81     		strh	r2, [r3, #14]
 304:../Generated_Code/SS1.c ****   SPI_PDD_EnableInterruptMask(SPI0_BASE_PTR, SPI_PDD_TX_BUFFER_EMPTY); /* Enable Tx empy interrupt 
 418              		.loc 1 304 0
 419 0032 074B     		ldr	r3, .L15
 420 0034 064A     		ldr	r2, .L15
 421 0036 1278     		ldrb	r2, [r2]
 422 0038 D2B2     		uxtb	r2, r2
 423 003a 2021     		mov	r1, #32
 424 003c 0A43     		orr	r2, r1
 425 003e D2B2     		uxtb	r2, r2
 426 0040 1A70     		strb	r2, [r3]
 305:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} Critical section ends (RTOS function call is defined by MQXLite RTOS Ad
 306:../Generated_Code/SS1.c ****   _int_enable();
 427              		.loc 1 306 0
 428 0042 FFF7FEFF 		bl	_int_enable
 307:../Generated_Code/SS1.c ****   return ERR_OK;                       /* OK */
 429              		.loc 1 307 0
 430 0046 0023     		mov	r3, #0
 431              	.L14:
 308:../Generated_Code/SS1.c **** }
 432              		.loc 1 308 0
 433 0048 181C     		mov	r0, r3
 434 004a BD46     		mov	sp, r7
 435 004c 04B0     		add	sp, sp, #16
 436              		@ sp needed for prologue
 437 004e 80BD     		pop	{r7, pc}
 438              	.L16:
 439              		.align	2
 440              	.L15:
 441 0050 00600740 		.word	1074225152
 442              		.cfi_endproc
 443              	.LFE3:
 445              		.section	.text.SS1_GetReceivedDataNum,"ax",%progbits
 446              		.align	2
 447              		.global	SS1_GetReceivedDataNum
 448              		.code	16
 449              		.thumb_func
 451              	SS1_GetReceivedDataNum:
 452              	.LFB4:
 309:../Generated_Code/SS1.c **** 
 310:../Generated_Code/SS1.c **** /*
 311:../Generated_Code/SS1.c **** ** ===================================================================
 312:../Generated_Code/SS1.c **** **     Method      :  SS1_GetReceivedDataNum (component SPISlave_LDD)
 313:../Generated_Code/SS1.c **** **
 314:../Generated_Code/SS1.c **** **     Description :
 315:../Generated_Code/SS1.c **** **         Returns the number of received characters in the receive
 316:../Generated_Code/SS1.c **** **         buffer. This method is available only if the ReceiveBlock
 317:../Generated_Code/SS1.c **** **         method is enabled.
 318:../Generated_Code/SS1.c **** **     Parameters  :
 319:../Generated_Code/SS1.c **** **         NAME            - DESCRIPTION
 320:../Generated_Code/SS1.c **** **       * DeviceDataPtr   - Device data structure
 321:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 322:../Generated_Code/SS1.c **** **     Returns     :
 323:../Generated_Code/SS1.c **** **         ---             - The number of characters in the input
 324:../Generated_Code/SS1.c **** **                           buffer.
 325:../Generated_Code/SS1.c **** ** ===================================================================
 326:../Generated_Code/SS1.c **** */
 327:../Generated_Code/SS1.c **** uint16_t SS1_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr)
 328:../Generated_Code/SS1.c **** {
 453              		.loc 1 328 0
 454              		.cfi_startproc
 455 0000 80B5     		push	{r7, lr}
 456              	.LCFI12:
 457              		.cfi_def_cfa_offset 8
 458              		.cfi_offset 7, -8
 459              		.cfi_offset 14, -4
 460 0002 82B0     		sub	sp, sp, #8
 461              	.LCFI13:
 462              		.cfi_def_cfa_offset 16
 463 0004 00AF     		add	r7, sp, #0
 464              	.LCFI14:
 465              		.cfi_def_cfa_register 7
 466 0006 7860     		str	r0, [r7, #4]
 329:../Generated_Code/SS1.c ****   return (((SS1_TDeviceDataPtr)DeviceDataPtr)->InpRecvDataNum); /* Return the number of received ch
 467              		.loc 1 329 0
 468 0008 7B68     		ldr	r3, [r7, #4]
 469 000a 9B88     		ldrh	r3, [r3, #4]
 330:../Generated_Code/SS1.c **** }
 470              		.loc 1 330 0
 471 000c 181C     		mov	r0, r3
 472 000e BD46     		mov	sp, r7
 473 0010 02B0     		add	sp, sp, #8
 474              		@ sp needed for prologue
 475 0012 80BD     		pop	{r7, pc}
 476              		.cfi_endproc
 477              	.LFE4:
 479              		.section	.text.SS1_GetSentDataNum,"ax",%progbits
 480              		.align	2
 481              		.global	SS1_GetSentDataNum
 482              		.code	16
 483              		.thumb_func
 485              	SS1_GetSentDataNum:
 486              	.LFB5:
 331:../Generated_Code/SS1.c **** 
 332:../Generated_Code/SS1.c **** /*
 333:../Generated_Code/SS1.c **** ** ===================================================================
 334:../Generated_Code/SS1.c **** **     Method      :  SS1_GetSentDataNum (component SPISlave_LDD)
 335:../Generated_Code/SS1.c **** **
 336:../Generated_Code/SS1.c **** **     Description :
 337:../Generated_Code/SS1.c **** **         Returns the number of sent characters. This method is
 338:../Generated_Code/SS1.c **** **         available only if method SendBlock is enabled.
 339:../Generated_Code/SS1.c **** **     Parameters  :
 340:../Generated_Code/SS1.c **** **         NAME            - DESCRIPTION
 341:../Generated_Code/SS1.c **** **       * DeviceDataPtr   - Device data structure
 342:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 343:../Generated_Code/SS1.c **** **     Returns     :
 344:../Generated_Code/SS1.c **** **         ---             - The number of characters in the output
 345:../Generated_Code/SS1.c **** **                           buffer.
 346:../Generated_Code/SS1.c **** ** ===================================================================
 347:../Generated_Code/SS1.c **** */
 348:../Generated_Code/SS1.c **** uint16_t SS1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr)
 349:../Generated_Code/SS1.c **** {
 487              		.loc 1 349 0
 488              		.cfi_startproc
 489 0000 80B5     		push	{r7, lr}
 490              	.LCFI15:
 491              		.cfi_def_cfa_offset 8
 492              		.cfi_offset 7, -8
 493              		.cfi_offset 14, -4
 494 0002 82B0     		sub	sp, sp, #8
 495              	.LCFI16:
 496              		.cfi_def_cfa_offset 16
 497 0004 00AF     		add	r7, sp, #0
 498              	.LCFI17:
 499              		.cfi_def_cfa_register 7
 500 0006 7860     		str	r0, [r7, #4]
 350:../Generated_Code/SS1.c ****   return (((SS1_TDeviceDataPtr)DeviceDataPtr)->OutSentDataNum); /* Return the number of sent charac
 501              		.loc 1 350 0
 502 0008 7B68     		ldr	r3, [r7, #4]
 503 000a DB89     		ldrh	r3, [r3, #14]
 351:../Generated_Code/SS1.c **** }
 504              		.loc 1 351 0
 505 000c 181C     		mov	r0, r3
 506 000e BD46     		mov	sp, r7
 507 0010 02B0     		add	sp, sp, #8
 508              		@ sp needed for prologue
 509 0012 80BD     		pop	{r7, pc}
 510              		.cfi_endproc
 511              	.LFE5:
 513              		.section	.text.SS1_Interrupt,"ax",%progbits
 514              		.align	2
 515              		.global	SS1_Interrupt
 516              		.code	16
 517              		.thumb_func
 519              	SS1_Interrupt:
 520              	.LFB6:
 352:../Generated_Code/SS1.c **** 
 353:../Generated_Code/SS1.c **** /*
 354:../Generated_Code/SS1.c **** ** ===================================================================
 355:../Generated_Code/SS1.c **** **     Method      :  SS1_Interrupt (component SPISlave_LDD)
 356:../Generated_Code/SS1.c **** **
 357:../Generated_Code/SS1.c **** **     Description :
 358:../Generated_Code/SS1.c **** **         The ISR function handling the device receive/transmit 
 359:../Generated_Code/SS1.c **** **         interrupt.
 360:../Generated_Code/SS1.c **** **         This method is internal. It is used by Processor Expert only.
 361:../Generated_Code/SS1.c **** ** ===================================================================
 362:../Generated_Code/SS1.c **** */
 363:../Generated_Code/SS1.c **** void SS1_Interrupt(LDD_RTOS_TISRParameter _isrParameter)
 364:../Generated_Code/SS1.c **** {
 521              		.loc 1 364 0
 522              		.cfi_startproc
 523 0000 80B5     		push	{r7, lr}
 524              	.LCFI18:
 525              		.cfi_def_cfa_offset 8
 526              		.cfi_offset 7, -8
 527              		.cfi_offset 14, -4
 528 0002 84B0     		sub	sp, sp, #16
 529              	.LCFI19:
 530              		.cfi_def_cfa_offset 24
 531 0004 00AF     		add	r7, sp, #0
 532              	.LCFI20:
 533              		.cfi_def_cfa_register 7
 534 0006 7860     		str	r0, [r7, #4]
 365:../Generated_Code/SS1.c ****   /* {MQXLite RTOS Adapter} ISR parameter is passed as parameter from RTOS interrupt dispatcher */
 366:../Generated_Code/SS1.c ****   SS1_TDeviceDataPtr DeviceDataPrv = (SS1_TDeviceDataPtr)_isrParameter;
 535              		.loc 1 366 0
 536 0008 7B68     		ldr	r3, [r7, #4]
 537 000a FB60     		str	r3, [r7, #12]
 367:../Generated_Code/SS1.c ****   uint8_t StatReg = SPI_PDD_ReadStatusReg(SPI0_BASE_PTR); /* Read status register */
 538              		.loc 1 367 0
 539 000c 334A     		ldr	r2, .L23
 540 000e 3B1C     		mov	r3, r7
 541 0010 0B33     		add	r3, r3, #11
 542 0012 D278     		ldrb	r2, [r2, #3]
 543 0014 1A70     		strb	r2, [r3]
 368:../Generated_Code/SS1.c **** 
 369:../Generated_Code/SS1.c ****   if ((StatReg & SPI_PDD_RX_BUFFER_FULL) != 0U) { /* Is any char in HW Rx buffer? */
 544              		.loc 1 369 0
 545 0016 3B1C     		mov	r3, r7
 546 0018 0B33     		add	r3, r3, #11
 547 001a 1B78     		ldrb	r3, [r3]
 548 001c 5BB2     		sxtb	r3, r3
 549 001e 002B     		cmp	r3, #0
 550 0020 28DA     		bge	.L20
 370:../Generated_Code/SS1.c ****     if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the receive block operation pending? */
 551              		.loc 1 370 0
 552 0022 FB68     		ldr	r3, [r7, #12]
 553 0024 9B89     		ldrh	r3, [r3, #12]
 554 0026 002B     		cmp	r3, #0
 555 0028 24D0     		beq	.L20
 371:../Generated_Code/SS1.c ****       *(DeviceDataPrv->InpDataPtr++) = SPI_PDD_ReadData8bit(SPI0_BASE_PTR); /* Put a character to t
 556              		.loc 1 371 0
 557 002a FB68     		ldr	r3, [r7, #12]
 558 002c 9B68     		ldr	r3, [r3, #8]
 559 002e 2B4A     		ldr	r2, .L23
 560 0030 5279     		ldrb	r2, [r2, #5]
 561 0032 D2B2     		uxtb	r2, r2
 562 0034 1A70     		strb	r2, [r3]
 563 0036 5A1C     		add	r2, r3, #1
 564 0038 FB68     		ldr	r3, [r7, #12]
 565 003a 9A60     		str	r2, [r3, #8]
 372:../Generated_Code/SS1.c ****       DeviceDataPrv->InpRecvDataNum++; /* Increment received char. counter */
 566              		.loc 1 372 0
 567 003c FB68     		ldr	r3, [r7, #12]
 568 003e 9B88     		ldrh	r3, [r3, #4]
 569 0040 0133     		add	r3, r3, #1
 570 0042 9AB2     		uxth	r2, r3
 571 0044 FB68     		ldr	r3, [r7, #12]
 572 0046 9A80     		strh	r2, [r3, #4]
 373:../Generated_Code/SS1.c ****       if (DeviceDataPrv->InpRecvDataNum == DeviceDataPrv->InpDataNumReq) { /* Is the requested numb
 573              		.loc 1 373 0
 574 0048 FB68     		ldr	r3, [r7, #12]
 575 004a 9A88     		ldrh	r2, [r3, #4]
 576 004c FB68     		ldr	r3, [r7, #12]
 577 004e 9B89     		ldrh	r3, [r3, #12]
 578 0050 9A42     		cmp	r2, r3
 579 0052 0FD1     		bne	.L20
 374:../Generated_Code/SS1.c ****         SPI_PDD_DisableInterruptMask(SPI0_BASE_PTR, SPI_PDD_RX_BUFFER_FULL_OR_FAULT); /* Disable Rx
 580              		.loc 1 374 0
 581 0054 214B     		ldr	r3, .L23
 582 0056 214A     		ldr	r2, .L23
 583 0058 1278     		ldrb	r2, [r2]
 584 005a D1B2     		uxtb	r1, r2
 585 005c 7F22     		mov	r2, #127
 586 005e 0A40     		and	r2, r1
 587 0060 D2B2     		uxtb	r2, r2
 588 0062 1A70     		strb	r2, [r3]
 375:../Generated_Code/SS1.c ****         DeviceDataPrv->InpDataNumReq = 0x00U; /* If yes then clear number of requested characters t
 589              		.loc 1 375 0
 590 0064 FB68     		ldr	r3, [r7, #12]
 591 0066 0022     		mov	r2, #0
 592 0068 9A81     		strh	r2, [r3, #12]
 376:../Generated_Code/SS1.c ****         SS1_OnBlockReceived(DeviceDataPrv->UserData);
 593              		.loc 1 376 0
 594 006a FB68     		ldr	r3, [r7, #12]
 595 006c 1B6A     		ldr	r3, [r3, #32]
 596 006e 181C     		mov	r0, r3
 597 0070 FFF7FEFF 		bl	SS1_OnBlockReceived
 598              	.L20:
 377:../Generated_Code/SS1.c ****       }
 378:../Generated_Code/SS1.c ****     }
 379:../Generated_Code/SS1.c ****   }
 380:../Generated_Code/SS1.c ****   if ((StatReg & SPI_PDD_TX_BUFFER_EMPTYG) != 0U) { /* Is HW Tx buffer empty? */
 599              		.loc 1 380 0
 600 0074 3B1C     		mov	r3, r7
 601 0076 0B33     		add	r3, r3, #11
 602 0078 1A78     		ldrb	r2, [r3]
 603 007a 2023     		mov	r3, #32
 604 007c 1340     		and	r3, r2
 605 007e 2AD0     		beq	.L19
 381:../Generated_Code/SS1.c ****     if (DeviceDataPrv->OutSentDataNum < DeviceDataPrv->OutDataNumReq) { /* Is number of sent charac
 606              		.loc 1 381 0
 607 0080 FB68     		ldr	r3, [r7, #12]
 608 0082 DA89     		ldrh	r2, [r3, #14]
 609 0084 FB68     		ldr	r3, [r7, #12]
 610 0086 9B8A     		ldrh	r3, [r3, #20]
 611 0088 9A42     		cmp	r2, r3
 612 008a 1CD2     		bcs	.L22
 382:../Generated_Code/SS1.c ****       SPI_PDD_WriteData8Bit(SPI0_BASE_PTR, (*((uint8_t *)DeviceDataPrv->OutDataPtr++))); /* Put a c
 613              		.loc 1 382 0
 614 008c 134A     		ldr	r2, .L23
 615 008e FB68     		ldr	r3, [r7, #12]
 616 0090 1B69     		ldr	r3, [r3, #16]
 617 0092 1978     		ldrb	r1, [r3]
 618 0094 5171     		strb	r1, [r2, #5]
 619 0096 5A1C     		add	r2, r3, #1
 620 0098 FB68     		ldr	r3, [r7, #12]
 621 009a 1A61     		str	r2, [r3, #16]
 383:../Generated_Code/SS1.c ****       DeviceDataPrv->OutSentDataNum++; /* Increment the counter of sent characters. */
 622              		.loc 1 383 0
 623 009c FB68     		ldr	r3, [r7, #12]
 624 009e DB89     		ldrh	r3, [r3, #14]
 625 00a0 0133     		add	r3, r3, #1
 626 00a2 9AB2     		uxth	r2, r3
 627 00a4 FB68     		ldr	r3, [r7, #12]
 628 00a6 DA81     		strh	r2, [r3, #14]
 384:../Generated_Code/SS1.c ****       if (DeviceDataPrv->OutSentDataNum == DeviceDataPrv->OutDataNumReq) {
 629              		.loc 1 384 0
 630 00a8 FB68     		ldr	r3, [r7, #12]
 631 00aa DA89     		ldrh	r2, [r3, #14]
 632 00ac FB68     		ldr	r3, [r7, #12]
 633 00ae 9B8A     		ldrh	r3, [r3, #20]
 634 00b0 9A42     		cmp	r2, r3
 635 00b2 10D1     		bne	.L19
 385:../Generated_Code/SS1.c ****         DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by Send
 636              		.loc 1 385 0
 637 00b4 FB68     		ldr	r3, [r7, #12]
 638 00b6 0022     		mov	r2, #0
 639 00b8 9A82     		strh	r2, [r3, #20]
 386:../Generated_Code/SS1.c ****         SS1_OnBlockSent(DeviceDataPrv->UserData);
 640              		.loc 1 386 0
 641 00ba FB68     		ldr	r3, [r7, #12]
 642 00bc 1B6A     		ldr	r3, [r3, #32]
 643 00be 181C     		mov	r0, r3
 644 00c0 FFF7FEFF 		bl	SS1_OnBlockSent
 645 00c4 07E0     		b	.L19
 646              	.L22:
 387:../Generated_Code/SS1.c ****       }
 388:../Generated_Code/SS1.c ****     } else {
 389:../Generated_Code/SS1.c ****       SPI_PDD_DisableInterruptMask(SPI0_BASE_PTR, SPI_PDD_TX_BUFFER_EMPTY); /* Disable TX interrupt
 647              		.loc 1 389 0
 648 00c6 054B     		ldr	r3, .L23
 649 00c8 044A     		ldr	r2, .L23
 650 00ca 1278     		ldrb	r2, [r2]
 651 00cc D2B2     		uxtb	r2, r2
 652 00ce 2021     		mov	r1, #32
 653 00d0 8A43     		bic	r2, r1
 654 00d2 D2B2     		uxtb	r2, r2
 655 00d4 1A70     		strb	r2, [r3]
 656              	.L19:
 390:../Generated_Code/SS1.c ****     }
 391:../Generated_Code/SS1.c ****   }
 392:../Generated_Code/SS1.c **** }
 657              		.loc 1 392 0
 658 00d6 BD46     		mov	sp, r7
 659 00d8 04B0     		add	sp, sp, #16
 660              		@ sp needed for prologue
 661 00da 80BD     		pop	{r7, pc}
 662              	.L24:
 663              		.align	2
 664              	.L23:
 665 00dc 00600740 		.word	1074225152
 666              		.cfi_endproc
 667              	.LFE6:
 669              		.text
 670              	.Letext0:
 671              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 672              		.file 3 "C:/Users/LARM/workspace/MQX-Lite + SPI + Motor + Ultrassom/Generated_Code/IO_Map.h"
 673              		.file 4 "C:/Users/LARM/workspace/MQX-Lite + SPI + Motor + Ultrassom/Generated_Code/PE_LDD.h"
 674              		.file 5 "C:/Users/LARM/workspace/MQX-Lite + SPI + Motor + Ultrassom/MQXLITE/psp/cortex_m/psptypes.
DEFINED SYMBOLS
                            *ABS*:00000000 SS1.c
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:24     .text.SS1_Init:00000000 $t
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:29     .text.SS1_Init:00000000 SS1_Init
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:214    .text.SS1_Init:00000120 $d
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:519    .text.SS1_Interrupt:00000000 SS1_Interrupt
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:228    .text.SS1_Deinit:00000000 $t
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:233    .text.SS1_Deinit:00000000 SS1_Deinit
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:284    .text.SS1_Deinit:00000040 $d
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:293    .text.SS1_ReceiveBlock:00000000 $t
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:298    .text.SS1_ReceiveBlock:00000000 SS1_ReceiveBlock
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:365    .text.SS1_ReceiveBlock:00000054 $d
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:370    .text.SS1_SendBlock:00000000 $t
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:375    .text.SS1_SendBlock:00000000 SS1_SendBlock
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:441    .text.SS1_SendBlock:00000050 $d
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:446    .text.SS1_GetReceivedDataNum:00000000 $t
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:451    .text.SS1_GetReceivedDataNum:00000000 SS1_GetReceivedDataNum
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:480    .text.SS1_GetSentDataNum:00000000 $t
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:485    .text.SS1_GetSentDataNum:00000000 SS1_GetSentDataNum
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:514    .text.SS1_Interrupt:00000000 $t
C:\Users\LARM\AppData\Local\Temp\cc7XpK0Y.s:665    .text.SS1_Interrupt:000000dc $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_int_get_isr_data
_int_install_isr
PE_LDD_DeviceDataList
_int_disable
_int_enable
SS1_OnBlockReceived
SS1_OnBlockSent
