   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"AS1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	24
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.INT_UART0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  24              		.align	2
  27              	INT_UART0__DEFAULT_RTOS_ISRPARAM:
  28 0000 00000000 		.space	4
  29              		.section	.text.AS1_Init,"ax",%progbits
  30              		.align	2
  31              		.global	AS1_Init
  32              		.code	16
  33              		.thumb_func
  35              	AS1_Init:
  36              	.LFB0:
  37              		.file 1 "../Generated_Code/AS1.c"
   1:../Generated_Code/AS1.c **** /** ###################################################################
   2:../Generated_Code/AS1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/AS1.c **** **     Filename    : AS1.c
   4:../Generated_Code/AS1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/AS1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/AS1.c **** **     Component   : Serial_LDD
   7:../Generated_Code/AS1.c **** **     Version     : Component 01.165, Driver 01.10, CPU db: 3.00.000
   8:../Generated_Code/AS1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/AS1.c **** **     Date/Time   : 2013-08-21, 10:54, # CodeGen: 19
  10:../Generated_Code/AS1.c **** **     Abstract    :
  11:../Generated_Code/AS1.c **** **         This component "Serial_LDD" implements an asynchronous serial
  12:../Generated_Code/AS1.c **** **         communication. The component supports different settings of
  13:../Generated_Code/AS1.c **** **         parity, word width, stop-bit and communication speed,
  14:../Generated_Code/AS1.c **** **         user can select interrupt or polling handler.
  15:../Generated_Code/AS1.c **** **         Communication speed can be changed also in runtime.
  16:../Generated_Code/AS1.c **** **         The component requires one on-chip asynchronous serial communication channel.
  17:../Generated_Code/AS1.c **** **     Settings    :
  18:../Generated_Code/AS1.c **** **          Component name                                 : AS1
  19:../Generated_Code/AS1.c **** **          Device                                         : UART0
  20:../Generated_Code/AS1.c **** **          Interrupt service/event                        : Enabled
  21:../Generated_Code/AS1.c **** **            Interrupt RxD                                : INT_UART0
  22:../Generated_Code/AS1.c **** **            Interrupt RxD priority                       : medium priority
  23:../Generated_Code/AS1.c **** **            Interrupt TxD                                : INT_UART0
  24:../Generated_Code/AS1.c **** **            Interrupt TxD priority                       : medium priority
  25:../Generated_Code/AS1.c **** **            Interrupt Error                              : INT_UART0
  26:../Generated_Code/AS1.c **** **            Interrupt Error priority                     : medium priority
  27:../Generated_Code/AS1.c **** **          Settings                                       : 
  28:../Generated_Code/AS1.c **** **            Data width                                   : 8 bits
  29:../Generated_Code/AS1.c **** **            Parity                                       : None
  30:../Generated_Code/AS1.c **** **            Stop bits                                    : 1
  31:../Generated_Code/AS1.c **** **            Loop mode                                    : Normal
  32:../Generated_Code/AS1.c **** **            Baud rate                                    : 38400 baud
  33:../Generated_Code/AS1.c **** **            Wakeup condition                             : Idle line wakeup
  34:../Generated_Code/AS1.c **** **            Stop in wait mode                            : no
  35:../Generated_Code/AS1.c **** **            Idle line mode                               : Starts after start bit
  36:../Generated_Code/AS1.c **** **            Transmitter output                           : Not inverted
  37:../Generated_Code/AS1.c **** **            Receiver input                               : Not inverted
  38:../Generated_Code/AS1.c **** **            Break generation length                      : 10/11 bits
  39:../Generated_Code/AS1.c **** **            Receiver                                     : Enabled
  40:../Generated_Code/AS1.c **** **              RxD                                        : TSI0_CH2/PTA1/UART0_RX/TPM2_CH0
  41:../Generated_Code/AS1.c **** **              RxD pin signal                             : 
  42:../Generated_Code/AS1.c **** **            Transmitter                                  : Enabled
  43:../Generated_Code/AS1.c **** **              TxD                                        : TSI0_CH3/PTA2/UART0_TX/TPM2_CH1
  44:../Generated_Code/AS1.c **** **              TxD pin signal                             : 
  45:../Generated_Code/AS1.c **** **            Flow control                                 : None
  46:../Generated_Code/AS1.c **** **          Initialization                                 : 
  47:../Generated_Code/AS1.c **** **            Enabled in init. code                        : yes
  48:../Generated_Code/AS1.c **** **            Auto initialization                          : no
  49:../Generated_Code/AS1.c **** **            Event mask                                   : 
  50:../Generated_Code/AS1.c **** **              OnBlockSent                                : Enabled
  51:../Generated_Code/AS1.c **** **              OnBlockReceived                            : Enabled
  52:../Generated_Code/AS1.c **** **              OnTxComplete                               : Disabled
  53:../Generated_Code/AS1.c **** **              OnError                                    : Disabled
  54:../Generated_Code/AS1.c **** **              OnBreak                                    : Disabled
  55:../Generated_Code/AS1.c **** **          CPU clock/configuration selection              : 
  56:../Generated_Code/AS1.c **** **            Clock configuration 0                        : This component enabled
  57:../Generated_Code/AS1.c **** **            Clock configuration 1                        : This component disabled
  58:../Generated_Code/AS1.c **** **            Clock configuration 2                        : This component disabled
  59:../Generated_Code/AS1.c **** **            Clock configuration 3                        : This component disabled
  60:../Generated_Code/AS1.c **** **            Clock configuration 4                        : This component disabled
  61:../Generated_Code/AS1.c **** **            Clock configuration 5                        : This component disabled
  62:../Generated_Code/AS1.c **** **            Clock configuration 6                        : This component disabled
  63:../Generated_Code/AS1.c **** **            Clock configuration 7                        : This component disabled
  64:../Generated_Code/AS1.c **** **     Contents    :
  65:../Generated_Code/AS1.c **** **         Init               - LDD_TDeviceData* AS1_Init(LDD_TUserData *UserDataPtr);
  66:../Generated_Code/AS1.c **** **         Deinit             - void AS1_Deinit(LDD_TDeviceData *DeviceDataPtr);
  67:../Generated_Code/AS1.c **** **         SendBlock          - LDD_TError AS1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData.
  68:../Generated_Code/AS1.c **** **         ReceiveBlock       - LDD_TError AS1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TDa
  69:../Generated_Code/AS1.c **** **         GetSentDataNum     - uint16_t AS1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr);
  70:../Generated_Code/AS1.c **** **         GetReceivedDataNum - uint16_t AS1_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr);
  71:../Generated_Code/AS1.c **** **
  72:../Generated_Code/AS1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  73:../Generated_Code/AS1.c **** **     
  74:../Generated_Code/AS1.c **** **     http      : www.freescale.com
  75:../Generated_Code/AS1.c **** **     mail      : support@freescale.com
  76:../Generated_Code/AS1.c **** ** ###################################################################*/
  77:../Generated_Code/AS1.c **** 
  78:../Generated_Code/AS1.c **** /* MODULE AS1. */
  79:../Generated_Code/AS1.c **** /*lint -save  -e926 -e927 -e928 -e929 -e572 Disable MISRA rule (11.4,12.8) checking. */
  80:../Generated_Code/AS1.c **** 
  81:../Generated_Code/AS1.c **** /* {Default RTOS Adapter} No RTOS includes */
  82:../Generated_Code/AS1.c **** #include "AS1.h"
  83:../Generated_Code/AS1.c **** #include "Events.h"
  84:../Generated_Code/AS1.c **** #include "UART0_PDD.h"
  85:../Generated_Code/AS1.c **** 
  86:../Generated_Code/AS1.c **** #define AVAILABLE_EVENTS_MASK (LDD_SERIAL_ON_BLOCK_RECEIVED | LDD_SERIAL_ON_BLOCK_SENT)
  87:../Generated_Code/AS1.c **** 
  88:../Generated_Code/AS1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
  89:../Generated_Code/AS1.c **** static AS1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  90:../Generated_Code/AS1.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
  91:../Generated_Code/AS1.c **** static AS1_TDeviceDataPtr INT_UART0__DEFAULT_RTOS_ISRPARAM;
  92:../Generated_Code/AS1.c **** 
  93:../Generated_Code/AS1.c **** /*
  94:../Generated_Code/AS1.c **** ** ===================================================================
  95:../Generated_Code/AS1.c **** **     Method      :  AS1_Init (component Serial_LDD)
  96:../Generated_Code/AS1.c **** **
  97:../Generated_Code/AS1.c **** **     Description :
  98:../Generated_Code/AS1.c **** **         Initializes the device. Allocates memory for the device data
  99:../Generated_Code/AS1.c **** **         structure, allocates interrupt vectors and sets interrupt
 100:../Generated_Code/AS1.c **** **         priority, sets pin routing, sets timing, etc. If the "Enable
 101:../Generated_Code/AS1.c **** **         in init. code" is set to "yes" value then the device is also
 102:../Generated_Code/AS1.c **** **         enabled(see the description of the Enable() method). In this
 103:../Generated_Code/AS1.c **** **         case the Enable() method is not necessary and needn't to be
 104:../Generated_Code/AS1.c **** **         generated. 
 105:../Generated_Code/AS1.c **** **     Parameters  :
 106:../Generated_Code/AS1.c **** **         NAME            - DESCRIPTION
 107:../Generated_Code/AS1.c **** **       * UserDataPtr     - Pointer to the user or
 108:../Generated_Code/AS1.c **** **                           RTOS specific data. This pointer will be
 109:../Generated_Code/AS1.c **** **                           passed as an event or callback parameter.
 110:../Generated_Code/AS1.c **** **     Returns     :
 111:../Generated_Code/AS1.c **** **         ---             - Device data structure pointer.
 112:../Generated_Code/AS1.c **** ** ===================================================================
 113:../Generated_Code/AS1.c **** */
 114:../Generated_Code/AS1.c **** LDD_TDeviceData* AS1_Init(LDD_TUserData *UserDataPtr)
 115:../Generated_Code/AS1.c **** {
  38              		.loc 1 115 0
  39              		.cfi_startproc
  40 0000 80B5     		push	{r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 8
  43              		.cfi_offset 7, -8
  44              		.cfi_offset 14, -4
  45 0002 84B0     		sub	sp, sp, #16
  46              	.LCFI1:
  47              		.cfi_def_cfa_offset 24
  48 0004 00AF     		add	r7, sp, #0
  49              	.LCFI2:
  50              		.cfi_def_cfa_register 7
  51 0006 7860     		str	r0, [r7, #4]
 116:../Generated_Code/AS1.c ****   /* Allocate device structure */
 117:../Generated_Code/AS1.c ****   AS1_TDeviceDataPtr DeviceDataPrv;
 118:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 119:../Generated_Code/AS1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  52              		.loc 1 119 0
  53 0008 5E4B     		ldr	r3, .L2
  54 000a FB60     		str	r3, [r7, #12]
 120:../Generated_Code/AS1.c **** 
 121:../Generated_Code/AS1.c ****   /* Clear the receive counters and pointer */
 122:../Generated_Code/AS1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Clear the counter of received characters */
  55              		.loc 1 122 0
  56 000c FB68     		ldr	r3, [r7, #12]
  57 000e 0022     		mov	r2, #0
  58 0010 5A80     		strh	r2, [r3, #2]
 123:../Generated_Code/AS1.c ****   DeviceDataPrv->InpDataNumReq = 0x00U; /* Clear the counter of characters to receive by ReceiveBlo
  59              		.loc 1 123 0
  60 0012 FB68     		ldr	r3, [r7, #12]
  61 0014 0022     		mov	r2, #0
  62 0016 1A81     		strh	r2, [r3, #8]
 124:../Generated_Code/AS1.c ****   DeviceDataPrv->InpDataPtr = NULL;    /* Clear the buffer pointer for received characters */
  63              		.loc 1 124 0
  64 0018 FB68     		ldr	r3, [r7, #12]
  65 001a 0022     		mov	r2, #0
  66 001c 5A60     		str	r2, [r3, #4]
 125:../Generated_Code/AS1.c ****   /* Clear the transmit counters and pointer */
 126:../Generated_Code/AS1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters */
  67              		.loc 1 126 0
  68 001e FB68     		ldr	r3, [r7, #12]
  69 0020 0022     		mov	r2, #0
  70 0022 5A81     		strh	r2, [r3, #10]
 127:../Generated_Code/AS1.c ****   DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBlock(
  71              		.loc 1 127 0
  72 0024 FB68     		ldr	r3, [r7, #12]
  73 0026 0022     		mov	r2, #0
  74 0028 1A82     		strh	r2, [r3, #16]
 128:../Generated_Code/AS1.c ****   DeviceDataPrv->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  75              		.loc 1 128 0
  76 002a FB68     		ldr	r3, [r7, #12]
  77 002c 0022     		mov	r2, #0
  78 002e DA60     		str	r2, [r3, #12]
 129:../Generated_Code/AS1.c ****   DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  79              		.loc 1 129 0
  80 0030 FB68     		ldr	r3, [r7, #12]
  81 0032 7A68     		ldr	r2, [r7, #4]
  82 0034 5A61     		str	r2, [r3, #20]
 130:../Generated_Code/AS1.c ****   /* Allocate interrupt vectors */
 131:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 132:../Generated_Code/AS1.c ****   INT_UART0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  83              		.loc 1 132 0
  84 0036 544B     		ldr	r3, .L2+4
  85 0038 FA68     		ldr	r2, [r7, #12]
  86 003a 1A60     		str	r2, [r3]
 133:../Generated_Code/AS1.c ****   /* SIM_SCGC4: UART0=1 */
 134:../Generated_Code/AS1.c ****   SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;                                                   
  87              		.loc 1 134 0
  88 003c 534A     		ldr	r2, .L2+8
  89 003e 5349     		ldr	r1, .L2+8
  90 0040 534B     		ldr	r3, .L2+12
  91 0042 CB58     		ldr	r3, [r1, r3]
  92 0044 8021     		mov	r1, #128
  93 0046 C900     		lsl	r1, r1, #3
  94 0048 1943     		orr	r1, r3
  95 004a 514B     		ldr	r3, .L2+12
  96 004c D150     		str	r1, [r2, r3]
 135:../Generated_Code/AS1.c ****   /* PORTA_PCR1: ISF=0,MUX=2 */
 136:../Generated_Code/AS1.c ****   PORTA_PCR1 = (uint32_t)((PORTA_PCR1 & (uint32_t)~(uint32_t)(
  97              		.loc 1 136 0
  98 004e 514B     		ldr	r3, .L2+16
  99 0050 504A     		ldr	r2, .L2+16
 100 0052 5268     		ldr	r2, [r2, #4]
 101 0054 111C     		mov	r1, r2
 102 0056 504A     		ldr	r2, .L2+20
 103 0058 0A40     		and	r2, r1
 104 005a 8021     		mov	r1, #128
 105 005c 8900     		lsl	r1, r1, #2
 106 005e 0A43     		orr	r2, r1
 107 0060 5A60     		str	r2, [r3, #4]
 137:../Generated_Code/AS1.c ****                 PORT_PCR_ISF_MASK |
 138:../Generated_Code/AS1.c ****                 PORT_PCR_MUX(0x05)
 139:../Generated_Code/AS1.c ****                )) | (uint32_t)(
 140:../Generated_Code/AS1.c ****                 PORT_PCR_MUX(0x02)
 141:../Generated_Code/AS1.c ****                ));                                                  
 142:../Generated_Code/AS1.c ****   /* PORTA_PCR2: ISF=0,MUX=2 */
 143:../Generated_Code/AS1.c ****   PORTA_PCR2 = (uint32_t)((PORTA_PCR2 & (uint32_t)~(uint32_t)(
 108              		.loc 1 143 0
 109 0062 4C4B     		ldr	r3, .L2+16
 110 0064 4B4A     		ldr	r2, .L2+16
 111 0066 9268     		ldr	r2, [r2, #8]
 112 0068 111C     		mov	r1, r2
 113 006a 4B4A     		ldr	r2, .L2+20
 114 006c 0A40     		and	r2, r1
 115 006e 8021     		mov	r1, #128
 116 0070 8900     		lsl	r1, r1, #2
 117 0072 0A43     		orr	r2, r1
 118 0074 9A60     		str	r2, [r3, #8]
 144:../Generated_Code/AS1.c ****                 PORT_PCR_ISF_MASK |
 145:../Generated_Code/AS1.c ****                 PORT_PCR_MUX(0x05)
 146:../Generated_Code/AS1.c ****                )) | (uint32_t)(
 147:../Generated_Code/AS1.c ****                 PORT_PCR_MUX(0x02)
 148:../Generated_Code/AS1.c ****                ));                                                  
 149:../Generated_Code/AS1.c ****   /* NVIC_IPR3: PRI_12=0x80 */
 150:../Generated_Code/AS1.c ****   NVIC_IPR3 = (uint32_t)((NVIC_IPR3 & (uint32_t)~(uint32_t)(
 119              		.loc 1 150 0
 120 0076 494A     		ldr	r2, .L2+24
 121 0078 4849     		ldr	r1, .L2+24
 122 007a C323     		mov	r3, #195
 123 007c 9B00     		lsl	r3, r3, #2
 124 007e CB58     		ldr	r3, [r1, r3]
 125 0080 FF21     		mov	r1, #255
 126 0082 8B43     		bic	r3, r1
 127 0084 8021     		mov	r1, #128
 128 0086 1943     		orr	r1, r3
 129 0088 C323     		mov	r3, #195
 130 008a 9B00     		lsl	r3, r3, #2
 131 008c D150     		str	r1, [r2, r3]
 151:../Generated_Code/AS1.c ****                NVIC_IP_PRI_12(0x7F)
 152:../Generated_Code/AS1.c ****               )) | (uint32_t)(
 153:../Generated_Code/AS1.c ****                NVIC_IP_PRI_12(0x80)
 154:../Generated_Code/AS1.c ****               ));                                                  
 155:../Generated_Code/AS1.c ****   /* NVIC_ISER: SETENA|=0x1000 */
 156:../Generated_Code/AS1.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x1000);                                                   
 132              		.loc 1 156 0
 133 008e 434B     		ldr	r3, .L2+24
 134 0090 424A     		ldr	r2, .L2+24
 135 0092 1268     		ldr	r2, [r2]
 136 0094 8021     		mov	r1, #128
 137 0096 4901     		lsl	r1, r1, #5
 138 0098 0A43     		orr	r2, r1
 139 009a 1A60     		str	r2, [r3]
 157:../Generated_Code/AS1.c ****   UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_DISABLE); /* Disable transmitter. */
 140              		.loc 1 157 0
 141 009c 404B     		ldr	r3, .L2+28
 142 009e 404A     		ldr	r2, .L2+28
 143 00a0 D278     		ldrb	r2, [r2, #3]
 144 00a2 D2B2     		uxtb	r2, r2
 145 00a4 0821     		mov	r1, #8
 146 00a6 8A43     		bic	r2, r1
 147 00a8 D2B2     		uxtb	r2, r2
 148 00aa DA70     		strb	r2, [r3, #3]
 158:../Generated_Code/AS1.c ****   UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_DISABLE); /* Disable receiver. */
 149              		.loc 1 158 0
 150 00ac 3C4B     		ldr	r3, .L2+28
 151 00ae 3C4A     		ldr	r2, .L2+28
 152 00b0 D278     		ldrb	r2, [r2, #3]
 153 00b2 D2B2     		uxtb	r2, r2
 154 00b4 0421     		mov	r1, #4
 155 00b6 8A43     		bic	r2, r1
 156 00b8 D2B2     		uxtb	r2, r2
 157 00ba DA70     		strb	r2, [r3, #3]
 159:../Generated_Code/AS1.c ****   DeviceDataPrv->SerFlag = 0x00U;      /* Reset flags */
 158              		.loc 1 159 0
 159 00bc FB68     		ldr	r3, [r7, #12]
 160 00be 0022     		mov	r2, #0
 161 00c0 1A80     		strh	r2, [r3]
 160:../Generated_Code/AS1.c ****   /* UART0_C1: LOOPS=0,DOZEEN=0,RSRC=0,M=0,WAKE=0,ILT=0,PE=0,PT=0 */
 161:../Generated_Code/AS1.c ****   UART0_C1 = 0x00U;                    /*  Set the C1 register */
 162              		.loc 1 161 0
 163 00c2 374B     		ldr	r3, .L2+28
 164 00c4 0022     		mov	r2, #0
 165 00c6 9A70     		strb	r2, [r3, #2]
 162:../Generated_Code/AS1.c ****   /* UART0_C3: R8T9=0,R9T8=0,TXDIR=0,TXINV=0,ORIE=0,NEIE=0,FEIE=0,PEIE=0 */
 163:../Generated_Code/AS1.c ****   UART0_C3 = 0x00U;                    /*  Set the C3 register */
 166              		.loc 1 163 0
 167 00c8 354B     		ldr	r3, .L2+28
 168 00ca 0022     		mov	r2, #0
 169 00cc 9A71     		strb	r2, [r3, #6]
 164:../Generated_Code/AS1.c ****   /* UART0_S2: LBKDIF=0,RXEDGIF=0,MSBF=0,RXINV=0,RWUID=0,BRK13=0,LBKDE=0,RAF=0 */
 165:../Generated_Code/AS1.c ****   UART0_S2 = 0x00U;                    /*  Set the S2 register */
 170              		.loc 1 165 0
 171 00ce 344B     		ldr	r3, .L2+28
 172 00d0 0022     		mov	r2, #0
 173 00d2 5A71     		strb	r2, [r3, #5]
 166:../Generated_Code/AS1.c ****   UART0_PDD_SetClockSource(UART0_BASE_PTR, UART0_PDD_PLL_FLL_CLOCK);
 174              		.loc 1 166 0
 175 00d4 2D4A     		ldr	r2, .L2+8
 176 00d6 2D49     		ldr	r1, .L2+8
 177 00d8 324B     		ldr	r3, .L2+32
 178 00da CB58     		ldr	r3, [r1, r3]
 179 00dc 191C     		mov	r1, r3
 180 00de 324B     		ldr	r3, .L2+36
 181 00e0 0B40     		and	r3, r1
 182 00e2 8021     		mov	r1, #128
 183 00e4 C904     		lsl	r1, r1, #19
 184 00e6 1943     		orr	r1, r3
 185 00e8 2E4B     		ldr	r3, .L2+32
 186 00ea D150     		str	r1, [r2, r3]
 167:../Generated_Code/AS1.c ****   UART0_PDD_SetBaudRate(UART0_BASE_PTR, 137U); /* Set the baud rate register. */
 187              		.loc 1 167 0
 188 00ec 2C4B     		ldr	r3, .L2+28
 189 00ee 2C4A     		ldr	r2, .L2+28
 190 00f0 1278     		ldrb	r2, [r2]
 191 00f2 D2B2     		uxtb	r2, r2
 192 00f4 1F21     		mov	r1, #31
 193 00f6 8A43     		bic	r2, r1
 194 00f8 D2B2     		uxtb	r2, r2
 195 00fa 1A70     		strb	r2, [r3]
 196 00fc 284B     		ldr	r3, .L2+28
 197 00fe 8922     		mov	r2, #137
 198 0100 5A70     		strb	r2, [r3, #1]
 168:../Generated_Code/AS1.c ****   UART0_PDD_SetOversamplingRatio(UART0_BASE_PTR, 3U);
 199              		.loc 1 168 0
 200 0102 274B     		ldr	r3, .L2+28
 201 0104 264A     		ldr	r2, .L2+28
 202 0106 927A     		ldrb	r2, [r2, #10]
 203 0108 D2B2     		uxtb	r2, r2
 204 010a D2B2     		uxtb	r2, r2
 205 010c 1F21     		mov	r1, #31
 206 010e 8A43     		bic	r2, r1
 207 0110 D2B2     		uxtb	r2, r2
 208 0112 0321     		mov	r1, #3
 209 0114 0A43     		orr	r2, r1
 210 0116 D2B2     		uxtb	r2, r2
 211 0118 D2B2     		uxtb	r2, r2
 212 011a 9A72     		strb	r2, [r3, #10]
 169:../Generated_Code/AS1.c ****   UART0_PDD_EnableSamplingOnBothEdges(UART0_BASE_PTR, PDD_ENABLE);
 213              		.loc 1 169 0
 214 011c 204B     		ldr	r3, .L2+28
 215 011e 204A     		ldr	r2, .L2+28
 216 0120 D27A     		ldrb	r2, [r2, #11]
 217 0122 D2B2     		uxtb	r2, r2
 218 0124 D2B2     		uxtb	r2, r2
 219 0126 0221     		mov	r1, #2
 220 0128 0A43     		orr	r2, r1
 221 012a D2B2     		uxtb	r2, r2
 222 012c D2B2     		uxtb	r2, r2
 223 012e DA72     		strb	r2, [r3, #11]
 170:../Generated_Code/AS1.c ****   UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_ENABLE); /* Enable transmitter */
 224              		.loc 1 170 0
 225 0130 1B4B     		ldr	r3, .L2+28
 226 0132 1B4A     		ldr	r2, .L2+28
 227 0134 D278     		ldrb	r2, [r2, #3]
 228 0136 D2B2     		uxtb	r2, r2
 229 0138 D2B2     		uxtb	r2, r2
 230 013a 0821     		mov	r1, #8
 231 013c 0A43     		orr	r2, r1
 232 013e D2B2     		uxtb	r2, r2
 233 0140 D2B2     		uxtb	r2, r2
 234 0142 DA70     		strb	r2, [r3, #3]
 171:../Generated_Code/AS1.c ****   UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_ENABLE); /* Enable receiver */
 235              		.loc 1 171 0
 236 0144 164B     		ldr	r3, .L2+28
 237 0146 164A     		ldr	r2, .L2+28
 238 0148 D278     		ldrb	r2, [r2, #3]
 239 014a D2B2     		uxtb	r2, r2
 240 014c D2B2     		uxtb	r2, r2
 241 014e 0421     		mov	r1, #4
 242 0150 0A43     		orr	r2, r1
 243 0152 D2B2     		uxtb	r2, r2
 244 0154 D2B2     		uxtb	r2, r2
 245 0156 DA70     		strb	r2, [r3, #3]
 172:../Generated_Code/AS1.c ****   UART0_PDD_EnableInterrupt(UART0_BASE_PTR, ( UART0_PDD_INTERRUPT_RECEIVER )); /* Enable interrupts
 246              		.loc 1 172 0
 247 0158 114B     		ldr	r3, .L2+28
 248 015a 114A     		ldr	r2, .L2+28
 249 015c D278     		ldrb	r2, [r2, #3]
 250 015e D2B2     		uxtb	r2, r2
 251 0160 2021     		mov	r1, #32
 252 0162 0A43     		orr	r2, r1
 253 0164 D2B2     		uxtb	r2, r2
 254 0166 DA70     		strb	r2, [r3, #3]
 255 0168 0D4B     		ldr	r3, .L2+28
 256 016a 0D4A     		ldr	r2, .L2+28
 257 016c 9279     		ldrb	r2, [r2, #6]
 258 016e D2B2     		uxtb	r2, r2
 259 0170 9A71     		strb	r2, [r3, #6]
 173:../Generated_Code/AS1.c ****   /* Registration of the device structure */
 174:../Generated_Code/AS1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_AS1_ID,DeviceDataPrv);
 260              		.loc 1 174 0
 261 0172 0E4B     		ldr	r3, .L2+40
 262 0174 FA68     		ldr	r2, [r7, #12]
 263 0176 1A60     		str	r2, [r3]
 175:../Generated_Code/AS1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv);
 264              		.loc 1 175 0
 265 0178 FB68     		ldr	r3, [r7, #12]
 176:../Generated_Code/AS1.c **** }
 266              		.loc 1 176 0
 267 017a 181C     		mov	r0, r3
 268 017c BD46     		mov	sp, r7
 269 017e 04B0     		add	sp, sp, #16
 270              		@ sp needed for prologue
 271 0180 80BD     		pop	{r7, pc}
 272              	.L3:
 273 0182 C046     		.align	2
 274              	.L2:
 275 0184 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 276 0188 00000000 		.word	INT_UART0__DEFAULT_RTOS_ISRPARAM
 277 018c 00700440 		.word	1074032640
 278 0190 34100000 		.word	4148
 279 0194 00900440 		.word	1074040832
 280 0198 FFF8FFFE 		.word	-16779009
 281 019c 00E100E0 		.word	-536813312
 282 01a0 00A00640 		.word	1074176000
 283 01a4 04100000 		.word	4100
 284 01a8 FFFFFFF3 		.word	-201326593
 285 01ac 00000000 		.word	PE_LDD_DeviceDataList
 286              		.cfi_endproc
 287              	.LFE0:
 289              		.section	.text.AS1_Deinit,"ax",%progbits
 290              		.align	2
 291              		.global	AS1_Deinit
 292              		.code	16
 293              		.thumb_func
 295              	AS1_Deinit:
 296              	.LFB1:
 177:../Generated_Code/AS1.c **** 
 178:../Generated_Code/AS1.c **** /*
 179:../Generated_Code/AS1.c **** ** ===================================================================
 180:../Generated_Code/AS1.c **** **     Method      :  AS1_Deinit (component Serial_LDD)
 181:../Generated_Code/AS1.c **** **
 182:../Generated_Code/AS1.c **** **     Description :
 183:../Generated_Code/AS1.c **** **          Deinitializes the device. Switches off the device, frees
 184:../Generated_Code/AS1.c **** **         the device data structure memory, interrupts vectors, etc.
 185:../Generated_Code/AS1.c **** **     Parameters  :
 186:../Generated_Code/AS1.c **** **         NAME            - DESCRIPTION
 187:../Generated_Code/AS1.c **** **       * DeviceDataPtr   - Device data structure
 188:../Generated_Code/AS1.c **** **                           pointer returned by <Init> method.
 189:../Generated_Code/AS1.c **** **     Returns     : Nothing
 190:../Generated_Code/AS1.c **** ** ===================================================================
 191:../Generated_Code/AS1.c **** */
 192:../Generated_Code/AS1.c **** void AS1_Deinit(LDD_TDeviceData *DeviceDataPtr)
 193:../Generated_Code/AS1.c **** {
 297              		.loc 1 193 0
 298              		.cfi_startproc
 299 0000 80B5     		push	{r7, lr}
 300              	.LCFI3:
 301              		.cfi_def_cfa_offset 8
 302              		.cfi_offset 7, -8
 303              		.cfi_offset 14, -4
 304 0002 84B0     		sub	sp, sp, #16
 305              	.LCFI4:
 306              		.cfi_def_cfa_offset 24
 307 0004 00AF     		add	r7, sp, #0
 308              	.LCFI5:
 309              		.cfi_def_cfa_register 7
 310 0006 7860     		str	r0, [r7, #4]
 194:../Generated_Code/AS1.c ****   AS1_TDeviceDataPtr DeviceDataPrv = (AS1_TDeviceDataPtr)DeviceDataPtr;
 311              		.loc 1 194 0
 312 0008 7B68     		ldr	r3, [r7, #4]
 313 000a FB60     		str	r3, [r7, #12]
 195:../Generated_Code/AS1.c **** 
 196:../Generated_Code/AS1.c ****   (void)DeviceDataPrv;
 197:../Generated_Code/AS1.c ****   UART0_PDD_DisableInterrupt(UART0_BASE_PTR, ( UART0_PDD_INTERRUPT_RECEIVER | UART0_PDD_INTERRUPT_T
 314              		.loc 1 197 0
 315 000c 144B     		ldr	r3, .L5
 316 000e 144A     		ldr	r2, .L5
 317 0010 D278     		ldrb	r2, [r2, #3]
 318 0012 D1B2     		uxtb	r1, r2
 319 0014 5F22     		mov	r2, #95
 320 0016 0A40     		and	r2, r1
 321 0018 D2B2     		uxtb	r2, r2
 322 001a DA70     		strb	r2, [r3, #3]
 323 001c 104B     		ldr	r3, .L5
 324 001e 104A     		ldr	r2, .L5
 325 0020 9279     		ldrb	r2, [r2, #6]
 326 0022 D2B2     		uxtb	r2, r2
 327 0024 9A71     		strb	r2, [r3, #6]
 198:../Generated_Code/AS1.c ****   UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_DISABLE); /* Disable transmitter. */
 328              		.loc 1 198 0
 329 0026 0E4B     		ldr	r3, .L5
 330 0028 0D4A     		ldr	r2, .L5
 331 002a D278     		ldrb	r2, [r2, #3]
 332 002c D2B2     		uxtb	r2, r2
 333 002e 0821     		mov	r1, #8
 334 0030 8A43     		bic	r2, r1
 335 0032 D2B2     		uxtb	r2, r2
 336 0034 DA70     		strb	r2, [r3, #3]
 199:../Generated_Code/AS1.c ****   UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_DISABLE); /* Disable receiver. */
 337              		.loc 1 199 0
 338 0036 0A4B     		ldr	r3, .L5
 339 0038 094A     		ldr	r2, .L5
 340 003a D278     		ldrb	r2, [r2, #3]
 341 003c D2B2     		uxtb	r2, r2
 342 003e 0421     		mov	r1, #4
 343 0040 8A43     		bic	r2, r1
 344 0042 D2B2     		uxtb	r2, r2
 345 0044 DA70     		strb	r2, [r3, #3]
 200:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 201:../Generated_Code/AS1.c ****   /* Disable clock gate */
 202:../Generated_Code/AS1.c ****   /* SIM_SCGC4: UART0=0 */
 203:../Generated_Code/AS1.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_UART0_MASK);                                        
 346              		.loc 1 203 0
 347 0046 074A     		ldr	r2, .L5+4
 348 0048 0649     		ldr	r1, .L5+4
 349 004a 074B     		ldr	r3, .L5+8
 350 004c CB58     		ldr	r3, [r1, r3]
 351 004e 191C     		mov	r1, r3
 352 0050 064B     		ldr	r3, .L5+12
 353 0052 1940     		and	r1, r3
 354 0054 044B     		ldr	r3, .L5+8
 355 0056 D150     		str	r1, [r2, r3]
 204:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 205:../Generated_Code/AS1.c **** }
 356              		.loc 1 205 0
 357 0058 BD46     		mov	sp, r7
 358 005a 04B0     		add	sp, sp, #16
 359              		@ sp needed for prologue
 360 005c 80BD     		pop	{r7, pc}
 361              	.L6:
 362 005e C046     		.align	2
 363              	.L5:
 364 0060 00A00640 		.word	1074176000
 365 0064 00700440 		.word	1074032640
 366 0068 34100000 		.word	4148
 367 006c FFFBFFFF 		.word	-1025
 368              		.cfi_endproc
 369              	.LFE1:
 371              		.section	.text.AS1_ReceiveBlock,"ax",%progbits
 372              		.align	2
 373              		.global	AS1_ReceiveBlock
 374              		.code	16
 375              		.thumb_func
 377              	AS1_ReceiveBlock:
 378              	.LFB2:
 206:../Generated_Code/AS1.c **** 
 207:../Generated_Code/AS1.c **** /*
 208:../Generated_Code/AS1.c **** ** ===================================================================
 209:../Generated_Code/AS1.c **** **     Method      :  AS1_ReceiveBlock (component Serial_LDD)
 210:../Generated_Code/AS1.c **** **
 211:../Generated_Code/AS1.c **** **     Description :
 212:../Generated_Code/AS1.c **** **         Specifies the number of data to receive. The method returns
 213:../Generated_Code/AS1.c **** **         ERR_BUSY until the specified number of characters is
 214:../Generated_Code/AS1.c **** **         received. Method <CancelBlockReception> can be used to
 215:../Generated_Code/AS1.c **** **         cancel a running receive operation.
 216:../Generated_Code/AS1.c **** **     Parameters  :
 217:../Generated_Code/AS1.c **** **         NAME            - DESCRIPTION
 218:../Generated_Code/AS1.c **** **       * DeviceDataPtr   - Device data structure
 219:../Generated_Code/AS1.c **** **                           pointer returned by <Init> method.
 220:../Generated_Code/AS1.c **** **       * BufferPtr       - Pointer to a buffer where
 221:../Generated_Code/AS1.c **** **                           received characters will be stored.
 222:../Generated_Code/AS1.c **** **         Size            - Number of characters to receive
 223:../Generated_Code/AS1.c **** **     Returns     :
 224:../Generated_Code/AS1.c **** **         ---             - Error code, possible codes:
 225:../Generated_Code/AS1.c **** **                           ERR_OK - OK
 226:../Generated_Code/AS1.c **** **                           ERR_SPEED - The component does not work in
 227:../Generated_Code/AS1.c **** **                           the active clock configuration.
 228:../Generated_Code/AS1.c **** **                           ERR_DISABLED - The component or device is
 229:../Generated_Code/AS1.c **** **                           disabled.
 230:../Generated_Code/AS1.c **** **                           ERR_BUSY - The previous receive request is
 231:../Generated_Code/AS1.c **** **                           pending.
 232:../Generated_Code/AS1.c **** ** ===================================================================
 233:../Generated_Code/AS1.c **** */
 234:../Generated_Code/AS1.c **** LDD_TError AS1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 235:../Generated_Code/AS1.c **** {
 379              		.loc 1 235 0
 380              		.cfi_startproc
 381 0000 80B5     		push	{r7, lr}
 382              	.LCFI6:
 383              		.cfi_def_cfa_offset 8
 384              		.cfi_offset 7, -8
 385              		.cfi_offset 14, -4
 386 0002 86B0     		sub	sp, sp, #24
 387              	.LCFI7:
 388              		.cfi_def_cfa_offset 32
 389 0004 00AF     		add	r7, sp, #0
 390              	.LCFI8:
 391              		.cfi_def_cfa_register 7
 392 0006 F860     		str	r0, [r7, #12]
 393 0008 B960     		str	r1, [r7, #8]
 394 000a BB1D     		add	r3, r7, #6
 395 000c 1A80     		strh	r2, [r3]
 236:../Generated_Code/AS1.c ****   AS1_TDeviceDataPtr DeviceDataPrv = (AS1_TDeviceDataPtr)DeviceDataPtr;
 396              		.loc 1 236 0
 397 000e FB68     		ldr	r3, [r7, #12]
 398 0010 7B61     		str	r3, [r7, #20]
 237:../Generated_Code/AS1.c **** 
 238:../Generated_Code/AS1.c ****   if (Size == 0U) {                    /* Is the parameter Size within an expected range? */
 399              		.loc 1 238 0
 400 0012 BB1D     		add	r3, r7, #6
 401 0014 1B88     		ldrh	r3, [r3]
 402 0016 002B     		cmp	r3, #0
 403 0018 01D1     		bne	.L8
 239:../Generated_Code/AS1.c ****     return ERR_PARAM_SIZE;             /* If no then error */
 404              		.loc 1 239 0
 405 001a 8423     		mov	r3, #132
 406 001c 2DE0     		b	.L9
 407              	.L8:
 240:../Generated_Code/AS1.c ****   }
 241:../Generated_Code/AS1.c ****   if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the previous receive operation pending? */
 408              		.loc 1 241 0
 409 001e 7B69     		ldr	r3, [r7, #20]
 410 0020 1B89     		ldrh	r3, [r3, #8]
 411 0022 002B     		cmp	r3, #0
 412 0024 01D0     		beq	.L10
 242:../Generated_Code/AS1.c ****     return ERR_BUSY;                   /* If yes then error */
 413              		.loc 1 242 0
 414 0026 0823     		mov	r3, #8
 415 0028 27E0     		b	.L9
 416              	.L10:
 243:../Generated_Code/AS1.c ****   }
 244:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 245:../Generated_Code/AS1.c ****   EnterCritical();
 417              		.loc 1 245 0
 418 002a 164B     		ldr	r3, .L13
 419 002c 1B78     		ldrb	r3, [r3]
 420 002e DBB2     		uxtb	r3, r3
 421 0030 0133     		add	r3, r3, #1
 422 0032 DBB2     		uxtb	r3, r3
 423 0034 134A     		ldr	r2, .L13
 424 0036 191C     		add	r1, r3, #0
 425 0038 1170     		strb	r1, [r2]
 426 003a 012B     		cmp	r3, #1
 427 003c 04D1     		bne	.L11
 428              		.loc 1 245 0 is_stmt 0 discriminator 1
 429 003e 124B     		ldr	r3, .L13+4
 430              	@ 245 "../Generated_Code/AS1.c" 1
 431 0040 EFF31080 		MRS R0, PRIMASK
 432 0044 72B6     		CPSID i
 433 0046 1870     		STRB R0, [r3]
 434              	@ 0 "" 2
 435              		.code	16
 436              	.L11:
 246:../Generated_Code/AS1.c ****   DeviceDataPrv->InpDataPtr = BufferPtr; /* Store a pointer to the input data. */
 437              		.loc 1 246 0 is_stmt 1
 438 0048 7B69     		ldr	r3, [r7, #20]
 439 004a BA68     		ldr	r2, [r7, #8]
 440 004c 5A60     		str	r2, [r3, #4]
 247:../Generated_Code/AS1.c ****   DeviceDataPrv->InpDataNumReq = Size; /* Store a number of characters to be received. */
 441              		.loc 1 247 0
 442 004e 7B69     		ldr	r3, [r7, #20]
 443 0050 BA1D     		add	r2, r7, #6
 444 0052 1288     		ldrh	r2, [r2]
 445 0054 1A81     		strh	r2, [r3, #8]
 248:../Generated_Code/AS1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Set number of received characters to zero. */
 446              		.loc 1 248 0
 447 0056 7B69     		ldr	r3, [r7, #20]
 448 0058 0022     		mov	r2, #0
 449 005a 5A80     		strh	r2, [r3, #2]
 249:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 250:../Generated_Code/AS1.c ****   ExitCritical();
 450              		.loc 1 250 0
 451 005c 094B     		ldr	r3, .L13
 452 005e 1B78     		ldrb	r3, [r3]
 453 0060 DBB2     		uxtb	r3, r3
 454 0062 013B     		sub	r3, r3, #1
 455 0064 DBB2     		uxtb	r3, r3
 456 0066 074A     		ldr	r2, .L13
 457 0068 191C     		add	r1, r3, #0
 458 006a 1170     		strb	r1, [r2]
 459 006c 002B     		cmp	r3, #0
 460 006e 03D1     		bne	.L12
 461              		.loc 1 250 0 is_stmt 0 discriminator 1
 462 0070 054B     		ldr	r3, .L13+4
 463              	@ 250 "../Generated_Code/AS1.c" 1
 464 0072 1878     		ldrb r0, [r3]
 465 0074 80F31088 		msr PRIMASK,r0;
 466              		
 467              	@ 0 "" 2
 468              		.code	16
 469              	.L12:
 251:../Generated_Code/AS1.c ****   return ERR_OK;                       /* OK */
 470              		.loc 1 251 0 is_stmt 1
 471 0078 0023     		mov	r3, #0
 472              	.L9:
 252:../Generated_Code/AS1.c **** }
 473              		.loc 1 252 0
 474 007a 181C     		mov	r0, r3
 475 007c BD46     		mov	sp, r7
 476 007e 06B0     		add	sp, sp, #24
 477              		@ sp needed for prologue
 478 0080 80BD     		pop	{r7, pc}
 479              	.L14:
 480 0082 C046     		.align	2
 481              	.L13:
 482 0084 00000000 		.word	SR_lock
 483 0088 00000000 		.word	SR_reg
 484              		.cfi_endproc
 485              	.LFE2:
 487              		.section	.text.AS1_SendBlock,"ax",%progbits
 488              		.align	2
 489              		.global	AS1_SendBlock
 490              		.code	16
 491              		.thumb_func
 493              	AS1_SendBlock:
 494              	.LFB3:
 253:../Generated_Code/AS1.c **** 
 254:../Generated_Code/AS1.c **** /*
 255:../Generated_Code/AS1.c **** ** ===================================================================
 256:../Generated_Code/AS1.c **** **     Method      :  AS1_SendBlock (component Serial_LDD)
 257:../Generated_Code/AS1.c **** **
 258:../Generated_Code/AS1.c **** **     Description :
 259:../Generated_Code/AS1.c **** **         Sends a block of characters. The method returns ERR_BUSY
 260:../Generated_Code/AS1.c **** **         when the previous block transmission is not completed.
 261:../Generated_Code/AS1.c **** **         Method <CancelBlockTransmission> can be used to cancel a
 262:../Generated_Code/AS1.c **** **         transmit operation. This method is available only if the
 263:../Generated_Code/AS1.c **** **         transmitter property is enabled.
 264:../Generated_Code/AS1.c **** **     Parameters  :
 265:../Generated_Code/AS1.c **** **         NAME            - DESCRIPTION
 266:../Generated_Code/AS1.c **** **       * DeviceDataPtr   - Device data structure
 267:../Generated_Code/AS1.c **** **                           pointer returned by <Init> method.
 268:../Generated_Code/AS1.c **** **       * BufferPtr       - Pointer to a buffer from where
 269:../Generated_Code/AS1.c **** **                           data will be sent.
 270:../Generated_Code/AS1.c **** **         Size            - Number of characters in the buffer.
 271:../Generated_Code/AS1.c **** **     Returns     :
 272:../Generated_Code/AS1.c **** **         ---             - Error code, possible codes:
 273:../Generated_Code/AS1.c **** **                           ERR_OK - OK
 274:../Generated_Code/AS1.c **** **                           ERR_SPEED - The component does not work in
 275:../Generated_Code/AS1.c **** **                           the active clock configuration.
 276:../Generated_Code/AS1.c **** **                           ERR_DISABLED - The component or device is
 277:../Generated_Code/AS1.c **** **                           disabled.
 278:../Generated_Code/AS1.c **** **                           ERR_BUSY - The previous transmit request is
 279:../Generated_Code/AS1.c **** **                           pending.
 280:../Generated_Code/AS1.c **** ** ===================================================================
 281:../Generated_Code/AS1.c **** */
 282:../Generated_Code/AS1.c **** LDD_TError AS1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 283:../Generated_Code/AS1.c **** {
 495              		.loc 1 283 0
 496              		.cfi_startproc
 497 0000 80B5     		push	{r7, lr}
 498              	.LCFI9:
 499              		.cfi_def_cfa_offset 8
 500              		.cfi_offset 7, -8
 501              		.cfi_offset 14, -4
 502 0002 86B0     		sub	sp, sp, #24
 503              	.LCFI10:
 504              		.cfi_def_cfa_offset 32
 505 0004 00AF     		add	r7, sp, #0
 506              	.LCFI11:
 507              		.cfi_def_cfa_register 7
 508 0006 F860     		str	r0, [r7, #12]
 509 0008 B960     		str	r1, [r7, #8]
 510 000a BB1D     		add	r3, r7, #6
 511 000c 1A80     		strh	r2, [r3]
 284:../Generated_Code/AS1.c ****   AS1_TDeviceDataPtr DeviceDataPrv = (AS1_TDeviceDataPtr)DeviceDataPtr;
 512              		.loc 1 284 0
 513 000e FB68     		ldr	r3, [r7, #12]
 514 0010 7B61     		str	r3, [r7, #20]
 285:../Generated_Code/AS1.c **** 
 286:../Generated_Code/AS1.c ****   if (Size == 0U) {                    /* Is the parameter Size within an expected range? */
 515              		.loc 1 286 0
 516 0012 BB1D     		add	r3, r7, #6
 517 0014 1B88     		ldrh	r3, [r3]
 518 0016 002B     		cmp	r3, #0
 519 0018 01D1     		bne	.L16
 287:../Generated_Code/AS1.c ****     return ERR_PARAM_SIZE;             /* If no then error */
 520              		.loc 1 287 0
 521 001a 8423     		mov	r3, #132
 522 001c 42E0     		b	.L17
 523              	.L16:
 288:../Generated_Code/AS1.c ****   }
 289:../Generated_Code/AS1.c ****   if (DeviceDataPrv->OutDataNumReq != 0x00U) { /* Is the previous transmit operation pending? */
 524              		.loc 1 289 0
 525 001e 7B69     		ldr	r3, [r7, #20]
 526 0020 1B8A     		ldrh	r3, [r3, #16]
 527 0022 002B     		cmp	r3, #0
 528 0024 01D0     		beq	.L18
 290:../Generated_Code/AS1.c ****     return ERR_BUSY;                   /* If yes then error */
 529              		.loc 1 290 0
 530 0026 0823     		mov	r3, #8
 531 0028 3CE0     		b	.L17
 532              	.L18:
 291:../Generated_Code/AS1.c ****   }
 292:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 293:../Generated_Code/AS1.c ****   EnterCritical();
 533              		.loc 1 293 0
 534 002a 204B     		ldr	r3, .L21
 535 002c 1B78     		ldrb	r3, [r3]
 536 002e DBB2     		uxtb	r3, r3
 537 0030 0133     		add	r3, r3, #1
 538 0032 DBB2     		uxtb	r3, r3
 539 0034 1D4A     		ldr	r2, .L21
 540 0036 191C     		add	r1, r3, #0
 541 0038 1170     		strb	r1, [r2]
 542 003a 012B     		cmp	r3, #1
 543 003c 04D1     		bne	.L19
 544              		.loc 1 293 0 is_stmt 0 discriminator 1
 545 003e 1C4B     		ldr	r3, .L21+4
 546              	@ 293 "../Generated_Code/AS1.c" 1
 547 0040 EFF31080 		MRS R0, PRIMASK
 548 0044 72B6     		CPSID i
 549 0046 1870     		STRB R0, [r3]
 550              	@ 0 "" 2
 551              		.code	16
 552              	.L19:
 294:../Generated_Code/AS1.c ****   DeviceDataPrv->OutDataPtr = BufferPtr; /* Set a pointer to the output data. */
 553              		.loc 1 294 0 is_stmt 1
 554 0048 7B69     		ldr	r3, [r7, #20]
 555 004a BA68     		ldr	r2, [r7, #8]
 556 004c DA60     		str	r2, [r3, #12]
 295:../Generated_Code/AS1.c ****   DeviceDataPrv->OutDataNumReq = Size; /* Set the counter of characters to be sent. */
 557              		.loc 1 295 0
 558 004e 7B69     		ldr	r3, [r7, #20]
 559 0050 BA1D     		add	r2, r7, #6
 560 0052 1288     		ldrh	r2, [r2]
 561 0054 1A82     		strh	r2, [r3, #16]
 296:../Generated_Code/AS1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters. */
 562              		.loc 1 296 0
 563 0056 7B69     		ldr	r3, [r7, #20]
 564 0058 0022     		mov	r2, #0
 565 005a 5A81     		strh	r2, [r3, #10]
 297:../Generated_Code/AS1.c ****   DeviceDataPrv->SerFlag |= ENABLED_TX_INT; /* Set the flag ENABLED_TX_INT */
 566              		.loc 1 297 0
 567 005c 7B69     		ldr	r3, [r7, #20]
 568 005e 1B88     		ldrh	r3, [r3]
 569 0060 0122     		mov	r2, #1
 570 0062 1343     		orr	r3, r2
 571 0064 9AB2     		uxth	r2, r3
 572 0066 7B69     		ldr	r3, [r7, #20]
 573 0068 1A80     		strh	r2, [r3]
 298:../Generated_Code/AS1.c ****   UART0_PDD_EnableInterrupt(UART0_BASE_PTR, UART0_PDD_INTERRUPT_TRANSMITTER); /* Enable TX interrup
 574              		.loc 1 298 0
 575 006a 124B     		ldr	r3, .L21+8
 576 006c 114A     		ldr	r2, .L21+8
 577 006e D278     		ldrb	r2, [r2, #3]
 578 0070 D2B2     		uxtb	r2, r2
 579 0072 8021     		mov	r1, #128
 580 0074 4942     		neg	r1, r1
 581 0076 0A43     		orr	r2, r1
 582 0078 D2B2     		uxtb	r2, r2
 583 007a DA70     		strb	r2, [r3, #3]
 584 007c 0D4B     		ldr	r3, .L21+8
 585 007e 0D4A     		ldr	r2, .L21+8
 586 0080 9279     		ldrb	r2, [r2, #6]
 587 0082 D2B2     		uxtb	r2, r2
 588 0084 9A71     		strb	r2, [r3, #6]
 299:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 300:../Generated_Code/AS1.c ****   ExitCritical();
 589              		.loc 1 300 0
 590 0086 094B     		ldr	r3, .L21
 591 0088 1B78     		ldrb	r3, [r3]
 592 008a DBB2     		uxtb	r3, r3
 593 008c 013B     		sub	r3, r3, #1
 594 008e DBB2     		uxtb	r3, r3
 595 0090 064A     		ldr	r2, .L21
 596 0092 191C     		add	r1, r3, #0
 597 0094 1170     		strb	r1, [r2]
 598 0096 002B     		cmp	r3, #0
 599 0098 03D1     		bne	.L20
 600              		.loc 1 300 0 is_stmt 0 discriminator 1
 601 009a 054B     		ldr	r3, .L21+4
 602              	@ 300 "../Generated_Code/AS1.c" 1
 603 009c 1878     		ldrb r0, [r3]
 604 009e 80F31088 		msr PRIMASK,r0;
 605              		
 606              	@ 0 "" 2
 607              		.code	16
 608              	.L20:
 301:../Generated_Code/AS1.c ****   return ERR_OK;                       /* OK */
 609              		.loc 1 301 0 is_stmt 1
 610 00a2 0023     		mov	r3, #0
 611              	.L17:
 302:../Generated_Code/AS1.c **** }
 612              		.loc 1 302 0
 613 00a4 181C     		mov	r0, r3
 614 00a6 BD46     		mov	sp, r7
 615 00a8 06B0     		add	sp, sp, #24
 616              		@ sp needed for prologue
 617 00aa 80BD     		pop	{r7, pc}
 618              	.L22:
 619              		.align	2
 620              	.L21:
 621 00ac 00000000 		.word	SR_lock
 622 00b0 00000000 		.word	SR_reg
 623 00b4 00A00640 		.word	1074176000
 624              		.cfi_endproc
 625              	.LFE3:
 627              		.section	.text.AS1_GetReceivedDataNum,"ax",%progbits
 628              		.align	2
 629              		.global	AS1_GetReceivedDataNum
 630              		.code	16
 631              		.thumb_func
 633              	AS1_GetReceivedDataNum:
 634              	.LFB4:
 303:../Generated_Code/AS1.c **** 
 304:../Generated_Code/AS1.c **** /*
 305:../Generated_Code/AS1.c **** ** ===================================================================
 306:../Generated_Code/AS1.c **** **     Method      :  AS1_GetReceivedDataNum (component Serial_LDD)
 307:../Generated_Code/AS1.c **** **
 308:../Generated_Code/AS1.c **** **     Description :
 309:../Generated_Code/AS1.c **** **         Returns the number of received characters in the receive
 310:../Generated_Code/AS1.c **** **         buffer. 
 311:../Generated_Code/AS1.c **** **     Parameters  :
 312:../Generated_Code/AS1.c **** **         NAME            - DESCRIPTION
 313:../Generated_Code/AS1.c **** **       * DeviceDataPtr   - Device data structure
 314:../Generated_Code/AS1.c **** **                           pointer returned by <Init> method.
 315:../Generated_Code/AS1.c **** **     Returns     :
 316:../Generated_Code/AS1.c **** **         ---             - Number of received characters in the
 317:../Generated_Code/AS1.c **** **                           receive buffer.
 318:../Generated_Code/AS1.c **** ** ===================================================================
 319:../Generated_Code/AS1.c **** */
 320:../Generated_Code/AS1.c **** uint16_t AS1_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr)
 321:../Generated_Code/AS1.c **** {
 635              		.loc 1 321 0
 636              		.cfi_startproc
 637 0000 80B5     		push	{r7, lr}
 638              	.LCFI12:
 639              		.cfi_def_cfa_offset 8
 640              		.cfi_offset 7, -8
 641              		.cfi_offset 14, -4
 642 0002 84B0     		sub	sp, sp, #16
 643              	.LCFI13:
 644              		.cfi_def_cfa_offset 24
 645 0004 00AF     		add	r7, sp, #0
 646              	.LCFI14:
 647              		.cfi_def_cfa_register 7
 648 0006 7860     		str	r0, [r7, #4]
 322:../Generated_Code/AS1.c ****   AS1_TDeviceDataPtr DeviceDataPrv = (AS1_TDeviceDataPtr)DeviceDataPtr;
 649              		.loc 1 322 0
 650 0008 7B68     		ldr	r3, [r7, #4]
 651 000a FB60     		str	r3, [r7, #12]
 323:../Generated_Code/AS1.c **** 
 324:../Generated_Code/AS1.c ****   return (DeviceDataPrv->InpRecvDataNum); /* Return the number of received characters. */
 652              		.loc 1 324 0
 653 000c FB68     		ldr	r3, [r7, #12]
 654 000e 5B88     		ldrh	r3, [r3, #2]
 325:../Generated_Code/AS1.c **** }
 655              		.loc 1 325 0
 656 0010 181C     		mov	r0, r3
 657 0012 BD46     		mov	sp, r7
 658 0014 04B0     		add	sp, sp, #16
 659              		@ sp needed for prologue
 660 0016 80BD     		pop	{r7, pc}
 661              		.cfi_endproc
 662              	.LFE4:
 664              		.section	.text.AS1_GetSentDataNum,"ax",%progbits
 665              		.align	2
 666              		.global	AS1_GetSentDataNum
 667              		.code	16
 668              		.thumb_func
 670              	AS1_GetSentDataNum:
 671              	.LFB5:
 326:../Generated_Code/AS1.c **** 
 327:../Generated_Code/AS1.c **** /*
 328:../Generated_Code/AS1.c **** ** ===================================================================
 329:../Generated_Code/AS1.c **** **     Method      :  AS1_GetSentDataNum (component Serial_LDD)
 330:../Generated_Code/AS1.c **** **
 331:../Generated_Code/AS1.c **** **     Description :
 332:../Generated_Code/AS1.c **** **         Returns the number of sent characters.
 333:../Generated_Code/AS1.c **** **     Parameters  :
 334:../Generated_Code/AS1.c **** **         NAME            - DESCRIPTION
 335:../Generated_Code/AS1.c **** **       * DeviceDataPtr   - Device data structure
 336:../Generated_Code/AS1.c **** **                           pointer returned by <Init> method.
 337:../Generated_Code/AS1.c **** **     Returns     :
 338:../Generated_Code/AS1.c **** **         ---             - The number of sent characters.
 339:../Generated_Code/AS1.c **** ** ===================================================================
 340:../Generated_Code/AS1.c **** */
 341:../Generated_Code/AS1.c **** uint16_t AS1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr)
 342:../Generated_Code/AS1.c **** {
 672              		.loc 1 342 0
 673              		.cfi_startproc
 674 0000 80B5     		push	{r7, lr}
 675              	.LCFI15:
 676              		.cfi_def_cfa_offset 8
 677              		.cfi_offset 7, -8
 678              		.cfi_offset 14, -4
 679 0002 84B0     		sub	sp, sp, #16
 680              	.LCFI16:
 681              		.cfi_def_cfa_offset 24
 682 0004 00AF     		add	r7, sp, #0
 683              	.LCFI17:
 684              		.cfi_def_cfa_register 7
 685 0006 7860     		str	r0, [r7, #4]
 343:../Generated_Code/AS1.c ****   AS1_TDeviceDataPtr DeviceDataPrv = (AS1_TDeviceDataPtr)DeviceDataPtr;
 686              		.loc 1 343 0
 687 0008 7B68     		ldr	r3, [r7, #4]
 688 000a FB60     		str	r3, [r7, #12]
 344:../Generated_Code/AS1.c **** 
 345:../Generated_Code/AS1.c ****   return (DeviceDataPrv->OutSentDataNum); /* Return the number of sent characters. */
 689              		.loc 1 345 0
 690 000c FB68     		ldr	r3, [r7, #12]
 691 000e 5B89     		ldrh	r3, [r3, #10]
 346:../Generated_Code/AS1.c **** }
 692              		.loc 1 346 0
 693 0010 181C     		mov	r0, r3
 694 0012 BD46     		mov	sp, r7
 695 0014 04B0     		add	sp, sp, #16
 696              		@ sp needed for prologue
 697 0016 80BD     		pop	{r7, pc}
 698              		.cfi_endproc
 699              	.LFE5:
 701              		.section	.text.InterruptRx,"ax",%progbits
 702              		.align	2
 703              		.code	16
 704              		.thumb_func
 706              	InterruptRx:
 707              	.LFB6:
 347:../Generated_Code/AS1.c **** 
 348:../Generated_Code/AS1.c **** /*
 349:../Generated_Code/AS1.c **** ** ===================================================================
 350:../Generated_Code/AS1.c **** **     Method      :  InterruptRx (component Serial_LDD)
 351:../Generated_Code/AS1.c **** **
 352:../Generated_Code/AS1.c **** **     Description :
 353:../Generated_Code/AS1.c **** **         The method services the receive interrupt of the selected 
 354:../Generated_Code/AS1.c **** **         peripheral(s) and eventually invokes the bean's event(s).
 355:../Generated_Code/AS1.c **** **         This method is internal. It is used by Processor Expert only.
 356:../Generated_Code/AS1.c **** ** ===================================================================
 357:../Generated_Code/AS1.c **** */
 358:../Generated_Code/AS1.c **** static void InterruptRx(AS1_TDeviceDataPtr DeviceDataPrv)
 359:../Generated_Code/AS1.c **** {
 708              		.loc 1 359 0
 709              		.cfi_startproc
 710 0000 90B5     		push	{r4, r7, lr}
 711              	.LCFI18:
 712              		.cfi_def_cfa_offset 12
 713              		.cfi_offset 4, -12
 714              		.cfi_offset 7, -8
 715              		.cfi_offset 14, -4
 716 0002 83B0     		sub	sp, sp, #12
 717              	.LCFI19:
 718              		.cfi_def_cfa_offset 24
 719 0004 00AF     		add	r7, sp, #0
 720              	.LCFI20:
 721              		.cfi_def_cfa_register 7
 722 0006 7860     		str	r0, [r7, #4]
 360:../Generated_Code/AS1.c ****   register uint16_t Data;              /* Temporary variable for data */
 361:../Generated_Code/AS1.c **** 
 362:../Generated_Code/AS1.c ****   Data = (uint16_t)UART0_PDD_GetChar8(UART0_BASE_PTR); /* Read an 8-bit character from the receiver
 723              		.loc 1 362 0
 724 0008 124B     		ldr	r3, .L27
 725 000a DB79     		ldrb	r3, [r3, #7]
 726 000c DBB2     		uxtb	r3, r3
 727 000e 1C1C     		mov	r4, r3
 363:../Generated_Code/AS1.c ****   if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the receive block operation pending? */
 728              		.loc 1 363 0
 729 0010 7B68     		ldr	r3, [r7, #4]
 730 0012 1B89     		ldrh	r3, [r3, #8]
 731 0014 002B     		cmp	r3, #0
 732 0016 1AD0     		beq	.L25
 364:../Generated_Code/AS1.c ****     *(DeviceDataPrv->InpDataPtr++) = (uint8_t)Data; /* Put an 8-bit character to the receive buffer
 733              		.loc 1 364 0
 734 0018 7B68     		ldr	r3, [r7, #4]
 735 001a 5B68     		ldr	r3, [r3, #4]
 736 001c E2B2     		uxtb	r2, r4
 737 001e 1A70     		strb	r2, [r3]
 738 0020 5A1C     		add	r2, r3, #1
 739 0022 7B68     		ldr	r3, [r7, #4]
 740 0024 5A60     		str	r2, [r3, #4]
 365:../Generated_Code/AS1.c ****     DeviceDataPrv->InpRecvDataNum++;   /* Increment received char. counter */
 741              		.loc 1 365 0
 742 0026 7B68     		ldr	r3, [r7, #4]
 743 0028 5B88     		ldrh	r3, [r3, #2]
 744 002a 0133     		add	r3, r3, #1
 745 002c 9AB2     		uxth	r2, r3
 746 002e 7B68     		ldr	r3, [r7, #4]
 747 0030 5A80     		strh	r2, [r3, #2]
 366:../Generated_Code/AS1.c ****     if (DeviceDataPrv->InpRecvDataNum == DeviceDataPrv->InpDataNumReq) { /* Is the requested number
 748              		.loc 1 366 0
 749 0032 7B68     		ldr	r3, [r7, #4]
 750 0034 5A88     		ldrh	r2, [r3, #2]
 751 0036 7B68     		ldr	r3, [r7, #4]
 752 0038 1B89     		ldrh	r3, [r3, #8]
 753 003a 9A42     		cmp	r2, r3
 754 003c 07D1     		bne	.L25
 367:../Generated_Code/AS1.c ****       DeviceDataPrv->InpDataNumReq = 0x00U; /* If yes then clear number of requested characters to 
 755              		.loc 1 367 0
 756 003e 7B68     		ldr	r3, [r7, #4]
 757 0040 0022     		mov	r2, #0
 758 0042 1A81     		strh	r2, [r3, #8]
 368:../Generated_Code/AS1.c ****       AS1_OnBlockReceived(DeviceDataPrv->UserDataPtr);
 759              		.loc 1 368 0
 760 0044 7B68     		ldr	r3, [r7, #4]
 761 0046 5B69     		ldr	r3, [r3, #20]
 762 0048 181C     		mov	r0, r3
 763 004a FFF7FEFF 		bl	AS1_OnBlockReceived
 764              	.L25:
 369:../Generated_Code/AS1.c ****     }
 370:../Generated_Code/AS1.c ****   }
 371:../Generated_Code/AS1.c **** }
 765              		.loc 1 371 0
 766 004e BD46     		mov	sp, r7
 767 0050 03B0     		add	sp, sp, #12
 768              		@ sp needed for prologue
 769 0052 90BD     		pop	{r4, r7, pc}
 770              	.L28:
 771              		.align	2
 772              	.L27:
 773 0054 00A00640 		.word	1074176000
 774              		.cfi_endproc
 775              	.LFE6:
 777              		.section	.text.InterruptTx,"ax",%progbits
 778              		.align	2
 779              		.code	16
 780              		.thumb_func
 782              	InterruptTx:
 783              	.LFB7:
 372:../Generated_Code/AS1.c **** 
 373:../Generated_Code/AS1.c **** /*
 374:../Generated_Code/AS1.c **** ** ===================================================================
 375:../Generated_Code/AS1.c **** **     Method      :  InterruptTx (component Serial_LDD)
 376:../Generated_Code/AS1.c **** **
 377:../Generated_Code/AS1.c **** **     Description :
 378:../Generated_Code/AS1.c **** **         The method services the receive interrupt of the selected 
 379:../Generated_Code/AS1.c **** **         peripheral(s) and eventually invokes the bean's event(s).
 380:../Generated_Code/AS1.c **** **         This method is internal. It is used by Processor Expert only.
 381:../Generated_Code/AS1.c **** ** ===================================================================
 382:../Generated_Code/AS1.c **** */
 383:../Generated_Code/AS1.c **** static void InterruptTx(AS1_TDeviceDataPtr DeviceDataPrv)
 384:../Generated_Code/AS1.c **** {
 784              		.loc 1 384 0
 785              		.cfi_startproc
 786 0000 80B5     		push	{r7, lr}
 787              	.LCFI21:
 788              		.cfi_def_cfa_offset 8
 789              		.cfi_offset 7, -8
 790              		.cfi_offset 14, -4
 791 0002 82B0     		sub	sp, sp, #8
 792              	.LCFI22:
 793              		.cfi_def_cfa_offset 16
 794 0004 00AF     		add	r7, sp, #0
 795              	.LCFI23:
 796              		.cfi_def_cfa_register 7
 797 0006 7860     		str	r0, [r7, #4]
 385:../Generated_Code/AS1.c **** 
 386:../Generated_Code/AS1.c ****   if (DeviceDataPrv->OutSentDataNum < DeviceDataPrv->OutDataNumReq) { /* Is number of sent characte
 798              		.loc 1 386 0
 799 0008 7B68     		ldr	r3, [r7, #4]
 800 000a 5A89     		ldrh	r2, [r3, #10]
 801 000c 7B68     		ldr	r3, [r7, #4]
 802 000e 1B8A     		ldrh	r3, [r3, #16]
 803 0010 9A42     		cmp	r2, r3
 804 0012 1CD2     		bcs	.L30
 387:../Generated_Code/AS1.c ****     UART0_PDD_PutChar8(UART0_BASE_PTR, *(DeviceDataPrv->OutDataPtr++)); /* Put a 8-bit character to
 805              		.loc 1 387 0
 806 0014 194A     		ldr	r2, .L32
 807 0016 7B68     		ldr	r3, [r7, #4]
 808 0018 DB68     		ldr	r3, [r3, #12]
 809 001a 1978     		ldrb	r1, [r3]
 810 001c D171     		strb	r1, [r2, #7]
 811 001e 5A1C     		add	r2, r3, #1
 812 0020 7B68     		ldr	r3, [r7, #4]
 813 0022 DA60     		str	r2, [r3, #12]
 388:../Generated_Code/AS1.c ****     DeviceDataPrv->OutSentDataNum++;   /* Increment the counter of sent characters. */
 814              		.loc 1 388 0
 815 0024 7B68     		ldr	r3, [r7, #4]
 816 0026 5B89     		ldrh	r3, [r3, #10]
 817 0028 0133     		add	r3, r3, #1
 818 002a 9AB2     		uxth	r2, r3
 819 002c 7B68     		ldr	r3, [r7, #4]
 820 002e 5A81     		strh	r2, [r3, #10]
 389:../Generated_Code/AS1.c ****     if (DeviceDataPrv->OutSentDataNum == DeviceDataPrv->OutDataNumReq) {
 821              		.loc 1 389 0
 822 0030 7B68     		ldr	r3, [r7, #4]
 823 0032 5A89     		ldrh	r2, [r3, #10]
 824 0034 7B68     		ldr	r3, [r7, #4]
 825 0036 1B8A     		ldrh	r3, [r3, #16]
 826 0038 9A42     		cmp	r2, r3
 827 003a 1CD1     		bne	.L29
 390:../Generated_Code/AS1.c ****       DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBl
 828              		.loc 1 390 0
 829 003c 7B68     		ldr	r3, [r7, #4]
 830 003e 0022     		mov	r2, #0
 831 0040 1A82     		strh	r2, [r3, #16]
 391:../Generated_Code/AS1.c ****       AS1_OnBlockSent(DeviceDataPrv->UserDataPtr);
 832              		.loc 1 391 0
 833 0042 7B68     		ldr	r3, [r7, #4]
 834 0044 5B69     		ldr	r3, [r3, #20]
 835 0046 181C     		mov	r0, r3
 836 0048 FFF7FEFF 		bl	AS1_OnBlockSent
 837 004c 13E0     		b	.L29
 838              	.L30:
 392:../Generated_Code/AS1.c ****     }
 393:../Generated_Code/AS1.c ****   } else {
 394:../Generated_Code/AS1.c ****     UART0_PDD_DisableInterrupt(UART0_BASE_PTR, UART0_PDD_INTERRUPT_TRANSMITTER); /* Disable TX inte
 839              		.loc 1 394 0
 840 004e 0B4B     		ldr	r3, .L32
 841 0050 0A4A     		ldr	r2, .L32
 842 0052 D278     		ldrb	r2, [r2, #3]
 843 0054 D1B2     		uxtb	r1, r2
 844 0056 7F22     		mov	r2, #127
 845 0058 0A40     		and	r2, r1
 846 005a D2B2     		uxtb	r2, r2
 847 005c DA70     		strb	r2, [r3, #3]
 848 005e 074B     		ldr	r3, .L32
 849 0060 064A     		ldr	r2, .L32
 850 0062 9279     		ldrb	r2, [r2, #6]
 851 0064 D2B2     		uxtb	r2, r2
 852 0066 9A71     		strb	r2, [r3, #6]
 395:../Generated_Code/AS1.c ****     DeviceDataPrv->SerFlag &= (uint16_t)(~(uint16_t)ENABLED_TX_INT); /* Clear the flag ENABLED_TX_I
 853              		.loc 1 395 0
 854 0068 7B68     		ldr	r3, [r7, #4]
 855 006a 1B88     		ldrh	r3, [r3]
 856 006c 0122     		mov	r2, #1
 857 006e 9343     		bic	r3, r2
 858 0070 9AB2     		uxth	r2, r3
 859 0072 7B68     		ldr	r3, [r7, #4]
 860 0074 1A80     		strh	r2, [r3]
 861              	.L29:
 396:../Generated_Code/AS1.c ****   }
 397:../Generated_Code/AS1.c **** }
 862              		.loc 1 397 0
 863 0076 BD46     		mov	sp, r7
 864 0078 02B0     		add	sp, sp, #8
 865              		@ sp needed for prologue
 866 007a 80BD     		pop	{r7, pc}
 867              	.L33:
 868              		.align	2
 869              	.L32:
 870 007c 00A00640 		.word	1074176000
 871              		.cfi_endproc
 872              	.LFE7:
 874              		.section	.text.AS1_Interrupt,"ax",%progbits
 875              		.align	2
 876              		.global	AS1_Interrupt
 877              		.code	16
 878              		.thumb_func
 880              	AS1_Interrupt:
 881              	.LFB8:
 398:../Generated_Code/AS1.c **** 
 399:../Generated_Code/AS1.c **** /*
 400:../Generated_Code/AS1.c **** ** ===================================================================
 401:../Generated_Code/AS1.c **** **     Method      :  AS1_Interrupt (component Serial_LDD)
 402:../Generated_Code/AS1.c **** **
 403:../Generated_Code/AS1.c **** **     Description :
 404:../Generated_Code/AS1.c **** **         The ISR function handling the device receive/transmit 
 405:../Generated_Code/AS1.c **** **         interrupt. Calls InterruptTX/InterruptRX methods.
 406:../Generated_Code/AS1.c **** **         This method is internal. It is used by Processor Expert only.
 407:../Generated_Code/AS1.c **** ** ===================================================================
 408:../Generated_Code/AS1.c **** */
 409:../Generated_Code/AS1.c **** PE_ISR(AS1_Interrupt)
 410:../Generated_Code/AS1.c **** {
 882              		.loc 1 410 0
 883              		.cfi_startproc
 884 0000 90B5     		push	{r4, r7, lr}
 885              	.LCFI24:
 886              		.cfi_def_cfa_offset 12
 887              		.cfi_offset 4, -12
 888              		.cfi_offset 7, -8
 889              		.cfi_offset 14, -4
 890 0002 83B0     		sub	sp, sp, #12
 891              	.LCFI25:
 892              		.cfi_def_cfa_offset 24
 893 0004 00AF     		add	r7, sp, #0
 894              	.LCFI26:
 895              		.cfi_def_cfa_register 7
 411:../Generated_Code/AS1.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 412:../Generated_Code/AS1.c ****   AS1_TDeviceDataPtr DeviceDataPrv = INT_UART0__DEFAULT_RTOS_ISRPARAM;
 896              		.loc 1 412 0
 897 0006 184B     		ldr	r3, .L38
 898 0008 1B68     		ldr	r3, [r3]
 899 000a 7B60     		str	r3, [r7, #4]
 413:../Generated_Code/AS1.c ****   register uint16_t StatReg = UART0_PDD_ReadInterruptStatusReg(UART0_BASE_PTR); /* Read status regi
 900              		.loc 1 413 0
 901 000c 174B     		ldr	r3, .L38+4
 902 000e 1B79     		ldrb	r3, [r3, #4]
 903 0010 DBB2     		uxtb	r3, r3
 904 0012 1C1C     		mov	r4, r3
 414:../Generated_Code/AS1.c **** 
 415:../Generated_Code/AS1.c ****   if (StatReg & (UART0_S1_NF_MASK | UART0_S1_OR_MASK | UART0_S1_FE_MASK | UART0_S1_PF_MASK)) { /* I
 905              		.loc 1 415 0
 906 0014 221C     		mov	r2, r4
 907 0016 0F23     		mov	r3, #15
 908 0018 1340     		and	r3, r2
 909 001a 09D0     		beq	.L35
 416:../Generated_Code/AS1.c ****     UART0_PDD_ClearInterruptFlags(UART0_BASE_PTR, (UART0_S1_NF_MASK | UART0_S1_OR_MASK | UART0_S1_F
 910              		.loc 1 416 0
 911 001c 134B     		ldr	r3, .L38+4
 912 001e 0F22     		mov	r2, #15
 913 0020 1A71     		strb	r2, [r3, #4]
 417:../Generated_Code/AS1.c ****     (void)UART0_PDD_GetChar8(UART0_BASE_PTR); /* Dummy read 8-bit character from receiver */
 914              		.loc 1 417 0
 915 0022 124B     		ldr	r3, .L38+4
 916 0024 DB79     		ldrb	r3, [r3, #7]
 418:../Generated_Code/AS1.c ****     StatReg &= (uint16_t)(~(uint16_t)UART0_S1_RDRF_MASK); /* Clear the receive data flag to discard
 917              		.loc 1 418 0
 918 0026 2023     		mov	r3, #32
 919 0028 221C     		mov	r2, r4
 920 002a 9A43     		bic	r2, r3
 921 002c 131C     		mov	r3, r2
 922 002e 9CB2     		uxth	r4, r3
 923              	.L35:
 419:../Generated_Code/AS1.c ****   }
 420:../Generated_Code/AS1.c ****   if (StatReg & UART0_S1_RDRF_MASK) {  /* Is the receiver's interrupt flag set? */
 924              		.loc 1 420 0
 925 0030 221C     		mov	r2, r4
 926 0032 2023     		mov	r3, #32
 927 0034 1340     		and	r3, r2
 928 0036 03D0     		beq	.L36
 421:../Generated_Code/AS1.c ****     InterruptRx(DeviceDataPrv);        /* If yes, then invoke the internal service routine. This ro
 929              		.loc 1 421 0
 930 0038 7B68     		ldr	r3, [r7, #4]
 931 003a 181C     		mov	r0, r3
 932 003c FFF7FEFF 		bl	InterruptRx
 933              	.L36:
 422:../Generated_Code/AS1.c ****   }
 423:../Generated_Code/AS1.c ****   if (DeviceDataPrv->SerFlag & ENABLED_TX_INT) { /* Is the transmitter interrupt enabled? */
 934              		.loc 1 423 0
 935 0040 7B68     		ldr	r3, [r7, #4]
 936 0042 1B88     		ldrh	r3, [r3]
 937 0044 1A1C     		mov	r2, r3
 938 0046 0123     		mov	r3, #1
 939 0048 1340     		and	r3, r2
 940 004a DBB2     		uxtb	r3, r3
 941 004c 002B     		cmp	r3, #0
 942 004e 07D0     		beq	.L34
 424:../Generated_Code/AS1.c ****     if (StatReg & UART0_S1_TDRE_MASK) { /* Is the transmitter empty? */
 943              		.loc 1 424 0
 944 0050 221C     		mov	r2, r4
 945 0052 8023     		mov	r3, #128
 946 0054 1340     		and	r3, r2
 947 0056 03D0     		beq	.L34
 425:../Generated_Code/AS1.c ****       InterruptTx(DeviceDataPrv);      /* If yes, then invoke the internal service routine. This ro
 948              		.loc 1 425 0
 949 0058 7B68     		ldr	r3, [r7, #4]
 950 005a 181C     		mov	r0, r3
 951 005c FFF7FEFF 		bl	InterruptTx
 952              	.L34:
 426:../Generated_Code/AS1.c ****     }
 427:../Generated_Code/AS1.c ****   }
 428:../Generated_Code/AS1.c **** }
 953              		.loc 1 428 0
 954 0060 BD46     		mov	sp, r7
 955 0062 03B0     		add	sp, sp, #12
 956              		@ sp needed for prologue
 957 0064 90BD     		pop	{r4, r7, pc}
 958              	.L39:
 959 0066 C046     		.align	2
 960              	.L38:
 961 0068 00000000 		.word	INT_UART0__DEFAULT_RTOS_ISRPARAM
 962 006c 00A00640 		.word	1074176000
 963              		.cfi_endproc
 964              	.LFE8:
 966              		.text
 967              	.Letext0:
 968              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 969              		.file 3 "../Generated_Code/PE_LDD.h"
 970              		.file 4 "../Generated_Code/IO_Map.h"
 971              		.file 5 "../Generated_Code/AS1.h"
 972              		.file 6 "../Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AS1.c
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:24     .bss.INT_UART0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:27     .bss.INT_UART0__DEFAULT_RTOS_ISRPARAM:00000000 INT_UART0__DEFAULT_RTOS_ISRPARAM
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:30     .text.AS1_Init:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:35     .text.AS1_Init:00000000 AS1_Init
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:275    .text.AS1_Init:00000184 $d
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:290    .text.AS1_Deinit:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:295    .text.AS1_Deinit:00000000 AS1_Deinit
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:364    .text.AS1_Deinit:00000060 $d
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:372    .text.AS1_ReceiveBlock:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:377    .text.AS1_ReceiveBlock:00000000 AS1_ReceiveBlock
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:482    .text.AS1_ReceiveBlock:00000084 $d
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:488    .text.AS1_SendBlock:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:493    .text.AS1_SendBlock:00000000 AS1_SendBlock
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:621    .text.AS1_SendBlock:000000ac $d
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:628    .text.AS1_GetReceivedDataNum:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:633    .text.AS1_GetReceivedDataNum:00000000 AS1_GetReceivedDataNum
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:665    .text.AS1_GetSentDataNum:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:670    .text.AS1_GetSentDataNum:00000000 AS1_GetSentDataNum
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:702    .text.InterruptRx:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:706    .text.InterruptRx:00000000 InterruptRx
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:773    .text.InterruptRx:00000054 $d
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:778    .text.InterruptTx:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:782    .text.InterruptTx:00000000 InterruptTx
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:870    .text.InterruptTx:0000007c $d
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:875    .text.AS1_Interrupt:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:880    .text.AS1_Interrupt:00000000 AS1_Interrupt
C:\Users\LARM\AppData\Local\Temp\ccUPvXUB.s:961    .text.AS1_Interrupt:00000068 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
SR_lock
SR_reg
AS1_OnBlockReceived
AS1_OnBlockSent
