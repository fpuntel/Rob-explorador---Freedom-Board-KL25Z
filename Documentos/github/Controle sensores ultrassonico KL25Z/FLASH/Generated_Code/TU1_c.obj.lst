   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"TU1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.ChannelDevice,"a",%progbits
  18              		.align	2
  21              	ChannelDevice:
  22 0000 04       		.byte	4
  23 0001 000000   		.section	.rodata.ChannelMode,"a",%progbits
  24              		.align	2
  27              	ChannelMode:
  28 0000 01       		.byte	1
  29 0001 000000   		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  30              		.align	2
  33              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  34 0000 00000000 		.space	8
  34      00000000 
  35              		.section	.bss.INT_TPM0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  36              		.align	2
  39              	INT_TPM0__DEFAULT_RTOS_ISRPARAM:
  40 0000 00000000 		.space	4
  41              		.section	.text.TU1_Init,"ax",%progbits
  42              		.align	2
  43              		.global	TU1_Init
  44              		.code	16
  45              		.thumb_func
  47              	TU1_Init:
  48              	.LFB0:
  49              		.file 1 "../Generated_Code/TU1.c"
   1:../Generated_Code/TU1.c **** /** ###################################################################
   2:../Generated_Code/TU1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/TU1.c **** **     Filename    : TU1.c
   4:../Generated_Code/TU1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/TU1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/TU1.c **** **     Component   : TimerUnit_LDD
   7:../Generated_Code/TU1.c **** **     Version     : Component 01.139, Driver 01.09, CPU db: 3.00.000
   8:../Generated_Code/TU1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/TU1.c **** **     Date/Time   : 2013-08-21, 10:54, # CodeGen: 19
  10:../Generated_Code/TU1.c **** **     Abstract    :
  11:../Generated_Code/TU1.c **** **          This TimerUnit component provides a low level API for unified hardware access across
  12:../Generated_Code/TU1.c **** **          various timer devices using the Prescaler-Counter-Compare-Capture timer structure.
  13:../Generated_Code/TU1.c **** **     Settings    :
  14:../Generated_Code/TU1.c **** **          Component name                                 : TU1
  15:../Generated_Code/TU1.c **** **          Module name                                    : TPM0
  16:../Generated_Code/TU1.c **** **          Counter                                        : TPM0_CNT
  17:../Generated_Code/TU1.c **** **          Counter direction                              : Up
  18:../Generated_Code/TU1.c **** **          Counter width                                  : 16 bits
  19:../Generated_Code/TU1.c **** **          Value type                                     : Optimal
  20:../Generated_Code/TU1.c **** **          Input clock source                             : Internal
  21:../Generated_Code/TU1.c **** **            Counter frequency                            : 2.62144 MHz
  22:../Generated_Code/TU1.c **** **          Counter restart                                : On-overrun
  23:../Generated_Code/TU1.c **** **            Overrun period                               : Auto select
  24:../Generated_Code/TU1.c **** **            Interrupt                                    : Enabled
  25:../Generated_Code/TU1.c **** **              Interrupt                                  : INT_TPM0
  26:../Generated_Code/TU1.c **** **              Interrupt priority                         : medium priority
  27:../Generated_Code/TU1.c **** **          Channel list                                   : 1
  28:../Generated_Code/TU1.c **** **            Channel 0                                    : 
  29:../Generated_Code/TU1.c **** **              Mode                                       : Capture
  30:../Generated_Code/TU1.c **** **                Capture                                  : TPM0_C4V
  31:../Generated_Code/TU1.c **** **                Capture input pin                        : PTD4/LLWU_P14/SPI1_PCS0/UART2_RX/TPM0_
  32:../Generated_Code/TU1.c **** **                Capture input signal                     : US_Echo_D2
  33:../Generated_Code/TU1.c **** **                Edge                                     : both edges
  34:../Generated_Code/TU1.c **** **                Maximum time of event                    : 25.00001792 ms
  35:../Generated_Code/TU1.c **** **                Interrupt                                : Enabled
  36:../Generated_Code/TU1.c **** **                  Interrupt                              : INT_TPM0
  37:../Generated_Code/TU1.c **** **                  Interrupt priority                     : medium priority
  38:../Generated_Code/TU1.c **** **          Initialization                                 : 
  39:../Generated_Code/TU1.c **** **            Enabled in init. code                        : yes
  40:../Generated_Code/TU1.c **** **            Auto initialization                          : no
  41:../Generated_Code/TU1.c **** **            Event mask                                   : 
  42:../Generated_Code/TU1.c **** **              OnCounterRestart                           : Enabled
  43:../Generated_Code/TU1.c **** **              OnChannel0                                 : Enabled
  44:../Generated_Code/TU1.c **** **              OnChannel1                                 : Disabled
  45:../Generated_Code/TU1.c **** **              OnChannel2                                 : Disabled
  46:../Generated_Code/TU1.c **** **              OnChannel3                                 : Disabled
  47:../Generated_Code/TU1.c **** **              OnChannel4                                 : Disabled
  48:../Generated_Code/TU1.c **** **              OnChannel5                                 : Disabled
  49:../Generated_Code/TU1.c **** **              OnChannel6                                 : Disabled
  50:../Generated_Code/TU1.c **** **              OnChannel7                                 : Disabled
  51:../Generated_Code/TU1.c **** **          CPU clock/configuration selection              : 
  52:../Generated_Code/TU1.c **** **            Clock configuration 0                        : This component enabled
  53:../Generated_Code/TU1.c **** **            Clock configuration 1                        : This component disabled
  54:../Generated_Code/TU1.c **** **            Clock configuration 2                        : This component disabled
  55:../Generated_Code/TU1.c **** **            Clock configuration 3                        : This component disabled
  56:../Generated_Code/TU1.c **** **            Clock configuration 4                        : This component disabled
  57:../Generated_Code/TU1.c **** **            Clock configuration 5                        : This component disabled
  58:../Generated_Code/TU1.c **** **            Clock configuration 6                        : This component disabled
  59:../Generated_Code/TU1.c **** **            Clock configuration 7                        : This component disabled
  60:../Generated_Code/TU1.c **** **     Contents    :
  61:../Generated_Code/TU1.c **** **         Init            - LDD_TDeviceData* TU1_Init(LDD_TUserData *UserDataPtr);
  62:../Generated_Code/TU1.c **** **         Deinit          - void TU1_Deinit(LDD_TDeviceData *DeviceDataPtr);
  63:../Generated_Code/TU1.c **** **         ResetCounter    - LDD_TError TU1_ResetCounter(LDD_TDeviceData *DeviceDataPtr);
  64:../Generated_Code/TU1.c **** **         GetCaptureValue - LDD_TError TU1_GetCaptureValue(LDD_TDeviceData *DeviceDataPtr, uint8_t
  65:../Generated_Code/TU1.c **** **
  66:../Generated_Code/TU1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  67:../Generated_Code/TU1.c **** **     
  68:../Generated_Code/TU1.c **** **     http      : www.freescale.com
  69:../Generated_Code/TU1.c **** **     mail      : support@freescale.com
  70:../Generated_Code/TU1.c **** ** ###################################################################*/
  71:../Generated_Code/TU1.c **** 
  72:../Generated_Code/TU1.c **** /* MODULE TU1. */
  73:../Generated_Code/TU1.c **** 
  74:../Generated_Code/TU1.c **** #include "Events.h"
  75:../Generated_Code/TU1.c **** #include "TU1.h"
  76:../Generated_Code/TU1.c **** /* {Default RTOS Adapter} No RTOS includes */
  77:../Generated_Code/TU1.c **** #include "IO_Map.h"
  78:../Generated_Code/TU1.c **** 
  79:../Generated_Code/TU1.c **** /* List of channels used by component */
  80:../Generated_Code/TU1.c **** static const uint8_t ChannelDevice[TU1_NUMBER_OF_CHANNELS] = {0x04U};
  81:../Generated_Code/TU1.c **** 
  82:../Generated_Code/TU1.c **** /* Table of channels mode / 0 - compare mode, 1 - capture mode */
  83:../Generated_Code/TU1.c **** static const uint8_t ChannelMode[TU1_NUMBER_OF_CHANNELS] = {0x01U};
  84:../Generated_Code/TU1.c **** 
  85:../Generated_Code/TU1.c **** 
  86:../Generated_Code/TU1.c **** typedef struct {
  87:../Generated_Code/TU1.c ****   LDD_TEventMask EnEvents;             /* Enable/Disable events mask */
  88:../Generated_Code/TU1.c ****   LDD_TUserData *UserDataPtr;          /* RTOS device data structure */
  89:../Generated_Code/TU1.c **** } TU1_TDeviceData;
  90:../Generated_Code/TU1.c **** 
  91:../Generated_Code/TU1.c **** typedef TU1_TDeviceData *TU1_TDeviceDataPtr; /* Pointer to the device data structure. */
  92:../Generated_Code/TU1.c **** 
  93:../Generated_Code/TU1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
  94:../Generated_Code/TU1.c **** static TU1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  95:../Generated_Code/TU1.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
  96:../Generated_Code/TU1.c **** static TU1_TDeviceDataPtr INT_TPM0__DEFAULT_RTOS_ISRPARAM;
  97:../Generated_Code/TU1.c **** 
  98:../Generated_Code/TU1.c **** #define AVAILABLE_EVENTS_MASK (LDD_TEventMask)(LDD_TIMERUNIT_ON_CHANNEL_0 | LDD_TIMERUNIT_ON_COUNTE
  99:../Generated_Code/TU1.c **** #define AVAILABLE_PIN_MASK (LDD_TPinMask)(TU1_CHANNEL_0_PIN)
 100:../Generated_Code/TU1.c **** #define LAST_CHANNEL 0x00U
 101:../Generated_Code/TU1.c **** 
 102:../Generated_Code/TU1.c **** /* Internal method prototypes */
 103:../Generated_Code/TU1.c **** /*
 104:../Generated_Code/TU1.c **** ** ===================================================================
 105:../Generated_Code/TU1.c **** **     Method      :  TU1_Init (component TimerUnit_LDD)
 106:../Generated_Code/TU1.c **** **
 107:../Generated_Code/TU1.c **** **     Description :
 108:../Generated_Code/TU1.c **** **         Initializes the device. Allocates memory for the device data
 109:../Generated_Code/TU1.c **** **         structure, allocates interrupt vectors and sets interrupt
 110:../Generated_Code/TU1.c **** **         priority, sets pin routing, sets timing, etc. If the
 111:../Generated_Code/TU1.c **** **         property <"Enable in init. code"> is set to "yes" value then
 112:../Generated_Code/TU1.c **** **         the device is also enabled (see the description of the
 113:../Generated_Code/TU1.c **** **         <Enable> method). In this case the <Enable> method is not
 114:../Generated_Code/TU1.c **** **         necessary and needn't to be generated. This method can be
 115:../Generated_Code/TU1.c **** **         called only once. Before the second call of Init the <Deinit>
 116:../Generated_Code/TU1.c **** **         must be called first.
 117:../Generated_Code/TU1.c **** **     Parameters  :
 118:../Generated_Code/TU1.c **** **         NAME            - DESCRIPTION
 119:../Generated_Code/TU1.c **** **       * UserDataPtr     - Pointer to the user or
 120:../Generated_Code/TU1.c **** **                           RTOS specific data. This pointer will be
 121:../Generated_Code/TU1.c **** **                           passed as an event or callback parameter.
 122:../Generated_Code/TU1.c **** **     Returns     :
 123:../Generated_Code/TU1.c **** **         ---             - Pointer to the dynamically allocated
 124:../Generated_Code/TU1.c **** **                           private structure or NULL if there was an
 125:../Generated_Code/TU1.c **** **                           error.
 126:../Generated_Code/TU1.c **** ** ===================================================================
 127:../Generated_Code/TU1.c **** */
 128:../Generated_Code/TU1.c **** LDD_TDeviceData* TU1_Init(LDD_TUserData *UserDataPtr)
 129:../Generated_Code/TU1.c **** {
  50              		.loc 1 129 0
  51              		.cfi_startproc
  52 0000 80B5     		push	{r7, lr}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 8
  55              		.cfi_offset 7, -8
  56              		.cfi_offset 14, -4
  57 0002 84B0     		sub	sp, sp, #16
  58              	.LCFI1:
  59              		.cfi_def_cfa_offset 24
  60 0004 00AF     		add	r7, sp, #0
  61              	.LCFI2:
  62              		.cfi_def_cfa_register 7
  63 0006 7860     		str	r0, [r7, #4]
 130:../Generated_Code/TU1.c ****   /* Allocate device structure */
 131:../Generated_Code/TU1.c ****   TU1_TDeviceData *DeviceDataPrv;
 132:../Generated_Code/TU1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 133:../Generated_Code/TU1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  64              		.loc 1 133 0
  65 0008 2D4B     		ldr	r3, .L2
  66 000a FB60     		str	r3, [r7, #12]
 134:../Generated_Code/TU1.c ****   DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  67              		.loc 1 134 0
  68 000c FB68     		ldr	r3, [r7, #12]
  69 000e 7A68     		ldr	r2, [r7, #4]
  70 0010 5A60     		str	r2, [r3, #4]
 135:../Generated_Code/TU1.c ****   /* Interrupt vector(s) allocation */
 136:../Generated_Code/TU1.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 137:../Generated_Code/TU1.c ****   INT_TPM0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  71              		.loc 1 137 0
  72 0012 2C4B     		ldr	r3, .L2+4
  73 0014 FA68     		ldr	r2, [r7, #12]
  74 0016 1A60     		str	r2, [r3]
 138:../Generated_Code/TU1.c ****   /* SIM_SCGC6: TPM0=1 */
 139:../Generated_Code/TU1.c ****   SIM_SCGC6 |= SIM_SCGC6_TPM0_MASK;                                                   
  75              		.loc 1 139 0
  76 0018 2B4A     		ldr	r2, .L2+8
  77 001a 2B49     		ldr	r1, .L2+8
  78 001c 2B4B     		ldr	r3, .L2+12
  79 001e CB58     		ldr	r3, [r1, r3]
  80 0020 8021     		mov	r1, #128
  81 0022 4904     		lsl	r1, r1, #17
  82 0024 1943     		orr	r1, r3
  83 0026 294B     		ldr	r3, .L2+12
  84 0028 D150     		str	r1, [r2, r3]
 140:../Generated_Code/TU1.c ****   /* TPM0_SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,
 141:../Generated_Code/TU1.c ****   TPM0_SC = 0x00U;                     /* Clear status and control register */
  85              		.loc 1 141 0
  86 002a 294B     		ldr	r3, .L2+16
  87 002c 0022     		mov	r2, #0
  88 002e 1A60     		str	r2, [r3]
 142:../Generated_Code/TU1.c ****   /* TPM0_CNT: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,COUN
 143:../Generated_Code/TU1.c ****   TPM0_CNT = 0x00U;                    /* Reset counter register */
  89              		.loc 1 143 0
  90 0030 274B     		ldr	r3, .L2+16
  91 0032 0022     		mov	r2, #0
  92 0034 5A60     		str	r2, [r3, #4]
 144:../Generated_Code/TU1.c ****   /* TPM0_C0SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 145:../Generated_Code/TU1.c ****   TPM0_C0SC = 0x00U;                   /* Clear channel status and control register */
  93              		.loc 1 145 0
  94 0036 264B     		ldr	r3, .L2+16
  95 0038 0022     		mov	r2, #0
  96 003a DA60     		str	r2, [r3, #12]
 146:../Generated_Code/TU1.c ****   /* TPM0_C1SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 147:../Generated_Code/TU1.c ****   TPM0_C1SC = 0x00U;                   /* Clear channel status and control register */
  97              		.loc 1 147 0
  98 003c 244B     		ldr	r3, .L2+16
  99 003e 0022     		mov	r2, #0
 100 0040 5A61     		str	r2, [r3, #20]
 148:../Generated_Code/TU1.c ****   /* TPM0_C2SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 149:../Generated_Code/TU1.c ****   TPM0_C2SC = 0x00U;                   /* Clear channel status and control register */
 101              		.loc 1 149 0
 102 0042 234B     		ldr	r3, .L2+16
 103 0044 0022     		mov	r2, #0
 104 0046 DA61     		str	r2, [r3, #28]
 150:../Generated_Code/TU1.c ****   /* TPM0_C3SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 151:../Generated_Code/TU1.c ****   TPM0_C3SC = 0x00U;                   /* Clear channel status and control register */
 105              		.loc 1 151 0
 106 0048 214B     		ldr	r3, .L2+16
 107 004a 0022     		mov	r2, #0
 108 004c 5A62     		str	r2, [r3, #36]
 152:../Generated_Code/TU1.c ****   /* TPM0_C4SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 153:../Generated_Code/TU1.c ****   TPM0_C4SC = 0x00U;                   /* Clear channel status and control register */
 109              		.loc 1 153 0
 110 004e 204B     		ldr	r3, .L2+16
 111 0050 0022     		mov	r2, #0
 112 0052 DA62     		str	r2, [r3, #44]
 154:../Generated_Code/TU1.c ****   /* TPM0_C5SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 155:../Generated_Code/TU1.c ****   TPM0_C5SC = 0x00U;                   /* Clear channel status and control register */
 113              		.loc 1 155 0
 114 0054 1E4B     		ldr	r3, .L2+16
 115 0056 0022     		mov	r2, #0
 116 0058 5A63     		str	r2, [r3, #52]
 156:../Generated_Code/TU1.c ****   /* TPM0_MOD: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,MOD=
 157:../Generated_Code/TU1.c ****   TPM0_MOD = TPM_MOD_MOD(0xFFFF);      /* Set up modulo register */
 117              		.loc 1 157 0
 118 005a 1D4B     		ldr	r3, .L2+16
 119 005c 1D4A     		ldr	r2, .L2+20
 120 005e 9A60     		str	r2, [r3, #8]
 158:../Generated_Code/TU1.c ****   /* TPM0_C4SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 159:../Generated_Code/TU1.c ****   TPM0_C4SC = (TPM_CnSC_CHIE_MASK | TPM_CnSC_ELSB_MASK | TPM_CnSC_ELSA_MASK); /* Set up channel sta
 121              		.loc 1 159 0
 122 0060 1B4B     		ldr	r3, .L2+16
 123 0062 4C22     		mov	r2, #76
 124 0064 DA62     		str	r2, [r3, #44]
 160:../Generated_Code/TU1.c ****   /* PORTD_PCR4: ISF=0,MUX=4 */
 161:../Generated_Code/TU1.c ****   PORTD_PCR4 = (uint32_t)((PORTD_PCR4 & (uint32_t)~(uint32_t)(
 125              		.loc 1 161 0
 126 0066 1C4B     		ldr	r3, .L2+24
 127 0068 1B4A     		ldr	r2, .L2+24
 128 006a 1269     		ldr	r2, [r2, #16]
 129 006c 111C     		mov	r1, r2
 130 006e 1B4A     		ldr	r2, .L2+28
 131 0070 0A40     		and	r2, r1
 132 0072 8021     		mov	r1, #128
 133 0074 C900     		lsl	r1, r1, #3
 134 0076 0A43     		orr	r2, r1
 135 0078 1A61     		str	r2, [r3, #16]
 162:../Generated_Code/TU1.c ****                 PORT_PCR_ISF_MASK |
 163:../Generated_Code/TU1.c ****                 PORT_PCR_MUX(0x03)
 164:../Generated_Code/TU1.c ****                )) | (uint32_t)(
 165:../Generated_Code/TU1.c ****                 PORT_PCR_MUX(0x04)
 166:../Generated_Code/TU1.c ****                ));                                                  
 167:../Generated_Code/TU1.c ****   DeviceDataPrv->EnEvents = 0x0101U;   /* Enable selected events */
 136              		.loc 1 167 0
 137 007a FB68     		ldr	r3, [r7, #12]
 138 007c 184A     		ldr	r2, .L2+32
 139 007e 1A60     		str	r2, [r3]
 168:../Generated_Code/TU1.c ****   /* NVIC_IPR4: PRI_17=0x80 */
 169:../Generated_Code/TU1.c ****   NVIC_IPR4 = (uint32_t)((NVIC_IPR4 & (uint32_t)~(uint32_t)(
 140              		.loc 1 169 0
 141 0080 184A     		ldr	r2, .L2+36
 142 0082 1849     		ldr	r1, .L2+36
 143 0084 C423     		mov	r3, #196
 144 0086 9B00     		lsl	r3, r3, #2
 145 0088 CB58     		ldr	r3, [r1, r3]
 146 008a 191C     		mov	r1, r3
 147 008c 164B     		ldr	r3, .L2+40
 148 008e 0B40     		and	r3, r1
 149 0090 8021     		mov	r1, #128
 150 0092 0902     		lsl	r1, r1, #8
 151 0094 1943     		orr	r1, r3
 152 0096 C423     		mov	r3, #196
 153 0098 9B00     		lsl	r3, r3, #2
 154 009a D150     		str	r1, [r2, r3]
 170:../Generated_Code/TU1.c ****                NVIC_IP_PRI_17(0x7F)
 171:../Generated_Code/TU1.c ****               )) | (uint32_t)(
 172:../Generated_Code/TU1.c ****                NVIC_IP_PRI_17(0x80)
 173:../Generated_Code/TU1.c ****               ));                                                  
 174:../Generated_Code/TU1.c ****   /* NVIC_ISER: SETENA|=0x00020000 */
 175:../Generated_Code/TU1.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x00020000);                                                   
 155              		.loc 1 175 0
 156 009c 114B     		ldr	r3, .L2+36
 157 009e 114A     		ldr	r2, .L2+36
 158 00a0 1268     		ldr	r2, [r2]
 159 00a2 8021     		mov	r1, #128
 160 00a4 8902     		lsl	r1, r1, #10
 161 00a6 0A43     		orr	r2, r1
 162 00a8 1A60     		str	r2, [r3]
 176:../Generated_Code/TU1.c ****   /* TPM0_SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,
 177:../Generated_Code/TU1.c ****   TPM0_SC = (TPM_SC_TOIE_MASK | TPM_SC_CMOD(0x01) | TPM_SC_PS(0x03)); /* Set up status and control 
 163              		.loc 1 177 0
 164 00aa 094B     		ldr	r3, .L2+16
 165 00ac 4B22     		mov	r2, #75
 166 00ae 1A60     		str	r2, [r3]
 178:../Generated_Code/TU1.c ****   /* Registration of the device structure */
 179:../Generated_Code/TU1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_TU1_ID,DeviceDataPrv);
 167              		.loc 1 179 0
 168 00b0 0E4B     		ldr	r3, .L2+44
 169 00b2 FA68     		ldr	r2, [r7, #12]
 170 00b4 DA60     		str	r2, [r3, #12]
 180:../Generated_Code/TU1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the device data structure */
 171              		.loc 1 180 0
 172 00b6 FB68     		ldr	r3, [r7, #12]
 181:../Generated_Code/TU1.c **** }
 173              		.loc 1 181 0
 174 00b8 181C     		mov	r0, r3
 175 00ba BD46     		mov	sp, r7
 176 00bc 04B0     		add	sp, sp, #16
 177              		@ sp needed for prologue
 178 00be 80BD     		pop	{r7, pc}
 179              	.L3:
 180              		.align	2
 181              	.L2:
 182 00c0 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 183 00c4 00000000 		.word	INT_TPM0__DEFAULT_RTOS_ISRPARAM
 184 00c8 00700440 		.word	1074032640
 185 00cc 3C100000 		.word	4156
 186 00d0 00800340 		.word	1073971200
 187 00d4 FFFF0000 		.word	65535
 188 00d8 00C00440 		.word	1074053120
 189 00dc FFF8FFFE 		.word	-16779009
 190 00e0 01010000 		.word	257
 191 00e4 00E100E0 		.word	-536813312
 192 00e8 FF00FFFF 		.word	-65281
 193 00ec 00000000 		.word	PE_LDD_DeviceDataList
 194              		.cfi_endproc
 195              	.LFE0:
 197              		.section	.text.TU1_Deinit,"ax",%progbits
 198              		.align	2
 199              		.global	TU1_Deinit
 200              		.code	16
 201              		.thumb_func
 203              	TU1_Deinit:
 204              	.LFB1:
 182:../Generated_Code/TU1.c **** 
 183:../Generated_Code/TU1.c **** /*
 184:../Generated_Code/TU1.c **** ** ===================================================================
 185:../Generated_Code/TU1.c **** **     Method      :  TU1_Deinit (component TimerUnit_LDD)
 186:../Generated_Code/TU1.c **** **
 187:../Generated_Code/TU1.c **** **     Description :
 188:../Generated_Code/TU1.c **** **         Deinitializes the device. Switches off the device, frees the
 189:../Generated_Code/TU1.c **** **         device data structure memory, interrupts vectors, etc.
 190:../Generated_Code/TU1.c **** **     Parameters  :
 191:../Generated_Code/TU1.c **** **         NAME            - DESCRIPTION
 192:../Generated_Code/TU1.c **** **       * DeviceDataPtr   - Device data structure
 193:../Generated_Code/TU1.c **** **                           pointer returned by Init method
 194:../Generated_Code/TU1.c **** **     Returns     : Nothing
 195:../Generated_Code/TU1.c **** ** ===================================================================
 196:../Generated_Code/TU1.c **** */
 197:../Generated_Code/TU1.c **** void TU1_Deinit(LDD_TDeviceData *DeviceDataPtr)
 198:../Generated_Code/TU1.c **** {
 205              		.loc 1 198 0
 206              		.cfi_startproc
 207 0000 80B5     		push	{r7, lr}
 208              	.LCFI3:
 209              		.cfi_def_cfa_offset 8
 210              		.cfi_offset 7, -8
 211              		.cfi_offset 14, -4
 212 0002 84B0     		sub	sp, sp, #16
 213              	.LCFI4:
 214              		.cfi_def_cfa_offset 24
 215 0004 00AF     		add	r7, sp, #0
 216              	.LCFI5:
 217              		.cfi_def_cfa_register 7
 218 0006 7860     		str	r0, [r7, #4]
 199:../Generated_Code/TU1.c ****   TU1_TDeviceData *DeviceDataPrv = (TU1_TDeviceData *)DeviceDataPtr;
 219              		.loc 1 199 0
 220 0008 7B68     		ldr	r3, [r7, #4]
 221 000a FB60     		str	r3, [r7, #12]
 200:../Generated_Code/TU1.c **** 
 201:../Generated_Code/TU1.c ****   (void)DeviceDataPrv;
 202:../Generated_Code/TU1.c ****   TPM_PDD_SelectPrescalerSource(TPM0_BASE_PTR, TPM_PDD_DISABLED);
 222              		.loc 1 202 0
 223 000c 054B     		ldr	r3, .L5
 224 000e 054A     		ldr	r2, .L5
 225 0010 1268     		ldr	r2, [r2]
 226 0012 9821     		mov	r1, #152
 227 0014 8A43     		bic	r2, r1
 228 0016 1A60     		str	r2, [r3]
 203:../Generated_Code/TU1.c ****   /* Interrupt vector(s) deallocation */
 204:../Generated_Code/TU1.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 205:../Generated_Code/TU1.c ****   /* Unregistration of the device structure */
 206:../Generated_Code/TU1.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_TU1_ID);
 229              		.loc 1 206 0
 230 0018 034B     		ldr	r3, .L5+4
 231 001a 0022     		mov	r2, #0
 232 001c DA60     		str	r2, [r3, #12]
 207:../Generated_Code/TU1.c ****   /* Deallocation of the device structure */
 208:../Generated_Code/TU1.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 209:../Generated_Code/TU1.c **** }
 233              		.loc 1 209 0
 234 001e BD46     		mov	sp, r7
 235 0020 04B0     		add	sp, sp, #16
 236              		@ sp needed for prologue
 237 0022 80BD     		pop	{r7, pc}
 238              	.L6:
 239              		.align	2
 240              	.L5:
 241 0024 00800340 		.word	1073971200
 242 0028 00000000 		.word	PE_LDD_DeviceDataList
 243              		.cfi_endproc
 244              	.LFE1:
 246              		.section	.text.TU1_ResetCounter,"ax",%progbits
 247              		.align	2
 248              		.global	TU1_ResetCounter
 249              		.code	16
 250              		.thumb_func
 252              	TU1_ResetCounter:
 253              	.LFB2:
 210:../Generated_Code/TU1.c **** 
 211:../Generated_Code/TU1.c **** /*
 212:../Generated_Code/TU1.c **** ** ===================================================================
 213:../Generated_Code/TU1.c **** **     Method      :  TU1_ResetCounter (component TimerUnit_LDD)
 214:../Generated_Code/TU1.c **** **
 215:../Generated_Code/TU1.c **** **     Description :
 216:../Generated_Code/TU1.c **** **         Resets counter. If counter is counting up then it is set to
 217:../Generated_Code/TU1.c **** **         zero. If counter is counting down then counter is updated to
 218:../Generated_Code/TU1.c **** **         the reload value.
 219:../Generated_Code/TU1.c **** **         The method is not available if HW doesn't allow resetting of
 220:../Generated_Code/TU1.c **** **         the counter.
 221:../Generated_Code/TU1.c **** **     Parameters  :
 222:../Generated_Code/TU1.c **** **         NAME            - DESCRIPTION
 223:../Generated_Code/TU1.c **** **       * DeviceDataPtr   - Device data structure
 224:../Generated_Code/TU1.c **** **                           pointer returned by <Init> method.
 225:../Generated_Code/TU1.c **** **     Returns     :
 226:../Generated_Code/TU1.c **** **         ---             - Error code, possible codes:
 227:../Generated_Code/TU1.c **** **                           ERR_OK - OK 
 228:../Generated_Code/TU1.c **** **                           ERR_SPEED - The component does not work in
 229:../Generated_Code/TU1.c **** **                           the active clock configuration
 230:../Generated_Code/TU1.c **** ** ===================================================================
 231:../Generated_Code/TU1.c **** */
 232:../Generated_Code/TU1.c **** LDD_TError TU1_ResetCounter(LDD_TDeviceData *DeviceDataPtr)
 233:../Generated_Code/TU1.c **** {
 254              		.loc 1 233 0
 255              		.cfi_startproc
 256 0000 80B5     		push	{r7, lr}
 257              	.LCFI6:
 258              		.cfi_def_cfa_offset 8
 259              		.cfi_offset 7, -8
 260              		.cfi_offset 14, -4
 261 0002 82B0     		sub	sp, sp, #8
 262              	.LCFI7:
 263              		.cfi_def_cfa_offset 16
 264 0004 00AF     		add	r7, sp, #0
 265              	.LCFI8:
 266              		.cfi_def_cfa_register 7
 267 0006 7860     		str	r0, [r7, #4]
 234:../Generated_Code/TU1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 235:../Generated_Code/TU1.c ****   TPM_PDD_InitializeCounter(TPM0_BASE_PTR);
 268              		.loc 1 235 0
 269 0008 034B     		ldr	r3, .L8
 270 000a 0022     		mov	r2, #0
 271 000c 5A60     		str	r2, [r3, #4]
 236:../Generated_Code/TU1.c ****   return ERR_OK;                       /* OK */
 272              		.loc 1 236 0
 273 000e 0023     		mov	r3, #0
 237:../Generated_Code/TU1.c **** }
 274              		.loc 1 237 0
 275 0010 181C     		mov	r0, r3
 276 0012 BD46     		mov	sp, r7
 277 0014 02B0     		add	sp, sp, #8
 278              		@ sp needed for prologue
 279 0016 80BD     		pop	{r7, pc}
 280              	.L9:
 281              		.align	2
 282              	.L8:
 283 0018 00800340 		.word	1073971200
 284              		.cfi_endproc
 285              	.LFE2:
 287              		.section	.text.TU1_GetCaptureValue,"ax",%progbits
 288              		.align	2
 289              		.global	TU1_GetCaptureValue
 290              		.code	16
 291              		.thumb_func
 293              	TU1_GetCaptureValue:
 294              	.LFB3:
 238:../Generated_Code/TU1.c **** 
 239:../Generated_Code/TU1.c **** /*
 240:../Generated_Code/TU1.c **** ** ===================================================================
 241:../Generated_Code/TU1.c **** **     Method      :  TU1_GetCaptureValue (component TimerUnit_LDD)
 242:../Generated_Code/TU1.c **** **
 243:../Generated_Code/TU1.c **** **     Description :
 244:../Generated_Code/TU1.c **** **         Returns the content of capture register specified by the
 245:../Generated_Code/TU1.c **** **         parameter ChannelIdx. This method is available when at least
 246:../Generated_Code/TU1.c **** **         one channel is configured.
 247:../Generated_Code/TU1.c **** **     Parameters  :
 248:../Generated_Code/TU1.c **** **         NAME            - DESCRIPTION
 249:../Generated_Code/TU1.c **** **       * DeviceDataPtr   - Device data structure
 250:../Generated_Code/TU1.c **** **                           pointer returned by <Init> method.
 251:../Generated_Code/TU1.c **** **         ChannelIdx      - Index of the component
 252:../Generated_Code/TU1.c **** **                           channel.
 253:../Generated_Code/TU1.c **** **       * ValuePtr        - Pointer to return value of the
 254:../Generated_Code/TU1.c **** **                           capture register.
 255:../Generated_Code/TU1.c **** **     Returns     :
 256:../Generated_Code/TU1.c **** **         ---             - Error code, possible codes:
 257:../Generated_Code/TU1.c **** **                           ERR_OK - OK 
 258:../Generated_Code/TU1.c **** **                           ERR_PARAM_INDEX - ChannelIdx parameter is
 259:../Generated_Code/TU1.c **** **                           out of possible range
 260:../Generated_Code/TU1.c **** **                           ERR_NOTAVAIL -  The capture mode is not
 261:../Generated_Code/TU1.c **** **                           selected for selected channel.
 262:../Generated_Code/TU1.c **** **                           ERR_SPEED - The component does not work in
 263:../Generated_Code/TU1.c **** **                           the active clock configuration
 264:../Generated_Code/TU1.c **** ** ===================================================================
 265:../Generated_Code/TU1.c **** */
 266:../Generated_Code/TU1.c **** LDD_TError TU1_GetCaptureValue(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, TU1_TValueType *
 267:../Generated_Code/TU1.c **** {
 295              		.loc 1 267 0
 296              		.cfi_startproc
 297 0000 80B5     		push	{r7, lr}
 298              	.LCFI9:
 299              		.cfi_def_cfa_offset 8
 300              		.cfi_offset 7, -8
 301              		.cfi_offset 14, -4
 302 0002 84B0     		sub	sp, sp, #16
 303              	.LCFI10:
 304              		.cfi_def_cfa_offset 24
 305 0004 00AF     		add	r7, sp, #0
 306              	.LCFI11:
 307              		.cfi_def_cfa_register 7
 308 0006 F860     		str	r0, [r7, #12]
 309 0008 7A60     		str	r2, [r7, #4]
 310 000a 3B1C     		mov	r3, r7
 311 000c 0B33     		add	r3, r3, #11
 312 000e 0A1C     		add	r2, r1, #0
 313 0010 1A70     		strb	r2, [r3]
 268:../Generated_Code/TU1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 269:../Generated_Code/TU1.c ****   /* Parameter test - this test can be disabled by setting the "Ignore range checking"
 270:../Generated_Code/TU1.c ****      property to the "yes" value in the "Configuration inspector" */
 271:../Generated_Code/TU1.c ****   if (ChannelIdx > LAST_CHANNEL) {     /* Is the channel index out of range? */
 314              		.loc 1 271 0
 315 0012 3B1C     		mov	r3, r7
 316 0014 0B33     		add	r3, r3, #11
 317 0016 1B78     		ldrb	r3, [r3]
 318 0018 002B     		cmp	r3, #0
 319 001a 01D0     		beq	.L11
 272:../Generated_Code/TU1.c ****     return ERR_PARAM_INDEX;            /* If yes then error */
 320              		.loc 1 272 0
 321 001c 8223     		mov	r3, #130
 322 001e 16E0     		b	.L12
 323              	.L11:
 273:../Generated_Code/TU1.c ****   }
 274:../Generated_Code/TU1.c ****   if ((ChannelMode[ChannelIdx]) != 1u) { /* Is the channel in capture mode? */
 324              		.loc 1 274 0
 325 0020 3B1C     		mov	r3, r7
 326 0022 0B33     		add	r3, r3, #11
 327 0024 1B78     		ldrb	r3, [r3]
 328 0026 0C4A     		ldr	r2, .L14
 329 0028 D35C     		ldrb	r3, [r2, r3]
 330 002a 012B     		cmp	r3, #1
 331 002c 01D0     		beq	.L13
 275:../Generated_Code/TU1.c ****     return ERR_NOTAVAIL;               /* If not then error */
 332              		.loc 1 275 0
 333 002e 0923     		mov	r3, #9
 334 0030 0DE0     		b	.L12
 335              	.L13:
 276:../Generated_Code/TU1.c ****   }
 277:../Generated_Code/TU1.c ****   *ValuePtr = (TU1_TValueType)(TPM_PDD_ReadChannelValueReg(TPM0_BASE_PTR, ChannelDevice[ChannelIdx]
 336              		.loc 1 277 0
 337 0032 0A4A     		ldr	r2, .L14+4
 338 0034 3B1C     		mov	r3, r7
 339 0036 0B33     		add	r3, r3, #11
 340 0038 1B78     		ldrb	r3, [r3]
 341 003a 0949     		ldr	r1, .L14+8
 342 003c CB5C     		ldrb	r3, [r1, r3]
 343 003e 0133     		add	r3, r3, #1
 344 0040 DB00     		lsl	r3, r3, #3
 345 0042 D318     		add	r3, r2, r3
 346 0044 9B68     		ldr	r3, [r3, #8]
 347 0046 1A1C     		mov	r2, r3
 348 0048 7B68     		ldr	r3, [r7, #4]
 349 004a 1A60     		str	r2, [r3]
 278:../Generated_Code/TU1.c ****   return ERR_OK;                       /* OK */
 350              		.loc 1 278 0
 351 004c 0023     		mov	r3, #0
 352              	.L12:
 279:../Generated_Code/TU1.c **** }
 353              		.loc 1 279 0
 354 004e 181C     		mov	r0, r3
 355 0050 BD46     		mov	sp, r7
 356 0052 04B0     		add	sp, sp, #16
 357              		@ sp needed for prologue
 358 0054 80BD     		pop	{r7, pc}
 359              	.L15:
 360 0056 C046     		.align	2
 361              	.L14:
 362 0058 00000000 		.word	ChannelMode
 363 005c 00800340 		.word	1073971200
 364 0060 00000000 		.word	ChannelDevice
 365              		.cfi_endproc
 366              	.LFE3:
 368              		.section	.text.TU1_Interrupt,"ax",%progbits
 369              		.align	2
 370              		.global	TU1_Interrupt
 371              		.code	16
 372              		.thumb_func
 374              	TU1_Interrupt:
 375              	.LFB4:
 280:../Generated_Code/TU1.c **** 
 281:../Generated_Code/TU1.c **** /*
 282:../Generated_Code/TU1.c **** ** ===================================================================
 283:../Generated_Code/TU1.c **** **     Method      :  TU1_Interrupt (component TimerUnit_LDD)
 284:../Generated_Code/TU1.c **** **
 285:../Generated_Code/TU1.c **** **     Description :
 286:../Generated_Code/TU1.c **** **         The method services the interrupt of the selected peripheral(s)
 287:../Generated_Code/TU1.c **** **         and eventually invokes event(s) of the component.
 288:../Generated_Code/TU1.c **** **         This method is internal. It is used by Processor Expert only.
 289:../Generated_Code/TU1.c **** ** ===================================================================
 290:../Generated_Code/TU1.c **** */
 291:../Generated_Code/TU1.c **** PE_ISR(TU1_Interrupt)
 292:../Generated_Code/TU1.c **** {
 376              		.loc 1 292 0
 377              		.cfi_startproc
 378 0000 80B5     		push	{r7, lr}
 379              	.LCFI12:
 380              		.cfi_def_cfa_offset 8
 381              		.cfi_offset 7, -8
 382              		.cfi_offset 14, -4
 383 0002 82B0     		sub	sp, sp, #8
 384              	.LCFI13:
 385              		.cfi_def_cfa_offset 16
 386 0004 00AF     		add	r7, sp, #0
 387              	.LCFI14:
 388              		.cfi_def_cfa_register 7
 293:../Generated_Code/TU1.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 294:../Generated_Code/TU1.c ****   TU1_TDeviceDataPtr DeviceDataPrv = INT_TPM0__DEFAULT_RTOS_ISRPARAM;
 389              		.loc 1 294 0
 390 0006 294B     		ldr	r3, .L21
 391 0008 1B68     		ldr	r3, [r3]
 392 000a 3B60     		str	r3, [r7]
 295:../Generated_Code/TU1.c **** 
 296:../Generated_Code/TU1.c ****   LDD_TEventMask State = 0U;
 393              		.loc 1 296 0
 394 000c 0023     		mov	r3, #0
 395 000e 7B60     		str	r3, [r7, #4]
 297:../Generated_Code/TU1.c **** 
 298:../Generated_Code/TU1.c ****   if ((TPM_PDD_GetOverflowInterruptFlag(TPM0_BASE_PTR)) != 0U) { /* Is the overflow interrupt flag 
 396              		.loc 1 298 0
 397 0010 274B     		ldr	r3, .L21+4
 398 0012 1B68     		ldr	r3, [r3]
 399 0014 1A1C     		mov	r2, r3
 400 0016 8023     		mov	r3, #128
 401 0018 1340     		and	r3, r2
 402 001a 04D0     		beq	.L17
 299:../Generated_Code/TU1.c ****     State |= LDD_TIMERUNIT_ON_COUNTER_RESTART; /* and set mask */
 403              		.loc 1 299 0
 404 001c 7B68     		ldr	r3, [r7, #4]
 405 001e 8022     		mov	r2, #128
 406 0020 5200     		lsl	r2, r2, #1
 407 0022 1343     		orr	r3, r2
 408 0024 7B60     		str	r3, [r7, #4]
 409              	.L17:
 300:../Generated_Code/TU1.c ****   }
 301:../Generated_Code/TU1.c ****   if ((TPM_PDD_GetChannelInterruptFlag(TPM0_BASE_PTR, ChannelDevice[0])) != 0U) { /* Is the channel
 410              		.loc 1 301 0
 411 0026 224A     		ldr	r2, .L21+4
 412 0028 224B     		ldr	r3, .L21+8
 413 002a 1B78     		ldrb	r3, [r3]
 414 002c 0133     		add	r3, r3, #1
 415 002e DB00     		lsl	r3, r3, #3
 416 0030 D318     		add	r3, r2, r3
 417 0032 5B68     		ldr	r3, [r3, #4]
 418 0034 1A1C     		mov	r2, r3
 419 0036 8023     		mov	r3, #128
 420 0038 1340     		and	r3, r2
 421 003a 03D0     		beq	.L18
 302:../Generated_Code/TU1.c ****     State |= LDD_TIMERUNIT_ON_CHANNEL_0; /* and set mask */
 422              		.loc 1 302 0
 423 003c 7B68     		ldr	r3, [r7, #4]
 424 003e 0122     		mov	r2, #1
 425 0040 1343     		orr	r3, r2
 426 0042 7B60     		str	r3, [r7, #4]
 427              	.L18:
 303:../Generated_Code/TU1.c ****   }
 304:../Generated_Code/TU1.c ****   State &= DeviceDataPrv->EnEvents;    /* Handle only enabled interrupts */
 428              		.loc 1 304 0
 429 0044 3B68     		ldr	r3, [r7]
 430 0046 1A68     		ldr	r2, [r3]
 431 0048 7B68     		ldr	r3, [r7, #4]
 432 004a 1340     		and	r3, r2
 433 004c 7B60     		str	r3, [r7, #4]
 305:../Generated_Code/TU1.c ****   if (State & LDD_TIMERUNIT_ON_COUNTER_RESTART) { /* Is the overflow interrupt flag pending? */
 434              		.loc 1 305 0
 435 004e 7A68     		ldr	r2, [r7, #4]
 436 0050 8023     		mov	r3, #128
 437 0052 5B00     		lsl	r3, r3, #1
 438 0054 1340     		and	r3, r2
 439 0056 0AD0     		beq	.L19
 306:../Generated_Code/TU1.c ****     TPM_PDD_ClearOverflowInterruptFlag(TPM0_BASE_PTR); /* Clear flag */
 440              		.loc 1 306 0
 441 0058 154B     		ldr	r3, .L21+4
 442 005a 154A     		ldr	r2, .L21+4
 443 005c 1268     		ldr	r2, [r2]
 444 005e 8021     		mov	r1, #128
 445 0060 0A43     		orr	r2, r1
 446 0062 1A60     		str	r2, [r3]
 307:../Generated_Code/TU1.c ****     TU1_OnCounterRestart(DeviceDataPrv->UserDataPtr); /* Invoke OnCounterRestart event */
 447              		.loc 1 307 0
 448 0064 3B68     		ldr	r3, [r7]
 449 0066 5B68     		ldr	r3, [r3, #4]
 450 0068 181C     		mov	r0, r3
 451 006a FFF7FEFF 		bl	TU1_OnCounterRestart
 452              	.L19:
 308:../Generated_Code/TU1.c ****   }
 309:../Generated_Code/TU1.c ****   if (State & LDD_TIMERUNIT_ON_CHANNEL_0) { /* Is the channel 0 interrupt flag pending? */
 453              		.loc 1 309 0
 454 006e 7A68     		ldr	r2, [r7, #4]
 455 0070 0123     		mov	r3, #1
 456 0072 1340     		and	r3, r2
 457 0074 DBB2     		uxtb	r3, r3
 458 0076 002B     		cmp	r3, #0
 459 0078 15D0     		beq	.L16
 310:../Generated_Code/TU1.c ****     TPM_PDD_ClearChannelInterruptFlag(TPM0_BASE_PTR, ChannelDevice[0]); /* Clear flag */
 460              		.loc 1 310 0
 461 007a 0D49     		ldr	r1, .L21+4
 462 007c 0D4B     		ldr	r3, .L21+8
 463 007e 1B78     		ldrb	r3, [r3]
 464 0080 181C     		mov	r0, r3
 465 0082 0B4A     		ldr	r2, .L21+4
 466 0084 0B4B     		ldr	r3, .L21+8
 467 0086 1B78     		ldrb	r3, [r3]
 468 0088 0133     		add	r3, r3, #1
 469 008a DB00     		lsl	r3, r3, #3
 470 008c D318     		add	r3, r2, r3
 471 008e 5B68     		ldr	r3, [r3, #4]
 472 0090 8022     		mov	r2, #128
 473 0092 1A43     		orr	r2, r3
 474 0094 431C     		add	r3, r0, #1
 475 0096 DB00     		lsl	r3, r3, #3
 476 0098 CB18     		add	r3, r1, r3
 477 009a 5A60     		str	r2, [r3, #4]
 311:../Generated_Code/TU1.c ****     TU1_OnChannel0(DeviceDataPrv->UserDataPtr); /* Invoke OnChannel0 event */
 478              		.loc 1 311 0
 479 009c 3B68     		ldr	r3, [r7]
 480 009e 5B68     		ldr	r3, [r3, #4]
 481 00a0 181C     		mov	r0, r3
 482 00a2 FFF7FEFF 		bl	TU1_OnChannel0
 483              	.L16:
 312:../Generated_Code/TU1.c ****   }
 313:../Generated_Code/TU1.c **** }
 484              		.loc 1 313 0
 485 00a6 BD46     		mov	sp, r7
 486 00a8 02B0     		add	sp, sp, #8
 487              		@ sp needed for prologue
 488 00aa 80BD     		pop	{r7, pc}
 489              	.L22:
 490              		.align	2
 491              	.L21:
 492 00ac 00000000 		.word	INT_TPM0__DEFAULT_RTOS_ISRPARAM
 493 00b0 00800340 		.word	1073971200
 494 00b4 00000000 		.word	ChannelDevice
 495              		.cfi_endproc
 496              	.LFE4:
 498              		.text
 499              	.Letext0:
 500              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 501              		.file 3 "C:/Users/LARM/workspace/Hello UltrasonicoMotor/Generated_Code/IO_Map.h"
 502              		.file 4 "C:/Users/LARM/workspace/Hello UltrasonicoMotor/Generated_Code/PE_LDD.h"
 503              		.file 5 "C:/Users/LARM/workspace/Hello UltrasonicoMotor/Generated_Code/TU1.h"
DEFINED SYMBOLS
                            *ABS*:00000000 TU1.c
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:18     .rodata.ChannelDevice:00000000 $d
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:21     .rodata.ChannelDevice:00000000 ChannelDevice
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:24     .rodata.ChannelMode:00000000 $d
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:27     .rodata.ChannelMode:00000000 ChannelMode
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:30     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:33     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:36     .bss.INT_TPM0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:39     .bss.INT_TPM0__DEFAULT_RTOS_ISRPARAM:00000000 INT_TPM0__DEFAULT_RTOS_ISRPARAM
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:42     .text.TU1_Init:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:47     .text.TU1_Init:00000000 TU1_Init
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:182    .text.TU1_Init:000000c0 $d
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:198    .text.TU1_Deinit:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:203    .text.TU1_Deinit:00000000 TU1_Deinit
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:241    .text.TU1_Deinit:00000024 $d
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:247    .text.TU1_ResetCounter:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:252    .text.TU1_ResetCounter:00000000 TU1_ResetCounter
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:283    .text.TU1_ResetCounter:00000018 $d
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:288    .text.TU1_GetCaptureValue:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:293    .text.TU1_GetCaptureValue:00000000 TU1_GetCaptureValue
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:362    .text.TU1_GetCaptureValue:00000058 $d
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:369    .text.TU1_Interrupt:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:374    .text.TU1_Interrupt:00000000 TU1_Interrupt
C:\Users\LARM\AppData\Local\Temp\ccgxN5bc.s:492    .text.TU1_Interrupt:000000ac $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
TU1_OnCounterRestart
TU1_OnChannel0
