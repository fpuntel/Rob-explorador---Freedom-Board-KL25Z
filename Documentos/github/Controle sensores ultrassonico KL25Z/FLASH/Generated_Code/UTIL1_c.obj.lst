   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UTIL1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.UTIL1_strcpy,"ax",%progbits
  18              		.align	2
  19              		.global	UTIL1_strcpy
  20              		.code	16
  21              		.thumb_func
  23              	UTIL1_strcpy:
  24              	.LFB0:
  25              		.file 1 "../Generated_Code/UTIL1.c"
   1:../Generated_Code/UTIL1.c **** /** ###################################################################
   2:../Generated_Code/UTIL1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/UTIL1.c **** **     Filename    : UTIL1.c
   4:../Generated_Code/UTIL1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/UTIL1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/UTIL1.c **** **     Component   : Utility
   7:../Generated_Code/UTIL1.c **** **     Version     : Component 01.086, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/UTIL1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/UTIL1.c **** **     Date/Time   : 2013-08-21, 10:54, # CodeGen: 19
  10:../Generated_Code/UTIL1.c **** **     Abstract    :
  11:../Generated_Code/UTIL1.c **** **          Contains various utility functions.
  12:../Generated_Code/UTIL1.c **** **     Settings    :
  13:../Generated_Code/UTIL1.c **** **          Component name                                 : UTIL1
  14:../Generated_Code/UTIL1.c **** **     Contents    :
  15:../Generated_Code/UTIL1.c **** **         strcpy                  - void UTIL1_strcpy(byte *dst, size_t dstSize, const unsigned ch
  16:../Generated_Code/UTIL1.c **** **         strcat                  - void UTIL1_strcat(byte *dst, size_t dstSize, const unsigned ch
  17:../Generated_Code/UTIL1.c **** **         chcat                   - void UTIL1_chcat(byte *dst, size_t dstSize, byte ch);
  18:../Generated_Code/UTIL1.c **** **         Num8sToStr              - void UTIL1_Num8sToStr(byte *dst, size_t dstSize, signed char v
  19:../Generated_Code/UTIL1.c **** **         Num8uToStr              - void UTIL1_Num8uToStr(byte *dst, size_t dstSize, byte val);
  20:../Generated_Code/UTIL1.c **** **         Num16sToStr             - void UTIL1_Num16sToStr(byte *dst, size_t dstSize, int16_t val)
  21:../Generated_Code/UTIL1.c **** **         Num16uToStr             - void UTIL1_Num16uToStr(byte *dst, size_t dstSize, word val);
  22:../Generated_Code/UTIL1.c **** **         Num32uToStr             - void UTIL1_Num32uToStr(byte *dst, size_t dstSize, dword val);
  23:../Generated_Code/UTIL1.c **** **         Num32sToStr             - void UTIL1_Num32sToStr(byte *dst, size_t dstSize, long val);
  24:../Generated_Code/UTIL1.c **** **         Num16sToStrFormatted    - void UTIL1_Num16sToStrFormatted(byte *dst, size_t dstSize, int
  25:../Generated_Code/UTIL1.c **** **         Num16uToStrFormatted    - void UTIL1_Num16uToStrFormatted(byte *dst, size_t dstSize, wor
  26:../Generated_Code/UTIL1.c **** **         Num32uToStrFormatted    - void UTIL1_Num32uToStrFormatted(byte *dst, size_t dstSize, dwo
  27:../Generated_Code/UTIL1.c **** **         Num32sToStrFormatted    - void UTIL1_Num32sToStrFormatted(byte *dst, size_t dstSize, lon
  28:../Generated_Code/UTIL1.c **** **         strcatNum8u             - void UTIL1_strcatNum8u(byte *dst, size_t dstSize, byte val);
  29:../Generated_Code/UTIL1.c **** **         strcatNum8s             - void UTIL1_strcatNum8s(byte *dst, size_t dstSize, signed char 
  30:../Generated_Code/UTIL1.c **** **         strcatNum16u            - void UTIL1_strcatNum16u(byte *dst, size_t dstSize, word val);
  31:../Generated_Code/UTIL1.c **** **         strcatNum16s            - void UTIL1_strcatNum16s(byte *dst, size_t dstSize, int16_t val
  32:../Generated_Code/UTIL1.c **** **         strcatNum32u            - void UTIL1_strcatNum32u(byte *dst, size_t dstSize, dword val);
  33:../Generated_Code/UTIL1.c **** **         strcatNum32s            - void UTIL1_strcatNum32s(byte *dst, size_t dstSize, long val);
  34:../Generated_Code/UTIL1.c **** **         strcatNum16uFormatted   - void UTIL1_strcatNum16uFormatted(byte *dst, size_t dstSize, wo
  35:../Generated_Code/UTIL1.c **** **         strcatNum16sFormatted   - void UTIL1_strcatNum16sFormatted(byte *dst, size_t dstSize, in
  36:../Generated_Code/UTIL1.c **** **         strcatNum32uFormatted   - void UTIL1_strcatNum32uFormatted(byte *dst, size_t dstSize, dw
  37:../Generated_Code/UTIL1.c **** **         strcatNum32sFormatted   - void UTIL1_strcatNum32sFormatted(byte *dst, size_t dstSize, lo
  38:../Generated_Code/UTIL1.c **** **         strcatNum8Hex           - void UTIL1_strcatNum8Hex(byte *dst, size_t dstSize, byte num);
  39:../Generated_Code/UTIL1.c **** **         strcatNum16Hex          - void UTIL1_strcatNum16Hex(byte *dst, size_t dstSize, word num)
  40:../Generated_Code/UTIL1.c **** **         strcatNum24Hex          - void UTIL1_strcatNum24Hex(byte *dst, size_t dstSize, dword num
  41:../Generated_Code/UTIL1.c **** **         strcatNum32Hex          - void UTIL1_strcatNum32Hex(byte *dst, size_t dstSize, dword num
  42:../Generated_Code/UTIL1.c **** **         IsLeapYear              - bool UTIL1_IsLeapYear(word year);
  43:../Generated_Code/UTIL1.c **** **         WeekDay                 - byte UTIL1_WeekDay(word year, byte month, byte day);
  44:../Generated_Code/UTIL1.c **** **         ReadEscapedName         - byte UTIL1_ReadEscapedName(const unsigned char *filename, byte
  45:../Generated_Code/UTIL1.c **** **         xatoi                   - byte UTIL1_xatoi(const unsigned char **str, long *res);
  46:../Generated_Code/UTIL1.c **** **         ScanDate                - byte UTIL1_ScanDate(const unsigned char **str, byte *day, byte
  47:../Generated_Code/UTIL1.c **** **         ScanTime                - byte UTIL1_ScanTime(const unsigned char **str, byte *hour, byt
  48:../Generated_Code/UTIL1.c **** **         ScanDecimal8uNumber     - byte UTIL1_ScanDecimal8uNumber(const unsigned char **str, byte
  49:../Generated_Code/UTIL1.c **** **         ScanDecimal16uNumber    - byte UTIL1_ScanDecimal16uNumber(const unsigned char **str, wor
  50:../Generated_Code/UTIL1.c **** **         ScanDecimal32uNumber    - byte UTIL1_ScanDecimal32uNumber(const unsigned char **str, dwo
  51:../Generated_Code/UTIL1.c **** **         ScanHex8uNumber         - byte UTIL1_ScanHex8uNumber(const unsigned char **str, byte *va
  52:../Generated_Code/UTIL1.c **** **         ScanHex8uNumberNoPrefix - byte UTIL1_ScanHex8uNumberNoPrefix(const unsigned char **str, 
  53:../Generated_Code/UTIL1.c **** **         ScanHex16uNumber        - byte UTIL1_ScanHex16uNumber(const unsigned char **str, word *v
  54:../Generated_Code/UTIL1.c **** **         ScanHex32uNumber        - byte UTIL1_ScanHex32uNumber(const unsigned char **str, dword *
  55:../Generated_Code/UTIL1.c **** **         strcmp                  - int16_t UTIL1_strcmp(const char *, const char *);
  56:../Generated_Code/UTIL1.c **** **         strncmp                 - int16_t UTIL1_strncmp(const char *, const char *, size_t size)
  57:../Generated_Code/UTIL1.c **** **         strtailcmp              - byte UTIL1_strtailcmp(byte *str, byte *tail);
  58:../Generated_Code/UTIL1.c **** **         strlen                  - word UTIL1_strlen(const char *);
  59:../Generated_Code/UTIL1.c **** **         strCutTail              - byte UTIL1_strCutTail(byte *str, byte *tail);
  60:../Generated_Code/UTIL1.c **** **
  61:../Generated_Code/UTIL1.c **** **     License   :  Open Source (LGPL)
  62:../Generated_Code/UTIL1.c **** **     Copyright : (c) Copyright Erich Styger, 2013, all rights reserved.
  63:../Generated_Code/UTIL1.c **** **     xatoi(): Copyright (C) 2010, ChaN, all right reserved. (see copyright notice and license at 
  64:../Generated_Code/UTIL1.c **** **     This an open source software implementing utility functions using Processor Expert.
  65:../Generated_Code/UTIL1.c **** **     This is a free software and is opened for education,  research and commercial developments u
  66:../Generated_Code/UTIL1.c **** **     * This is a free software and there is NO WARRANTY.
  67:../Generated_Code/UTIL1.c **** **     * No restriction on use. You can use, modify and redistribute it for
  68:../Generated_Code/UTIL1.c **** **       personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
  69:../Generated_Code/UTIL1.c **** **     * Redistributions of source code must retain the above copyright notice.
  70:../Generated_Code/UTIL1.c **** ** ###################################################################*/
  71:../Generated_Code/UTIL1.c **** 
  72:../Generated_Code/UTIL1.c **** /* MODULE UTIL1. */
  73:../Generated_Code/UTIL1.c **** 
  74:../Generated_Code/UTIL1.c **** #include "UTIL1.h"
  75:../Generated_Code/UTIL1.c **** 
  76:../Generated_Code/UTIL1.c **** /* Internal method prototypes */
  77:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill);
  78:../Generated_Code/UTIL1.c **** 
  79:../Generated_Code/UTIL1.c **** /*
  80:../Generated_Code/UTIL1.c **** ** ===================================================================
  81:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcpy (component Utility)
  82:../Generated_Code/UTIL1.c **** **
  83:../Generated_Code/UTIL1.c **** **     Description :
  84:../Generated_Code/UTIL1.c **** **         Same as normal strcpy, but safe as it does not write beyond
  85:../Generated_Code/UTIL1.c **** **         the buffer.
  86:../Generated_Code/UTIL1.c **** **     Parameters  :
  87:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
  88:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
  89:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
  90:../Generated_Code/UTIL1.c **** **                           bytes).
  91:../Generated_Code/UTIL1.c **** **       * src             - Pointer to source string.
  92:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
  93:../Generated_Code/UTIL1.c **** ** ===================================================================
  94:../Generated_Code/UTIL1.c **** */
  95:../Generated_Code/UTIL1.c **** /*!
  96:../Generated_Code/UTIL1.c ****   \brief copy the string src into dst. It performs the same task as strncpy, except
  97:../Generated_Code/UTIL1.c ****      - always terminates the result string.
  98:../Generated_Code/UTIL1.c ****      - does not zero out the remaining part in dst.
  99:../Generated_Code/UTIL1.c ****      Note: dstSize is the size of dst INCLUDING zero byte.
 100:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 101:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 102:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 103:../Generated_Code/UTIL1.c ****   \param[in] src The source string to copy
 104:../Generated_Code/UTIL1.c **** */
 105:../Generated_Code/UTIL1.c **** void UTIL1_strcpy(byte *dst, size_t dstSize, const unsigned char *src)
 106:../Generated_Code/UTIL1.c **** {
  26              		.loc 1 106 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 84B0     		sub	sp, sp, #16
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 24
  36 0004 00AF     		add	r7, sp, #0
  37              	.LCFI2:
  38              		.cfi_def_cfa_register 7
  39 0006 F860     		str	r0, [r7, #12]
  40 0008 B960     		str	r1, [r7, #8]
  41 000a 7A60     		str	r2, [r7, #4]
 107:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
  42              		.loc 1 107 0
  43 000c BB68     		ldr	r3, [r7, #8]
  44 000e 013B     		sub	r3, r3, #1
  45 0010 BB60     		str	r3, [r7, #8]
 108:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
  46              		.loc 1 108 0
  47 0012 0CE0     		b	.L2
  48              	.L4:
 109:../Generated_Code/UTIL1.c ****     *dst++ = *src++;
  49              		.loc 1 109 0
  50 0014 7B68     		ldr	r3, [r7, #4]
  51 0016 1A78     		ldrb	r2, [r3]
  52 0018 FB68     		ldr	r3, [r7, #12]
  53 001a 1A70     		strb	r2, [r3]
  54 001c FB68     		ldr	r3, [r7, #12]
  55 001e 0133     		add	r3, r3, #1
  56 0020 FB60     		str	r3, [r7, #12]
  57 0022 7B68     		ldr	r3, [r7, #4]
  58 0024 0133     		add	r3, r3, #1
  59 0026 7B60     		str	r3, [r7, #4]
 110:../Generated_Code/UTIL1.c ****     dstSize--;
  60              		.loc 1 110 0
  61 0028 BB68     		ldr	r3, [r7, #8]
  62 002a 013B     		sub	r3, r3, #1
  63 002c BB60     		str	r3, [r7, #8]
  64              	.L2:
 108:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
  65              		.loc 1 108 0 discriminator 1
  66 002e BB68     		ldr	r3, [r7, #8]
  67 0030 002B     		cmp	r3, #0
  68 0032 03D0     		beq	.L3
 108:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
  69              		.loc 1 108 0 is_stmt 0 discriminator 2
  70 0034 7B68     		ldr	r3, [r7, #4]
  71 0036 1B78     		ldrb	r3, [r3]
  72 0038 002B     		cmp	r3, #0
  73 003a EBD1     		bne	.L4
  74              	.L3:
 111:../Generated_Code/UTIL1.c ****   }
 112:../Generated_Code/UTIL1.c ****   *dst = '\0';
  75              		.loc 1 112 0 is_stmt 1
  76 003c FB68     		ldr	r3, [r7, #12]
  77 003e 0022     		mov	r2, #0
  78 0040 1A70     		strb	r2, [r3]
 113:../Generated_Code/UTIL1.c **** }
  79              		.loc 1 113 0
  80 0042 BD46     		mov	sp, r7
  81 0044 04B0     		add	sp, sp, #16
  82              		@ sp needed for prologue
  83 0046 80BD     		pop	{r7, pc}
  84              		.cfi_endproc
  85              	.LFE0:
  87              		.section	.text.UTIL1_strcat,"ax",%progbits
  88              		.align	2
  89              		.global	UTIL1_strcat
  90              		.code	16
  91              		.thumb_func
  93              	UTIL1_strcat:
  94              	.LFB1:
 114:../Generated_Code/UTIL1.c **** 
 115:../Generated_Code/UTIL1.c **** /*
 116:../Generated_Code/UTIL1.c **** ** ===================================================================
 117:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcat (component Utility)
 118:../Generated_Code/UTIL1.c **** **
 119:../Generated_Code/UTIL1.c **** **     Description :
 120:../Generated_Code/UTIL1.c **** **         Same as normal strcat, but safe as it does not write beyond
 121:../Generated_Code/UTIL1.c **** **         the buffer.
 122:../Generated_Code/UTIL1.c **** **     Parameters  :
 123:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 124:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 125:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 126:../Generated_Code/UTIL1.c **** **                           bytes).
 127:../Generated_Code/UTIL1.c **** **       * src             - Pointer to source string.
 128:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 129:../Generated_Code/UTIL1.c **** ** ===================================================================
 130:../Generated_Code/UTIL1.c **** */
 131:../Generated_Code/UTIL1.c **** /*!
 132:../Generated_Code/UTIL1.c ****   \brief Concat the string src into dst. Always terminates the result string.
 133:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 134:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 135:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 136:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 137:../Generated_Code/UTIL1.c ****   \param[in] src The source string to add
 138:../Generated_Code/UTIL1.c ****   */
 139:../Generated_Code/UTIL1.c **** void UTIL1_strcat(byte *dst, size_t dstSize, const unsigned char *src)
 140:../Generated_Code/UTIL1.c **** {
  95              		.loc 1 140 0
  96              		.cfi_startproc
  97 0000 80B5     		push	{r7, lr}
  98              	.LCFI3:
  99              		.cfi_def_cfa_offset 8
 100              		.cfi_offset 7, -8
 101              		.cfi_offset 14, -4
 102 0002 84B0     		sub	sp, sp, #16
 103              	.LCFI4:
 104              		.cfi_def_cfa_offset 24
 105 0004 00AF     		add	r7, sp, #0
 106              	.LCFI5:
 107              		.cfi_def_cfa_register 7
 108 0006 F860     		str	r0, [r7, #12]
 109 0008 B960     		str	r1, [r7, #8]
 110 000a 7A60     		str	r2, [r7, #4]
 141:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 111              		.loc 1 141 0
 112 000c BB68     		ldr	r3, [r7, #8]
 113 000e 013B     		sub	r3, r3, #1
 114 0010 BB60     		str	r3, [r7, #8]
 142:../Generated_Code/UTIL1.c ****   /* point to the end of the source */
 143:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 115              		.loc 1 143 0
 116 0012 05E0     		b	.L6
 117              	.L8:
 144:../Generated_Code/UTIL1.c ****     dst++;
 118              		.loc 1 144 0
 119 0014 FB68     		ldr	r3, [r7, #12]
 120 0016 0133     		add	r3, r3, #1
 121 0018 FB60     		str	r3, [r7, #12]
 145:../Generated_Code/UTIL1.c ****     dstSize--;
 122              		.loc 1 145 0
 123 001a BB68     		ldr	r3, [r7, #8]
 124 001c 013B     		sub	r3, r3, #1
 125 001e BB60     		str	r3, [r7, #8]
 126              	.L6:
 143:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 127              		.loc 1 143 0 discriminator 1
 128 0020 BB68     		ldr	r3, [r7, #8]
 129 0022 002B     		cmp	r3, #0
 130 0024 11D0     		beq	.L9
 143:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 131              		.loc 1 143 0 is_stmt 0 discriminator 2
 132 0026 FB68     		ldr	r3, [r7, #12]
 133 0028 1B78     		ldrb	r3, [r3]
 134 002a 002B     		cmp	r3, #0
 135 002c F2D1     		bne	.L8
 146:../Generated_Code/UTIL1.c ****   }
 147:../Generated_Code/UTIL1.c ****   /* copy the src in the destination */
 148:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 136              		.loc 1 148 0 is_stmt 1
 137 002e 0CE0     		b	.L9
 138              	.L11:
 149:../Generated_Code/UTIL1.c ****     *dst++ = *src++;
 139              		.loc 1 149 0
 140 0030 7B68     		ldr	r3, [r7, #4]
 141 0032 1A78     		ldrb	r2, [r3]
 142 0034 FB68     		ldr	r3, [r7, #12]
 143 0036 1A70     		strb	r2, [r3]
 144 0038 FB68     		ldr	r3, [r7, #12]
 145 003a 0133     		add	r3, r3, #1
 146 003c FB60     		str	r3, [r7, #12]
 147 003e 7B68     		ldr	r3, [r7, #4]
 148 0040 0133     		add	r3, r3, #1
 149 0042 7B60     		str	r3, [r7, #4]
 150:../Generated_Code/UTIL1.c ****     dstSize--;
 150              		.loc 1 150 0
 151 0044 BB68     		ldr	r3, [r7, #8]
 152 0046 013B     		sub	r3, r3, #1
 153 0048 BB60     		str	r3, [r7, #8]
 154              	.L9:
 148:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 155              		.loc 1 148 0 discriminator 1
 156 004a BB68     		ldr	r3, [r7, #8]
 157 004c 002B     		cmp	r3, #0
 158 004e 03D0     		beq	.L10
 148:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 159              		.loc 1 148 0 is_stmt 0 discriminator 2
 160 0050 7B68     		ldr	r3, [r7, #4]
 161 0052 1B78     		ldrb	r3, [r3]
 162 0054 002B     		cmp	r3, #0
 163 0056 EBD1     		bne	.L11
 164              	.L10:
 151:../Generated_Code/UTIL1.c ****   }
 152:../Generated_Code/UTIL1.c ****   /* terminate the string */
 153:../Generated_Code/UTIL1.c ****   *dst = '\0';
 165              		.loc 1 153 0 is_stmt 1
 166 0058 FB68     		ldr	r3, [r7, #12]
 167 005a 0022     		mov	r2, #0
 168 005c 1A70     		strb	r2, [r3]
 154:../Generated_Code/UTIL1.c **** }
 169              		.loc 1 154 0
 170 005e BD46     		mov	sp, r7
 171 0060 04B0     		add	sp, sp, #16
 172              		@ sp needed for prologue
 173 0062 80BD     		pop	{r7, pc}
 174              		.cfi_endproc
 175              	.LFE1:
 177              		.section	.text.UTIL1_chcat,"ax",%progbits
 178              		.align	2
 179              		.global	UTIL1_chcat
 180              		.code	16
 181              		.thumb_func
 183              	UTIL1_chcat:
 184              	.LFB2:
 155:../Generated_Code/UTIL1.c **** 
 156:../Generated_Code/UTIL1.c **** /*
 157:../Generated_Code/UTIL1.c **** ** ===================================================================
 158:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_chcat (component Utility)
 159:../Generated_Code/UTIL1.c **** **
 160:../Generated_Code/UTIL1.c **** **     Description :
 161:../Generated_Code/UTIL1.c **** **         Adds a single character to a zero byte terminated buffer. It
 162:../Generated_Code/UTIL1.c **** **         cares about buffer overflow.
 163:../Generated_Code/UTIL1.c **** **     Parameters  :
 164:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 165:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 166:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 167:../Generated_Code/UTIL1.c **** **                           bytes).
 168:../Generated_Code/UTIL1.c **** **         ch              - character to append
 169:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 170:../Generated_Code/UTIL1.c **** ** ===================================================================
 171:../Generated_Code/UTIL1.c **** */
 172:../Generated_Code/UTIL1.c **** void UTIL1_chcat(byte *dst, size_t dstSize, byte ch)
 173:../Generated_Code/UTIL1.c **** {
 185              		.loc 1 173 0
 186              		.cfi_startproc
 187 0000 80B5     		push	{r7, lr}
 188              	.LCFI6:
 189              		.cfi_def_cfa_offset 8
 190              		.cfi_offset 7, -8
 191              		.cfi_offset 14, -4
 192 0002 84B0     		sub	sp, sp, #16
 193              	.LCFI7:
 194              		.cfi_def_cfa_offset 24
 195 0004 00AF     		add	r7, sp, #0
 196              	.LCFI8:
 197              		.cfi_def_cfa_register 7
 198 0006 F860     		str	r0, [r7, #12]
 199 0008 B960     		str	r1, [r7, #8]
 200 000a FB1D     		add	r3, r7, #7
 201 000c 1A70     		strb	r2, [r3]
 174:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 202              		.loc 1 174 0
 203 000e BB68     		ldr	r3, [r7, #8]
 204 0010 013B     		sub	r3, r3, #1
 205 0012 BB60     		str	r3, [r7, #8]
 175:../Generated_Code/UTIL1.c ****   /* point to the end of the source */
 176:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 206              		.loc 1 176 0
 207 0014 05E0     		b	.L13
 208              	.L15:
 177:../Generated_Code/UTIL1.c ****     dst++;
 209              		.loc 1 177 0
 210 0016 FB68     		ldr	r3, [r7, #12]
 211 0018 0133     		add	r3, r3, #1
 212 001a FB60     		str	r3, [r7, #12]
 178:../Generated_Code/UTIL1.c ****     dstSize--;
 213              		.loc 1 178 0
 214 001c BB68     		ldr	r3, [r7, #8]
 215 001e 013B     		sub	r3, r3, #1
 216 0020 BB60     		str	r3, [r7, #8]
 217              	.L13:
 176:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 218              		.loc 1 176 0 discriminator 1
 219 0022 BB68     		ldr	r3, [r7, #8]
 220 0024 002B     		cmp	r3, #0
 221 0026 03D0     		beq	.L14
 176:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 222              		.loc 1 176 0 is_stmt 0 discriminator 2
 223 0028 FB68     		ldr	r3, [r7, #12]
 224 002a 1B78     		ldrb	r3, [r3]
 225 002c 002B     		cmp	r3, #0
 226 002e F2D1     		bne	.L15
 227              	.L14:
 179:../Generated_Code/UTIL1.c ****   }
 180:../Generated_Code/UTIL1.c ****   /* copy the ch in the destination */
 181:../Generated_Code/UTIL1.c ****   if (dstSize > 0) {
 228              		.loc 1 181 0 is_stmt 1
 229 0030 BB68     		ldr	r3, [r7, #8]
 230 0032 002B     		cmp	r3, #0
 231 0034 06D0     		beq	.L16
 182:../Generated_Code/UTIL1.c ****     *dst++ = ch;
 232              		.loc 1 182 0
 233 0036 FB68     		ldr	r3, [r7, #12]
 234 0038 FA1D     		add	r2, r7, #7
 235 003a 1278     		ldrb	r2, [r2]
 236 003c 1A70     		strb	r2, [r3]
 237 003e FB68     		ldr	r3, [r7, #12]
 238 0040 0133     		add	r3, r3, #1
 239 0042 FB60     		str	r3, [r7, #12]
 240              	.L16:
 183:../Generated_Code/UTIL1.c ****   }
 184:../Generated_Code/UTIL1.c ****   /* terminate the string */
 185:../Generated_Code/UTIL1.c ****   *dst = '\0';
 241              		.loc 1 185 0
 242 0044 FB68     		ldr	r3, [r7, #12]
 243 0046 0022     		mov	r2, #0
 244 0048 1A70     		strb	r2, [r3]
 186:../Generated_Code/UTIL1.c **** }
 245              		.loc 1 186 0
 246 004a BD46     		mov	sp, r7
 247 004c 04B0     		add	sp, sp, #16
 248              		@ sp needed for prologue
 249 004e 80BD     		pop	{r7, pc}
 250              		.cfi_endproc
 251              	.LFE2:
 253              		.section	.text.UTIL1_Num8uToStr,"ax",%progbits
 254              		.align	2
 255              		.global	UTIL1_Num8uToStr
 256              		.code	16
 257              		.thumb_func
 259              	UTIL1_Num8uToStr:
 260              	.LFB3:
 187:../Generated_Code/UTIL1.c **** 
 188:../Generated_Code/UTIL1.c **** /*
 189:../Generated_Code/UTIL1.c **** ** ===================================================================
 190:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num8uToStr (component Utility)
 191:../Generated_Code/UTIL1.c **** **
 192:../Generated_Code/UTIL1.c **** **     Description :
 193:../Generated_Code/UTIL1.c **** **         Converts an unsigned 8bit value into a string.
 194:../Generated_Code/UTIL1.c **** **     Parameters  :
 195:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 196:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 197:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 198:../Generated_Code/UTIL1.c **** **                           bytes).
 199:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 200:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 201:../Generated_Code/UTIL1.c **** ** ===================================================================
 202:../Generated_Code/UTIL1.c **** */
 203:../Generated_Code/UTIL1.c **** /*!
 204:../Generated_Code/UTIL1.c ****   \brief Converts an 8bit unsigned number into a string.
 205:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 206:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 207:../Generated_Code/UTIL1.c ****   \param[in] val 8bit unsigned number to convert.
 208:../Generated_Code/UTIL1.c ****  */
 209:../Generated_Code/UTIL1.c **** void UTIL1_Num8uToStr(byte *dst, size_t dstSize, byte val)
 210:../Generated_Code/UTIL1.c **** {
 261              		.loc 1 210 0
 262              		.cfi_startproc
 263 0000 80B5     		push	{r7, lr}
 264              	.LCFI9:
 265              		.cfi_def_cfa_offset 8
 266              		.cfi_offset 7, -8
 267              		.cfi_offset 14, -4
 268 0002 84B0     		sub	sp, sp, #16
 269              	.LCFI10:
 270              		.cfi_def_cfa_offset 24
 271 0004 00AF     		add	r7, sp, #0
 272              	.LCFI11:
 273              		.cfi_def_cfa_register 7
 274 0006 F860     		str	r0, [r7, #12]
 275 0008 B960     		str	r1, [r7, #8]
 276 000a FB1D     		add	r3, r7, #7
 277 000c 1A70     		strb	r2, [r3]
 211:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, (uint16_t)val);
 278              		.loc 1 211 0
 279 000e FB1D     		add	r3, r7, #7
 280 0010 1B78     		ldrb	r3, [r3]
 281 0012 9BB2     		uxth	r3, r3
 282 0014 F968     		ldr	r1, [r7, #12]
 283 0016 BA68     		ldr	r2, [r7, #8]
 284 0018 081C     		mov	r0, r1
 285 001a 111C     		mov	r1, r2
 286 001c 1A1C     		mov	r2, r3
 287 001e FFF7FEFF 		bl	UTIL1_Num16uToStr
 212:../Generated_Code/UTIL1.c **** }
 288              		.loc 1 212 0
 289 0022 BD46     		mov	sp, r7
 290 0024 04B0     		add	sp, sp, #16
 291              		@ sp needed for prologue
 292 0026 80BD     		pop	{r7, pc}
 293              		.cfi_endproc
 294              	.LFE3:
 296              		.section	.text.UTIL1_Num8sToStr,"ax",%progbits
 297              		.align	2
 298              		.global	UTIL1_Num8sToStr
 299              		.code	16
 300              		.thumb_func
 302              	UTIL1_Num8sToStr:
 303              	.LFB4:
 213:../Generated_Code/UTIL1.c **** 
 214:../Generated_Code/UTIL1.c **** /*
 215:../Generated_Code/UTIL1.c **** ** ===================================================================
 216:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num8sToStr (component Utility)
 217:../Generated_Code/UTIL1.c **** **
 218:../Generated_Code/UTIL1.c **** **     Description :
 219:../Generated_Code/UTIL1.c **** **         Converts a signed 8bit value into a string.
 220:../Generated_Code/UTIL1.c **** **     Parameters  :
 221:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 222:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 223:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 224:../Generated_Code/UTIL1.c **** **                           bytes).
 225:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 226:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 227:../Generated_Code/UTIL1.c **** ** ===================================================================
 228:../Generated_Code/UTIL1.c **** */
 229:../Generated_Code/UTIL1.c **** /*!
 230:../Generated_Code/UTIL1.c ****   \brief Converts an 8bit signed number into a string.
 231:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 232:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 233:../Generated_Code/UTIL1.c ****   \param[in] val 8bit signed number to convert.
 234:../Generated_Code/UTIL1.c ****  */
 235:../Generated_Code/UTIL1.c **** void UTIL1_Num8sToStr(byte *dst, size_t dstSize, signed char val)
 236:../Generated_Code/UTIL1.c **** {
 304              		.loc 1 236 0
 305              		.cfi_startproc
 306 0000 80B5     		push	{r7, lr}
 307              	.LCFI12:
 308              		.cfi_def_cfa_offset 8
 309              		.cfi_offset 7, -8
 310              		.cfi_offset 14, -4
 311 0002 84B0     		sub	sp, sp, #16
 312              	.LCFI13:
 313              		.cfi_def_cfa_offset 24
 314 0004 00AF     		add	r7, sp, #0
 315              	.LCFI14:
 316              		.cfi_def_cfa_register 7
 317 0006 F860     		str	r0, [r7, #12]
 318 0008 B960     		str	r1, [r7, #8]
 319 000a FB1D     		add	r3, r7, #7
 320 000c 1A70     		strb	r2, [r3]
 237:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, (int16_t)val);
 321              		.loc 1 237 0
 322 000e FB1D     		add	r3, r7, #7
 323 0010 1B78     		ldrb	r3, [r3]
 324 0012 5BB2     		sxtb	r3, r3
 325 0014 9BB2     		uxth	r3, r3
 326 0016 F968     		ldr	r1, [r7, #12]
 327 0018 BA68     		ldr	r2, [r7, #8]
 328 001a 1BB2     		sxth	r3, r3
 329 001c 081C     		mov	r0, r1
 330 001e 111C     		mov	r1, r2
 331 0020 1A1C     		mov	r2, r3
 332 0022 FFF7FEFF 		bl	UTIL1_Num16sToStr
 238:../Generated_Code/UTIL1.c **** }
 333              		.loc 1 238 0
 334 0026 BD46     		mov	sp, r7
 335 0028 04B0     		add	sp, sp, #16
 336              		@ sp needed for prologue
 337 002a 80BD     		pop	{r7, pc}
 338              		.cfi_endproc
 339              	.LFE4:
 341              		.global	__aeabi_uidivmod
 342              		.global	__aeabi_uidiv
 343              		.section	.text.UTIL1_Num16uToStr,"ax",%progbits
 344              		.align	2
 345              		.global	UTIL1_Num16uToStr
 346              		.code	16
 347              		.thumb_func
 349              	UTIL1_Num16uToStr:
 350              	.LFB5:
 239:../Generated_Code/UTIL1.c **** 
 240:../Generated_Code/UTIL1.c **** /*
 241:../Generated_Code/UTIL1.c **** ** ===================================================================
 242:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16uToStr (component Utility)
 243:../Generated_Code/UTIL1.c **** **
 244:../Generated_Code/UTIL1.c **** **     Description :
 245:../Generated_Code/UTIL1.c **** **         Converts a signed 16bit value into a string.
 246:../Generated_Code/UTIL1.c **** **     Parameters  :
 247:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 248:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 249:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 250:../Generated_Code/UTIL1.c **** **                           bytes).
 251:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 252:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 253:../Generated_Code/UTIL1.c **** ** ===================================================================
 254:../Generated_Code/UTIL1.c **** */
 255:../Generated_Code/UTIL1.c **** /*!
 256:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit unsigned number into a string.
 257:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 258:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 259:../Generated_Code/UTIL1.c ****   \param[in] val 16bit unsigned number to convert.
 260:../Generated_Code/UTIL1.c ****  */
 261:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStr(byte *dst, size_t dstSize, word val)
 262:../Generated_Code/UTIL1.c **** {
 351              		.loc 1 262 0
 352              		.cfi_startproc
 353 0000 90B5     		push	{r4, r7, lr}
 354              	.LCFI15:
 355              		.cfi_def_cfa_offset 12
 356              		.cfi_offset 4, -12
 357              		.cfi_offset 7, -8
 358              		.cfi_offset 14, -4
 359 0002 89B0     		sub	sp, sp, #36
 360              	.LCFI16:
 361              		.cfi_def_cfa_offset 48
 362 0004 00AF     		add	r7, sp, #0
 363              	.LCFI17:
 364              		.cfi_def_cfa_register 7
 365 0006 F860     		str	r0, [r7, #12]
 366 0008 B960     		str	r1, [r7, #8]
 367 000a BB1D     		add	r3, r7, #6
 368 000c 1A80     		strh	r2, [r3]
 263:../Generated_Code/UTIL1.c ****   unsigned char *ptr = ((unsigned char *)dst);
 369              		.loc 1 263 0
 370 000e FB68     		ldr	r3, [r7, #12]
 371 0010 BB61     		str	r3, [r7, #24]
 264:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 372              		.loc 1 264 0
 373 0012 3B1C     		mov	r3, r7
 374 0014 1F33     		add	r3, r3, #31
 375 0016 0022     		mov	r2, #0
 376 0018 1A70     		strb	r2, [r3]
 265:../Generated_Code/UTIL1.c ****   unsigned char tmp;
 266:../Generated_Code/UTIL1.c **** 
 267:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 377              		.loc 1 267 0
 378 001a BB68     		ldr	r3, [r7, #8]
 379 001c 013B     		sub	r3, r3, #1
 380 001e BB60     		str	r3, [r7, #8]
 268:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 381              		.loc 1 268 0
 382 0020 BB1D     		add	r3, r7, #6
 383 0022 1B88     		ldrh	r3, [r3]
 384 0024 002B     		cmp	r3, #0
 385 0026 38D1     		bne	.L21
 386              		.loc 1 268 0 is_stmt 0 discriminator 1
 387 0028 BB68     		ldr	r3, [r7, #8]
 388 002a 002B     		cmp	r3, #0
 389 002c 35D0     		beq	.L21
 269:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 390              		.loc 1 269 0 is_stmt 1
 391 002e 3B1C     		mov	r3, r7
 392 0030 1F33     		add	r3, r3, #31
 393 0032 1B78     		ldrb	r3, [r3]
 394 0034 BA69     		ldr	r2, [r7, #24]
 395 0036 D318     		add	r3, r2, r3
 396 0038 3022     		mov	r2, #48
 397 003a 1A70     		strb	r2, [r3]
 398 003c 3B1C     		mov	r3, r7
 399 003e 1F33     		add	r3, r3, #31
 400 0040 3A1C     		mov	r2, r7
 401 0042 1F32     		add	r2, r2, #31
 402 0044 1278     		ldrb	r2, [r2]
 403 0046 0132     		add	r2, r2, #1
 404 0048 1A70     		strb	r2, [r3]
 270:../Generated_Code/UTIL1.c ****     dstSize--;
 405              		.loc 1 270 0
 406 004a BB68     		ldr	r3, [r7, #8]
 407 004c 013B     		sub	r3, r3, #1
 408 004e BB60     		str	r3, [r7, #8]
 271:../Generated_Code/UTIL1.c ****   }
 272:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 409              		.loc 1 272 0
 410 0050 23E0     		b	.L21
 411              	.L23:
 273:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 412              		.loc 1 273 0
 413 0052 3B1C     		mov	r3, r7
 414 0054 1F33     		add	r3, r3, #31
 415 0056 1B78     		ldrb	r3, [r3]
 416 0058 BA69     		ldr	r2, [r7, #24]
 417 005a D418     		add	r4, r2, r3
 418 005c BB1D     		add	r3, r7, #6
 419 005e 1B88     		ldrh	r3, [r3]
 420 0060 181C     		mov	r0, r3
 421 0062 0A21     		mov	r1, #10
 422 0064 FFF7FEFF 		bl	__aeabi_uidivmod
 423 0068 0B1C     		mov	r3, r1
 424 006a 9BB2     		uxth	r3, r3
 425 006c DBB2     		uxtb	r3, r3
 426 006e 3033     		add	r3, r3, #48
 427 0070 DBB2     		uxtb	r3, r3
 428 0072 2370     		strb	r3, [r4]
 429 0074 3B1C     		mov	r3, r7
 430 0076 1F33     		add	r3, r3, #31
 431 0078 3A1C     		mov	r2, r7
 432 007a 1F32     		add	r2, r2, #31
 433 007c 1278     		ldrb	r2, [r2]
 434 007e 0132     		add	r2, r2, #1
 435 0080 1A70     		strb	r2, [r3]
 274:../Generated_Code/UTIL1.c ****     dstSize--;
 436              		.loc 1 274 0
 437 0082 BB68     		ldr	r3, [r7, #8]
 438 0084 013B     		sub	r3, r3, #1
 439 0086 BB60     		str	r3, [r7, #8]
 275:../Generated_Code/UTIL1.c ****     val /= 10;
 440              		.loc 1 275 0
 441 0088 BC1D     		add	r4, r7, #6
 442 008a BB1D     		add	r3, r7, #6
 443 008c 1B88     		ldrh	r3, [r3]
 444 008e 181C     		mov	r0, r3
 445 0090 0A21     		mov	r1, #10
 446 0092 FFF7FEFF 		bl	__aeabi_uidiv
 447 0096 031C     		mov	r3, r0
 448 0098 2380     		strh	r3, [r4]
 449              	.L21:
 272:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 450              		.loc 1 272 0 discriminator 1
 451 009a BB1D     		add	r3, r7, #6
 452 009c 1B88     		ldrh	r3, [r3]
 453 009e 002B     		cmp	r3, #0
 454 00a0 02D0     		beq	.L22
 272:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 455              		.loc 1 272 0 is_stmt 0 discriminator 2
 456 00a2 BB68     		ldr	r3, [r7, #8]
 457 00a4 002B     		cmp	r3, #0
 458 00a6 D4D1     		bne	.L23
 459              	.L22:
 276:../Generated_Code/UTIL1.c ****   }
 277:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 460              		.loc 1 277 0 is_stmt 1
 461 00a8 3B1C     		mov	r3, r7
 462 00aa 1E33     		add	r3, r3, #30
 463 00ac 0022     		mov	r2, #0
 464 00ae 1A70     		strb	r2, [r3]
 465 00b0 2EE0     		b	.L24
 466              	.L25:
 278:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 467              		.loc 1 278 0 discriminator 2
 468 00b2 3B1C     		mov	r3, r7
 469 00b4 1E33     		add	r3, r3, #30
 470 00b6 1B78     		ldrb	r3, [r3]
 471 00b8 BA69     		ldr	r2, [r7, #24]
 472 00ba D218     		add	r2, r2, r3
 473 00bc 3B1C     		mov	r3, r7
 474 00be 1733     		add	r3, r3, #23
 475 00c0 1278     		ldrb	r2, [r2]
 476 00c2 1A70     		strb	r2, [r3]
 279:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 477              		.loc 1 279 0 discriminator 2
 478 00c4 3B1C     		mov	r3, r7
 479 00c6 1E33     		add	r3, r3, #30
 480 00c8 1B78     		ldrb	r3, [r3]
 481 00ca BA69     		ldr	r2, [r7, #24]
 482 00cc D318     		add	r3, r2, r3
 483 00ce 3A1C     		mov	r2, r7
 484 00d0 1F32     		add	r2, r2, #31
 485 00d2 1178     		ldrb	r1, [r2]
 486 00d4 3A1C     		mov	r2, r7
 487 00d6 1E32     		add	r2, r2, #30
 488 00d8 1278     		ldrb	r2, [r2]
 489 00da 8A1A     		sub	r2, r1, r2
 490 00dc 013A     		sub	r2, r2, #1
 491 00de B969     		ldr	r1, [r7, #24]
 492 00e0 8A18     		add	r2, r1, r2
 493 00e2 1278     		ldrb	r2, [r2]
 494 00e4 1A70     		strb	r2, [r3]
 280:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 495              		.loc 1 280 0 discriminator 2
 496 00e6 3B1C     		mov	r3, r7
 497 00e8 1F33     		add	r3, r3, #31
 498 00ea 1A78     		ldrb	r2, [r3]
 499 00ec 3B1C     		mov	r3, r7
 500 00ee 1E33     		add	r3, r3, #30
 501 00f0 1B78     		ldrb	r3, [r3]
 502 00f2 D31A     		sub	r3, r2, r3
 503 00f4 013B     		sub	r3, r3, #1
 504 00f6 BA69     		ldr	r2, [r7, #24]
 505 00f8 D318     		add	r3, r2, r3
 506 00fa 3A1C     		mov	r2, r7
 507 00fc 1732     		add	r2, r2, #23
 508 00fe 1278     		ldrb	r2, [r2]
 509 0100 1A70     		strb	r2, [r3]
 277:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 510              		.loc 1 277 0 discriminator 2
 511 0102 3B1C     		mov	r3, r7
 512 0104 1E33     		add	r3, r3, #30
 513 0106 3A1C     		mov	r2, r7
 514 0108 1E32     		add	r2, r2, #30
 515 010a 1278     		ldrb	r2, [r2]
 516 010c 0132     		add	r2, r2, #1
 517 010e 1A70     		strb	r2, [r3]
 518              	.L24:
 277:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 519              		.loc 1 277 0 is_stmt 0 discriminator 1
 520 0110 3B1C     		mov	r3, r7
 521 0112 1F33     		add	r3, r3, #31
 522 0114 1B78     		ldrb	r3, [r3]
 523 0116 5B08     		lsr	r3, r3, #1
 524 0118 DBB2     		uxtb	r3, r3
 525 011a 3A1C     		mov	r2, r7
 526 011c 1E32     		add	r2, r2, #30
 527 011e 1278     		ldrb	r2, [r2]
 528 0120 9A42     		cmp	r2, r3
 529 0122 C6D3     		bcc	.L25
 281:../Generated_Code/UTIL1.c ****   }
 282:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 530              		.loc 1 282 0 is_stmt 1
 531 0124 3B1C     		mov	r3, r7
 532 0126 1F33     		add	r3, r3, #31
 533 0128 1B78     		ldrb	r3, [r3]
 534 012a BA69     		ldr	r2, [r7, #24]
 535 012c D318     		add	r3, r2, r3
 536 012e 0022     		mov	r2, #0
 537 0130 1A70     		strb	r2, [r3]
 283:../Generated_Code/UTIL1.c **** }
 538              		.loc 1 283 0
 539 0132 BD46     		mov	sp, r7
 540 0134 09B0     		add	sp, sp, #36
 541              		@ sp needed for prologue
 542 0136 90BD     		pop	{r4, r7, pc}
 543              		.cfi_endproc
 544              	.LFE5:
 546              		.global	__aeabi_idivmod
 547              		.global	__aeabi_idiv
 548              		.section	.text.UTIL1_Num16sToStr,"ax",%progbits
 549              		.align	2
 550              		.global	UTIL1_Num16sToStr
 551              		.code	16
 552              		.thumb_func
 554              	UTIL1_Num16sToStr:
 555              	.LFB6:
 284:../Generated_Code/UTIL1.c **** 
 285:../Generated_Code/UTIL1.c **** /*
 286:../Generated_Code/UTIL1.c **** ** ===================================================================
 287:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16sToStr (component Utility)
 288:../Generated_Code/UTIL1.c **** **
 289:../Generated_Code/UTIL1.c **** **     Description :
 290:../Generated_Code/UTIL1.c **** **         Converts a signed 16bit value into a string.
 291:../Generated_Code/UTIL1.c **** **     Parameters  :
 292:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 293:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 294:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 295:../Generated_Code/UTIL1.c **** **                           bytes).
 296:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 297:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 298:../Generated_Code/UTIL1.c **** ** ===================================================================
 299:../Generated_Code/UTIL1.c **** */
 300:../Generated_Code/UTIL1.c **** /*!
 301:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit signed number into a string.
 302:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 303:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 304:../Generated_Code/UTIL1.c ****   \param[in] val 16bit signed number to convert.
 305:../Generated_Code/UTIL1.c ****  */
 306:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStr(byte *dst, size_t dstSize, int16_t val)
 307:../Generated_Code/UTIL1.c **** {
 556              		.loc 1 307 0
 557              		.cfi_startproc
 558 0000 90B5     		push	{r4, r7, lr}
 559              	.LCFI18:
 560              		.cfi_def_cfa_offset 12
 561              		.cfi_offset 4, -12
 562              		.cfi_offset 7, -8
 563              		.cfi_offset 14, -4
 564 0002 89B0     		sub	sp, sp, #36
 565              	.LCFI19:
 566              		.cfi_def_cfa_offset 48
 567 0004 00AF     		add	r7, sp, #0
 568              	.LCFI20:
 569              		.cfi_def_cfa_register 7
 570 0006 F860     		str	r0, [r7, #12]
 571 0008 B960     		str	r1, [r7, #8]
 572 000a BB1D     		add	r3, r7, #6
 573 000c 1A80     		strh	r2, [r3]
 308:../Generated_Code/UTIL1.c ****   unsigned char *ptr =  ((unsigned char *)dst);
 574              		.loc 1 308 0
 575 000e FB68     		ldr	r3, [r7, #12]
 576 0010 BB61     		str	r3, [r7, #24]
 309:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 577              		.loc 1 309 0
 578 0012 3B1C     		mov	r3, r7
 579 0014 1F33     		add	r3, r3, #31
 580 0016 0022     		mov	r2, #0
 581 0018 1A70     		strb	r2, [r3]
 310:../Generated_Code/UTIL1.c ****   unsigned char tmp;
 311:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 582              		.loc 1 311 0
 583 001a 3B1C     		mov	r3, r7
 584 001c 1733     		add	r3, r3, #23
 585 001e BA1D     		add	r2, r7, #6
 586 0020 1288     		ldrh	r2, [r2]
 587 0022 D20B     		lsr	r2, r2, #15
 588 0024 1A70     		strb	r2, [r3]
 312:../Generated_Code/UTIL1.c **** 
 313:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 589              		.loc 1 313 0
 590 0026 BB68     		ldr	r3, [r7, #8]
 591 0028 013B     		sub	r3, r3, #1
 592 002a BB60     		str	r3, [r7, #8]
 314:../Generated_Code/UTIL1.c ****   if (sign){
 593              		.loc 1 314 0
 594 002c 3B1C     		mov	r3, r7
 595 002e 1733     		add	r3, r3, #23
 596 0030 1B78     		ldrb	r3, [r3]
 597 0032 002B     		cmp	r3, #0
 598 0034 05D0     		beq	.L27
 315:../Generated_Code/UTIL1.c ****     val *= -1;
 599              		.loc 1 315 0
 600 0036 BB1D     		add	r3, r7, #6
 601 0038 1B88     		ldrh	r3, [r3]
 602 003a 5B42     		neg	r3, r3
 603 003c 9AB2     		uxth	r2, r3
 604 003e BB1D     		add	r3, r7, #6
 605 0040 1A80     		strh	r2, [r3]
 606              	.L27:
 316:../Generated_Code/UTIL1.c ****   }
 317:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 607              		.loc 1 317 0
 608 0042 BB1D     		add	r3, r7, #6
 609 0044 0022     		mov	r2, #0
 610 0046 9B5E     		ldrsh	r3, [r3, r2]
 611 0048 002B     		cmp	r3, #0
 612 004a 3AD1     		bne	.L29
 613              		.loc 1 317 0 is_stmt 0 discriminator 1
 614 004c BB68     		ldr	r3, [r7, #8]
 615 004e 002B     		cmp	r3, #0
 616 0050 37D0     		beq	.L29
 318:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 617              		.loc 1 318 0 is_stmt 1
 618 0052 3B1C     		mov	r3, r7
 619 0054 1F33     		add	r3, r3, #31
 620 0056 1B78     		ldrb	r3, [r3]
 621 0058 BA69     		ldr	r2, [r7, #24]
 622 005a D318     		add	r3, r2, r3
 623 005c 3022     		mov	r2, #48
 624 005e 1A70     		strb	r2, [r3]
 625 0060 3B1C     		mov	r3, r7
 626 0062 1F33     		add	r3, r3, #31
 627 0064 3A1C     		mov	r2, r7
 628 0066 1F32     		add	r2, r2, #31
 629 0068 1278     		ldrb	r2, [r2]
 630 006a 0132     		add	r2, r2, #1
 631 006c 1A70     		strb	r2, [r3]
 319:../Generated_Code/UTIL1.c ****     dstSize--;
 632              		.loc 1 319 0
 633 006e BB68     		ldr	r3, [r7, #8]
 634 0070 013B     		sub	r3, r3, #1
 635 0072 BB60     		str	r3, [r7, #8]
 320:../Generated_Code/UTIL1.c ****   }
 321:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 636              		.loc 1 321 0
 637 0074 25E0     		b	.L29
 638              	.L31:
 322:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 639              		.loc 1 322 0
 640 0076 3B1C     		mov	r3, r7
 641 0078 1F33     		add	r3, r3, #31
 642 007a 1B78     		ldrb	r3, [r3]
 643 007c BA69     		ldr	r2, [r7, #24]
 644 007e D418     		add	r4, r2, r3
 645 0080 BB1D     		add	r3, r7, #6
 646 0082 0022     		mov	r2, #0
 647 0084 9B5E     		ldrsh	r3, [r3, r2]
 648 0086 181C     		mov	r0, r3
 649 0088 0A21     		mov	r1, #10
 650 008a FFF7FEFF 		bl	__aeabi_idivmod
 651 008e 0B1C     		mov	r3, r1
 652 0090 9BB2     		uxth	r3, r3
 653 0092 DBB2     		uxtb	r3, r3
 654 0094 3033     		add	r3, r3, #48
 655 0096 DBB2     		uxtb	r3, r3
 656 0098 2370     		strb	r3, [r4]
 657 009a 3B1C     		mov	r3, r7
 658 009c 1F33     		add	r3, r3, #31
 659 009e 3A1C     		mov	r2, r7
 660 00a0 1F32     		add	r2, r2, #31
 661 00a2 1278     		ldrb	r2, [r2]
 662 00a4 0132     		add	r2, r2, #1
 663 00a6 1A70     		strb	r2, [r3]
 323:../Generated_Code/UTIL1.c ****     dstSize--;
 664              		.loc 1 323 0
 665 00a8 BB68     		ldr	r3, [r7, #8]
 666 00aa 013B     		sub	r3, r3, #1
 667 00ac BB60     		str	r3, [r7, #8]
 324:../Generated_Code/UTIL1.c ****     val /= 10;
 668              		.loc 1 324 0
 669 00ae BC1D     		add	r4, r7, #6
 670 00b0 BB1D     		add	r3, r7, #6
 671 00b2 0022     		mov	r2, #0
 672 00b4 9B5E     		ldrsh	r3, [r3, r2]
 673 00b6 181C     		mov	r0, r3
 674 00b8 0A21     		mov	r1, #10
 675 00ba FFF7FEFF 		bl	__aeabi_idiv
 676 00be 031C     		mov	r3, r0
 677 00c0 2380     		strh	r3, [r4]
 678              	.L29:
 321:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 679              		.loc 1 321 0 discriminator 1
 680 00c2 BB1D     		add	r3, r7, #6
 681 00c4 0022     		mov	r2, #0
 682 00c6 9B5E     		ldrsh	r3, [r3, r2]
 683 00c8 002B     		cmp	r3, #0
 684 00ca 02DD     		ble	.L30
 321:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 685              		.loc 1 321 0 is_stmt 0 discriminator 2
 686 00cc BB68     		ldr	r3, [r7, #8]
 687 00ce 002B     		cmp	r3, #0
 688 00d0 D1D1     		bne	.L31
 689              	.L30:
 325:../Generated_Code/UTIL1.c ****   }
 326:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 690              		.loc 1 326 0 is_stmt 1
 691 00d2 3B1C     		mov	r3, r7
 692 00d4 1733     		add	r3, r3, #23
 693 00d6 1B78     		ldrb	r3, [r3]
 694 00d8 002B     		cmp	r3, #0
 695 00da 13D0     		beq	.L32
 696              		.loc 1 326 0 is_stmt 0 discriminator 1
 697 00dc BB68     		ldr	r3, [r7, #8]
 698 00de 002B     		cmp	r3, #0
 699 00e0 10D0     		beq	.L32
 327:../Generated_Code/UTIL1.c ****     ptr[i++] = '-';
 700              		.loc 1 327 0 is_stmt 1
 701 00e2 3B1C     		mov	r3, r7
 702 00e4 1F33     		add	r3, r3, #31
 703 00e6 1B78     		ldrb	r3, [r3]
 704 00e8 BA69     		ldr	r2, [r7, #24]
 705 00ea D318     		add	r3, r2, r3
 706 00ec 2D22     		mov	r2, #45
 707 00ee 1A70     		strb	r2, [r3]
 708 00f0 3B1C     		mov	r3, r7
 709 00f2 1F33     		add	r3, r3, #31
 710 00f4 3A1C     		mov	r2, r7
 711 00f6 1F32     		add	r2, r2, #31
 712 00f8 1278     		ldrb	r2, [r2]
 713 00fa 0132     		add	r2, r2, #1
 714 00fc 1A70     		strb	r2, [r3]
 328:../Generated_Code/UTIL1.c ****     dstSize--;
 715              		.loc 1 328 0
 716 00fe BB68     		ldr	r3, [r7, #8]
 717 0100 013B     		sub	r3, r3, #1
 718 0102 BB60     		str	r3, [r7, #8]
 719              	.L32:
 329:../Generated_Code/UTIL1.c ****   }
 330:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 720              		.loc 1 330 0
 721 0104 3B1C     		mov	r3, r7
 722 0106 1E33     		add	r3, r3, #30
 723 0108 0022     		mov	r2, #0
 724 010a 1A70     		strb	r2, [r3]
 725 010c 2EE0     		b	.L33
 726              	.L34:
 331:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 727              		.loc 1 331 0 discriminator 2
 728 010e 3B1C     		mov	r3, r7
 729 0110 1E33     		add	r3, r3, #30
 730 0112 1B78     		ldrb	r3, [r3]
 731 0114 BA69     		ldr	r2, [r7, #24]
 732 0116 D218     		add	r2, r2, r3
 733 0118 3B1C     		mov	r3, r7
 734 011a 1633     		add	r3, r3, #22
 735 011c 1278     		ldrb	r2, [r2]
 736 011e 1A70     		strb	r2, [r3]
 332:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 737              		.loc 1 332 0 discriminator 2
 738 0120 3B1C     		mov	r3, r7
 739 0122 1E33     		add	r3, r3, #30
 740 0124 1B78     		ldrb	r3, [r3]
 741 0126 BA69     		ldr	r2, [r7, #24]
 742 0128 D318     		add	r3, r2, r3
 743 012a 3A1C     		mov	r2, r7
 744 012c 1F32     		add	r2, r2, #31
 745 012e 1178     		ldrb	r1, [r2]
 746 0130 3A1C     		mov	r2, r7
 747 0132 1E32     		add	r2, r2, #30
 748 0134 1278     		ldrb	r2, [r2]
 749 0136 8A1A     		sub	r2, r1, r2
 750 0138 013A     		sub	r2, r2, #1
 751 013a B969     		ldr	r1, [r7, #24]
 752 013c 8A18     		add	r2, r1, r2
 753 013e 1278     		ldrb	r2, [r2]
 754 0140 1A70     		strb	r2, [r3]
 333:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 755              		.loc 1 333 0 discriminator 2
 756 0142 3B1C     		mov	r3, r7
 757 0144 1F33     		add	r3, r3, #31
 758 0146 1A78     		ldrb	r2, [r3]
 759 0148 3B1C     		mov	r3, r7
 760 014a 1E33     		add	r3, r3, #30
 761 014c 1B78     		ldrb	r3, [r3]
 762 014e D31A     		sub	r3, r2, r3
 763 0150 013B     		sub	r3, r3, #1
 764 0152 BA69     		ldr	r2, [r7, #24]
 765 0154 D318     		add	r3, r2, r3
 766 0156 3A1C     		mov	r2, r7
 767 0158 1632     		add	r2, r2, #22
 768 015a 1278     		ldrb	r2, [r2]
 769 015c 1A70     		strb	r2, [r3]
 330:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 770              		.loc 1 330 0 discriminator 2
 771 015e 3B1C     		mov	r3, r7
 772 0160 1E33     		add	r3, r3, #30
 773 0162 3A1C     		mov	r2, r7
 774 0164 1E32     		add	r2, r2, #30
 775 0166 1278     		ldrb	r2, [r2]
 776 0168 0132     		add	r2, r2, #1
 777 016a 1A70     		strb	r2, [r3]
 778              	.L33:
 330:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 779              		.loc 1 330 0 is_stmt 0 discriminator 1
 780 016c 3B1C     		mov	r3, r7
 781 016e 1F33     		add	r3, r3, #31
 782 0170 1B78     		ldrb	r3, [r3]
 783 0172 5B08     		lsr	r3, r3, #1
 784 0174 DBB2     		uxtb	r3, r3
 785 0176 3A1C     		mov	r2, r7
 786 0178 1E32     		add	r2, r2, #30
 787 017a 1278     		ldrb	r2, [r2]
 788 017c 9A42     		cmp	r2, r3
 789 017e C6D3     		bcc	.L34
 334:../Generated_Code/UTIL1.c ****   }
 335:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 790              		.loc 1 335 0 is_stmt 1
 791 0180 3B1C     		mov	r3, r7
 792 0182 1F33     		add	r3, r3, #31
 793 0184 1B78     		ldrb	r3, [r3]
 794 0186 BA69     		ldr	r2, [r7, #24]
 795 0188 D318     		add	r3, r2, r3
 796 018a 0022     		mov	r2, #0
 797 018c 1A70     		strb	r2, [r3]
 336:../Generated_Code/UTIL1.c **** }
 798              		.loc 1 336 0
 799 018e BD46     		mov	sp, r7
 800 0190 09B0     		add	sp, sp, #36
 801              		@ sp needed for prologue
 802 0192 90BD     		pop	{r4, r7, pc}
 803              		.cfi_endproc
 804              	.LFE6:
 806              		.section	.text.ShiftRightAndFill,"ax",%progbits
 807              		.align	2
 808              		.code	16
 809              		.thumb_func
 811              	ShiftRightAndFill:
 812              	.LFB7:
 337:../Generated_Code/UTIL1.c **** 
 338:../Generated_Code/UTIL1.c **** /*
 339:../Generated_Code/UTIL1.c **** ** ===================================================================
 340:../Generated_Code/UTIL1.c **** **     Method      :  ShiftRightAndFill (component Utility)
 341:../Generated_Code/UTIL1.c **** **
 342:../Generated_Code/UTIL1.c **** **     Description :
 343:../Generated_Code/UTIL1.c **** **         Moves the content of a string to the right and fills the space 
 344:../Generated_Code/UTIL1.c **** **         on the left side with a pattern
 345:../Generated_Code/UTIL1.c **** **         This method is internal. It is used by Processor Expert only.
 346:../Generated_Code/UTIL1.c **** ** ===================================================================
 347:../Generated_Code/UTIL1.c **** */
 348:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
 349:../Generated_Code/UTIL1.c **** {
 813              		.loc 1 349 0
 814              		.cfi_startproc
 815 0000 80B5     		push	{r7, lr}
 816              	.LCFI21:
 817              		.cfi_def_cfa_offset 8
 818              		.cfi_offset 7, -8
 819              		.cfi_offset 14, -4
 820 0002 84B0     		sub	sp, sp, #16
 821              	.LCFI22:
 822              		.cfi_def_cfa_offset 24
 823 0004 00AF     		add	r7, sp, #0
 824              	.LCFI23:
 825              		.cfi_def_cfa_register 7
 826 0006 7860     		str	r0, [r7, #4]
 827 0008 FB1C     		add	r3, r7, #3
 828 000a 1970     		strb	r1, [r3]
 829 000c BB1C     		add	r3, r7, #2
 830 000e 1A70     		strb	r2, [r3]
 350:../Generated_Code/UTIL1.c ****   signed char i, j;
 351:../Generated_Code/UTIL1.c **** 
 352:../Generated_Code/UTIL1.c ****   j = 0;
 831              		.loc 1 352 0
 832 0010 3B1C     		mov	r3, r7
 833 0012 0E33     		add	r3, r3, #14
 834 0014 0022     		mov	r2, #0
 835 0016 1A70     		strb	r2, [r3]
 353:../Generated_Code/UTIL1.c ****   while(dst[j] != '\0') {
 836              		.loc 1 353 0
 837 0018 06E0     		b	.L36
 838              	.L37:
 354:../Generated_Code/UTIL1.c ****     j++;
 839              		.loc 1 354 0
 840 001a 3B1C     		mov	r3, r7
 841 001c 0E33     		add	r3, r3, #14
 842 001e 3A1C     		mov	r2, r7
 843 0020 0E32     		add	r2, r2, #14
 844 0022 1278     		ldrb	r2, [r2]
 845 0024 0132     		add	r2, r2, #1
 846 0026 1A70     		strb	r2, [r3]
 847              	.L36:
 353:../Generated_Code/UTIL1.c ****   while(dst[j] != '\0') {
 848              		.loc 1 353 0 discriminator 1
 849 0028 3B1C     		mov	r3, r7
 850 002a 0E33     		add	r3, r3, #14
 851 002c 1B78     		ldrb	r3, [r3]
 852 002e 5BB2     		sxtb	r3, r3
 853 0030 7A68     		ldr	r2, [r7, #4]
 854 0032 D318     		add	r3, r2, r3
 855 0034 1B78     		ldrb	r3, [r3]
 856 0036 002B     		cmp	r3, #0
 857 0038 EFD1     		bne	.L37
 355:../Generated_Code/UTIL1.c ****   }
 356:../Generated_Code/UTIL1.c ****   i = (signed char)nofFill;
 858              		.loc 1 356 0
 859 003a 3B1C     		mov	r3, r7
 860 003c 0F33     		add	r3, r3, #15
 861 003e BA1C     		add	r2, r7, #2
 862 0040 1278     		ldrb	r2, [r2]
 863 0042 1A70     		strb	r2, [r3]
 357:../Generated_Code/UTIL1.c ****   if (i==j) {
 864              		.loc 1 357 0
 865 0044 3A1C     		mov	r2, r7
 866 0046 0F32     		add	r2, r2, #15
 867 0048 3B1C     		mov	r3, r7
 868 004a 0E33     		add	r3, r3, #14
 869 004c 1278     		ldrb	r2, [r2]
 870 004e 52B2     		sxtb	r2, r2
 871 0050 1B78     		ldrb	r3, [r3]
 872 0052 5BB2     		sxtb	r3, r3
 873 0054 9A42     		cmp	r2, r3
 874 0056 41D0     		beq	.L35
 358:../Generated_Code/UTIL1.c ****     /* nothing to do, we are done */
 359:../Generated_Code/UTIL1.c ****   } else if (i>j) {
 875              		.loc 1 359 0
 876 0058 3A1C     		mov	r2, r7
 877 005a 0F32     		add	r2, r2, #15
 878 005c 3B1C     		mov	r3, r7
 879 005e 0E33     		add	r3, r3, #14
 880 0060 1278     		ldrb	r2, [r2]
 881 0062 52B2     		sxtb	r2, r2
 882 0064 1B78     		ldrb	r3, [r3]
 883 0066 5BB2     		sxtb	r3, r3
 884 0068 9A42     		cmp	r2, r3
 885 006a 37DD     		ble	.L35
 360:../Generated_Code/UTIL1.c ****     while (j>=0) {
 886              		.loc 1 360 0
 887 006c 1BE0     		b	.L39
 888              	.L40:
 361:../Generated_Code/UTIL1.c ****       dst[i] = dst[j];
 889              		.loc 1 361 0
 890 006e 3B1C     		mov	r3, r7
 891 0070 0F33     		add	r3, r3, #15
 892 0072 1B78     		ldrb	r3, [r3]
 893 0074 5BB2     		sxtb	r3, r3
 894 0076 7A68     		ldr	r2, [r7, #4]
 895 0078 D318     		add	r3, r2, r3
 896 007a 3A1C     		mov	r2, r7
 897 007c 0E32     		add	r2, r2, #14
 898 007e 1278     		ldrb	r2, [r2]
 899 0080 52B2     		sxtb	r2, r2
 900 0082 7968     		ldr	r1, [r7, #4]
 901 0084 8A18     		add	r2, r1, r2
 902 0086 1278     		ldrb	r2, [r2]
 903 0088 1A70     		strb	r2, [r3]
 362:../Generated_Code/UTIL1.c ****       i--; j--;
 904              		.loc 1 362 0
 905 008a 3B1C     		mov	r3, r7
 906 008c 0F33     		add	r3, r3, #15
 907 008e 3A1C     		mov	r2, r7
 908 0090 0F32     		add	r2, r2, #15
 909 0092 1278     		ldrb	r2, [r2]
 910 0094 013A     		sub	r2, r2, #1
 911 0096 1A70     		strb	r2, [r3]
 912 0098 3B1C     		mov	r3, r7
 913 009a 0E33     		add	r3, r3, #14
 914 009c 3A1C     		mov	r2, r7
 915 009e 0E32     		add	r2, r2, #14
 916 00a0 1278     		ldrb	r2, [r2]
 917 00a2 013A     		sub	r2, r2, #1
 918 00a4 1A70     		strb	r2, [r3]
 919              	.L39:
 360:../Generated_Code/UTIL1.c ****     while (j>=0) {
 920              		.loc 1 360 0 discriminator 1
 921 00a6 3B1C     		mov	r3, r7
 922 00a8 0E33     		add	r3, r3, #14
 923 00aa 1B78     		ldrb	r3, [r3]
 924 00ac 7F2B     		cmp	r3, #127
 925 00ae DED9     		bls	.L40
 363:../Generated_Code/UTIL1.c ****     }
 364:../Generated_Code/UTIL1.c ****     while(i>=0) {
 926              		.loc 1 364 0
 927 00b0 0FE0     		b	.L41
 928              	.L42:
 365:../Generated_Code/UTIL1.c ****       dst[i] = fill;
 929              		.loc 1 365 0
 930 00b2 3B1C     		mov	r3, r7
 931 00b4 0F33     		add	r3, r3, #15
 932 00b6 1B78     		ldrb	r3, [r3]
 933 00b8 5BB2     		sxtb	r3, r3
 934 00ba 7A68     		ldr	r2, [r7, #4]
 935 00bc D318     		add	r3, r2, r3
 936 00be FA1C     		add	r2, r7, #3
 937 00c0 1278     		ldrb	r2, [r2]
 938 00c2 1A70     		strb	r2, [r3]
 366:../Generated_Code/UTIL1.c ****       i--;
 939              		.loc 1 366 0
 940 00c4 3B1C     		mov	r3, r7
 941 00c6 0F33     		add	r3, r3, #15
 942 00c8 3A1C     		mov	r2, r7
 943 00ca 0F32     		add	r2, r2, #15
 944 00cc 1278     		ldrb	r2, [r2]
 945 00ce 013A     		sub	r2, r2, #1
 946 00d0 1A70     		strb	r2, [r3]
 947              	.L41:
 364:../Generated_Code/UTIL1.c ****     while(i>=0) {
 948              		.loc 1 364 0 discriminator 1
 949 00d2 3B1C     		mov	r3, r7
 950 00d4 0F33     		add	r3, r3, #15
 951 00d6 1B78     		ldrb	r3, [r3]
 952 00d8 7F2B     		cmp	r3, #127
 953 00da EAD9     		bls	.L42
 954              	.L35:
 367:../Generated_Code/UTIL1.c ****     }
 368:../Generated_Code/UTIL1.c ****   } else {
 369:../Generated_Code/UTIL1.c ****     /* hmmm, not enough space, return what we have, do nothing */
 370:../Generated_Code/UTIL1.c ****   }
 371:../Generated_Code/UTIL1.c **** }
 955              		.loc 1 371 0
 956 00dc BD46     		mov	sp, r7
 957 00de 04B0     		add	sp, sp, #16
 958              		@ sp needed for prologue
 959 00e0 80BD     		pop	{r7, pc}
 960              		.cfi_endproc
 961              	.LFE7:
 963 00e2 C046     		.section	.text.UTIL1_Num16sToStrFormatted,"ax",%progbits
 964              		.align	2
 965              		.global	UTIL1_Num16sToStrFormatted
 966              		.code	16
 967              		.thumb_func
 969              	UTIL1_Num16sToStrFormatted:
 970              	.LFB8:
 372:../Generated_Code/UTIL1.c **** 
 373:../Generated_Code/UTIL1.c **** /*
 374:../Generated_Code/UTIL1.c **** ** ===================================================================
 375:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16sToStrFormatted (component Utility)
 376:../Generated_Code/UTIL1.c **** **
 377:../Generated_Code/UTIL1.c **** **     Description :
 378:../Generated_Code/UTIL1.c **** **         Converts a 16bit signed value to string.
 379:../Generated_Code/UTIL1.c **** **     Parameters  :
 380:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 381:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 382:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 383:../Generated_Code/UTIL1.c **** **                           bytes).
 384:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 385:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 386:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 387:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 388:../Generated_Code/UTIL1.c **** ** ===================================================================
 389:../Generated_Code/UTIL1.c **** */
 390:../Generated_Code/UTIL1.c **** /*!
 391:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit signed number to a string, in a formatted way (like printf with "%0d").
 392:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 393:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 394:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 395:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 396:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 397:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 398:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 399:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 400:../Generated_Code/UTIL1.c **** */
 401:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStrFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill)
 402:../Generated_Code/UTIL1.c **** {
 971              		.loc 1 402 0
 972              		.cfi_startproc
 973 0000 80B5     		push	{r7, lr}
 974              	.LCFI24:
 975              		.cfi_def_cfa_offset 8
 976              		.cfi_offset 7, -8
 977              		.cfi_offset 14, -4
 978 0002 84B0     		sub	sp, sp, #16
 979              	.LCFI25:
 980              		.cfi_def_cfa_offset 24
 981 0004 00AF     		add	r7, sp, #0
 982              	.LCFI26:
 983              		.cfi_def_cfa_register 7
 984 0006 F860     		str	r0, [r7, #12]
 985 0008 B960     		str	r1, [r7, #8]
 986 000a 111C     		mov	r1, r2
 987 000c 1A1C     		mov	r2, r3
 988 000e BB1D     		add	r3, r7, #6
 989 0010 1980     		strh	r1, [r3]
 990 0012 7B1D     		add	r3, r7, #5
 991 0014 1A70     		strb	r2, [r3]
 403:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, val);
 992              		.loc 1 403 0
 993 0016 F968     		ldr	r1, [r7, #12]
 994 0018 BA68     		ldr	r2, [r7, #8]
 995 001a BB1D     		add	r3, r7, #6
 996 001c 0020     		mov	r0, #0
 997 001e 1B5E     		ldrsh	r3, [r3, r0]
 998 0020 081C     		mov	r0, r1
 999 0022 111C     		mov	r1, r2
 1000 0024 1A1C     		mov	r2, r3
 1001 0026 FFF7FEFF 		bl	UTIL1_Num16sToStr
 404:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1002              		.loc 1 404 0
 1003 002a F968     		ldr	r1, [r7, #12]
 1004 002c 7B1D     		add	r3, r7, #5
 1005 002e 1A78     		ldrb	r2, [r3]
 1006 0030 3B1C     		mov	r3, r7
 1007 0032 1833     		add	r3, r3, #24
 1008 0034 1B78     		ldrb	r3, [r3]
 1009 0036 081C     		mov	r0, r1
 1010 0038 111C     		mov	r1, r2
 1011 003a 1A1C     		mov	r2, r3
 1012 003c FFF7FEFF 		bl	ShiftRightAndFill
 405:../Generated_Code/UTIL1.c **** }
 1013              		.loc 1 405 0
 1014 0040 BD46     		mov	sp, r7
 1015 0042 04B0     		add	sp, sp, #16
 1016              		@ sp needed for prologue
 1017 0044 80BD     		pop	{r7, pc}
 1018              		.cfi_endproc
 1019              	.LFE8:
 1021 0046 C046     		.section	.text.UTIL1_Num16uToStrFormatted,"ax",%progbits
 1022              		.align	2
 1023              		.global	UTIL1_Num16uToStrFormatted
 1024              		.code	16
 1025              		.thumb_func
 1027              	UTIL1_Num16uToStrFormatted:
 1028              	.LFB9:
 406:../Generated_Code/UTIL1.c **** 
 407:../Generated_Code/UTIL1.c **** /*
 408:../Generated_Code/UTIL1.c **** ** ===================================================================
 409:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16uToStrFormatted (component Utility)
 410:../Generated_Code/UTIL1.c **** **
 411:../Generated_Code/UTIL1.c **** **     Description :
 412:../Generated_Code/UTIL1.c **** **         Converts a 16bit unsigned value to string.
 413:../Generated_Code/UTIL1.c **** **     Parameters  :
 414:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 415:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 416:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 417:../Generated_Code/UTIL1.c **** **                           bytes).
 418:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 419:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 420:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 421:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 422:../Generated_Code/UTIL1.c **** ** ===================================================================
 423:../Generated_Code/UTIL1.c **** */
 424:../Generated_Code/UTIL1.c **** /*!
 425:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit unsigned number to a string, in a formatted way (like printf with "%0d").
 426:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 427:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 428:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 429:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 430:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 431:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 432:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 433:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 434:../Generated_Code/UTIL1.c **** */
 435:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStrFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill)
 436:../Generated_Code/UTIL1.c **** {
 1029              		.loc 1 436 0
 1030              		.cfi_startproc
 1031 0000 80B5     		push	{r7, lr}
 1032              	.LCFI27:
 1033              		.cfi_def_cfa_offset 8
 1034              		.cfi_offset 7, -8
 1035              		.cfi_offset 14, -4
 1036 0002 84B0     		sub	sp, sp, #16
 1037              	.LCFI28:
 1038              		.cfi_def_cfa_offset 24
 1039 0004 00AF     		add	r7, sp, #0
 1040              	.LCFI29:
 1041              		.cfi_def_cfa_register 7
 1042 0006 F860     		str	r0, [r7, #12]
 1043 0008 B960     		str	r1, [r7, #8]
 1044 000a 111C     		mov	r1, r2
 1045 000c 1A1C     		mov	r2, r3
 1046 000e BB1D     		add	r3, r7, #6
 1047 0010 1980     		strh	r1, [r3]
 1048 0012 7B1D     		add	r3, r7, #5
 1049 0014 1A70     		strb	r2, [r3]
 437:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, val);
 1050              		.loc 1 437 0
 1051 0016 F968     		ldr	r1, [r7, #12]
 1052 0018 BA68     		ldr	r2, [r7, #8]
 1053 001a BB1D     		add	r3, r7, #6
 1054 001c 1B88     		ldrh	r3, [r3]
 1055 001e 081C     		mov	r0, r1
 1056 0020 111C     		mov	r1, r2
 1057 0022 1A1C     		mov	r2, r3
 1058 0024 FFF7FEFF 		bl	UTIL1_Num16uToStr
 438:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1059              		.loc 1 438 0
 1060 0028 F968     		ldr	r1, [r7, #12]
 1061 002a 7B1D     		add	r3, r7, #5
 1062 002c 1A78     		ldrb	r2, [r3]
 1063 002e 3B1C     		mov	r3, r7
 1064 0030 1833     		add	r3, r3, #24
 1065 0032 1B78     		ldrb	r3, [r3]
 1066 0034 081C     		mov	r0, r1
 1067 0036 111C     		mov	r1, r2
 1068 0038 1A1C     		mov	r2, r3
 1069 003a FFF7FEFF 		bl	ShiftRightAndFill
 439:../Generated_Code/UTIL1.c **** }
 1070              		.loc 1 439 0
 1071 003e BD46     		mov	sp, r7
 1072 0040 04B0     		add	sp, sp, #16
 1073              		@ sp needed for prologue
 1074 0042 80BD     		pop	{r7, pc}
 1075              		.cfi_endproc
 1076              	.LFE9:
 1078              		.section	.text.UTIL1_Num32uToStrFormatted,"ax",%progbits
 1079              		.align	2
 1080              		.global	UTIL1_Num32uToStrFormatted
 1081              		.code	16
 1082              		.thumb_func
 1084              	UTIL1_Num32uToStrFormatted:
 1085              	.LFB10:
 440:../Generated_Code/UTIL1.c **** 
 441:../Generated_Code/UTIL1.c **** /*
 442:../Generated_Code/UTIL1.c **** ** ===================================================================
 443:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32uToStrFormatted (component Utility)
 444:../Generated_Code/UTIL1.c **** **
 445:../Generated_Code/UTIL1.c **** **     Description :
 446:../Generated_Code/UTIL1.c **** **         Converts a 32bit unsigned value to string.
 447:../Generated_Code/UTIL1.c **** **     Parameters  :
 448:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 449:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 450:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 451:../Generated_Code/UTIL1.c **** **                           bytes).
 452:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 453:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 454:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 455:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 456:../Generated_Code/UTIL1.c **** ** ===================================================================
 457:../Generated_Code/UTIL1.c **** */
 458:../Generated_Code/UTIL1.c **** /*!
 459:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit unsigned number to a string, in a formatted way (like printf with "%0d").
 460:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 461:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 462:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 463:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 464:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 465:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
 466:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 467:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 468:../Generated_Code/UTIL1.c **** */
 469:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStrFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill)
 470:../Generated_Code/UTIL1.c **** {
 1086              		.loc 1 470 0
 1087              		.cfi_startproc
 1088 0000 80B5     		push	{r7, lr}
 1089              	.LCFI30:
 1090              		.cfi_def_cfa_offset 8
 1091              		.cfi_offset 7, -8
 1092              		.cfi_offset 14, -4
 1093 0002 84B0     		sub	sp, sp, #16
 1094              	.LCFI31:
 1095              		.cfi_def_cfa_offset 24
 1096 0004 00AF     		add	r7, sp, #0
 1097              	.LCFI32:
 1098              		.cfi_def_cfa_register 7
 1099 0006 F860     		str	r0, [r7, #12]
 1100 0008 B960     		str	r1, [r7, #8]
 1101 000a 7A60     		str	r2, [r7, #4]
 1102 000c 1A1C     		mov	r2, r3
 1103 000e FB1C     		add	r3, r7, #3
 1104 0010 1A70     		strb	r2, [r3]
 471:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStr(dst, dstSize, val);
 1105              		.loc 1 471 0
 1106 0012 F968     		ldr	r1, [r7, #12]
 1107 0014 BA68     		ldr	r2, [r7, #8]
 1108 0016 7B68     		ldr	r3, [r7, #4]
 1109 0018 081C     		mov	r0, r1
 1110 001a 111C     		mov	r1, r2
 1111 001c 1A1C     		mov	r2, r3
 1112 001e FFF7FEFF 		bl	UTIL1_Num32uToStr
 472:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1113              		.loc 1 472 0
 1114 0022 F968     		ldr	r1, [r7, #12]
 1115 0024 FB1C     		add	r3, r7, #3
 1116 0026 1A78     		ldrb	r2, [r3]
 1117 0028 3B1C     		mov	r3, r7
 1118 002a 1833     		add	r3, r3, #24
 1119 002c 1B78     		ldrb	r3, [r3]
 1120 002e 081C     		mov	r0, r1
 1121 0030 111C     		mov	r1, r2
 1122 0032 1A1C     		mov	r2, r3
 1123 0034 FFF7FEFF 		bl	ShiftRightAndFill
 473:../Generated_Code/UTIL1.c **** }
 1124              		.loc 1 473 0
 1125 0038 BD46     		mov	sp, r7
 1126 003a 04B0     		add	sp, sp, #16
 1127              		@ sp needed for prologue
 1128 003c 80BD     		pop	{r7, pc}
 1129              		.cfi_endproc
 1130              	.LFE10:
 1132 003e C046     		.section	.text.UTIL1_Num32sToStrFormatted,"ax",%progbits
 1133              		.align	2
 1134              		.global	UTIL1_Num32sToStrFormatted
 1135              		.code	16
 1136              		.thumb_func
 1138              	UTIL1_Num32sToStrFormatted:
 1139              	.LFB11:
 474:../Generated_Code/UTIL1.c **** 
 475:../Generated_Code/UTIL1.c **** /*
 476:../Generated_Code/UTIL1.c **** ** ===================================================================
 477:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32sToStrFormatted (component Utility)
 478:../Generated_Code/UTIL1.c **** **
 479:../Generated_Code/UTIL1.c **** **     Description :
 480:../Generated_Code/UTIL1.c **** **         Converts a 32bit signed value to string.
 481:../Generated_Code/UTIL1.c **** **     Parameters  :
 482:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 483:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 484:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 485:../Generated_Code/UTIL1.c **** **                           bytes).
 486:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 487:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 488:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 489:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 490:../Generated_Code/UTIL1.c **** ** ===================================================================
 491:../Generated_Code/UTIL1.c **** */
 492:../Generated_Code/UTIL1.c **** /*!
 493:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit signed number to a string, in a formatted way (like printf with "%0d").
 494:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 495:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 496:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 497:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 498:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 499:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit signed number to add
 500:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 501:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 502:../Generated_Code/UTIL1.c **** */
 503:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStrFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill)
 504:../Generated_Code/UTIL1.c **** {
 1140              		.loc 1 504 0
 1141              		.cfi_startproc
 1142 0000 80B5     		push	{r7, lr}
 1143              	.LCFI33:
 1144              		.cfi_def_cfa_offset 8
 1145              		.cfi_offset 7, -8
 1146              		.cfi_offset 14, -4
 1147 0002 84B0     		sub	sp, sp, #16
 1148              	.LCFI34:
 1149              		.cfi_def_cfa_offset 24
 1150 0004 00AF     		add	r7, sp, #0
 1151              	.LCFI35:
 1152              		.cfi_def_cfa_register 7
 1153 0006 F860     		str	r0, [r7, #12]
 1154 0008 B960     		str	r1, [r7, #8]
 1155 000a 7A60     		str	r2, [r7, #4]
 1156 000c 1A1C     		mov	r2, r3
 1157 000e FB1C     		add	r3, r7, #3
 1158 0010 1A70     		strb	r2, [r3]
 505:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStr(dst, dstSize, val);
 1159              		.loc 1 505 0
 1160 0012 F968     		ldr	r1, [r7, #12]
 1161 0014 BA68     		ldr	r2, [r7, #8]
 1162 0016 7B68     		ldr	r3, [r7, #4]
 1163 0018 081C     		mov	r0, r1
 1164 001a 111C     		mov	r1, r2
 1165 001c 1A1C     		mov	r2, r3
 1166 001e FFF7FEFF 		bl	UTIL1_Num32sToStr
 506:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1167              		.loc 1 506 0
 1168 0022 F968     		ldr	r1, [r7, #12]
 1169 0024 FB1C     		add	r3, r7, #3
 1170 0026 1A78     		ldrb	r2, [r3]
 1171 0028 3B1C     		mov	r3, r7
 1172 002a 1833     		add	r3, r3, #24
 1173 002c 1B78     		ldrb	r3, [r3]
 1174 002e 081C     		mov	r0, r1
 1175 0030 111C     		mov	r1, r2
 1176 0032 1A1C     		mov	r2, r3
 1177 0034 FFF7FEFF 		bl	ShiftRightAndFill
 507:../Generated_Code/UTIL1.c **** }
 1178              		.loc 1 507 0
 1179 0038 BD46     		mov	sp, r7
 1180 003a 04B0     		add	sp, sp, #16
 1181              		@ sp needed for prologue
 1182 003c 80BD     		pop	{r7, pc}
 1183              		.cfi_endproc
 1184              	.LFE11:
 1186 003e C046     		.section	.text.UTIL1_strcatNum8u,"ax",%progbits
 1187              		.align	2
 1188              		.global	UTIL1_strcatNum8u
 1189              		.code	16
 1190              		.thumb_func
 1192              	UTIL1_strcatNum8u:
 1193              	.LFB12:
 508:../Generated_Code/UTIL1.c **** 
 509:../Generated_Code/UTIL1.c **** /*
 510:../Generated_Code/UTIL1.c **** ** ===================================================================
 511:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8u (component Utility)
 512:../Generated_Code/UTIL1.c **** **
 513:../Generated_Code/UTIL1.c **** **     Description :
 514:../Generated_Code/UTIL1.c **** **         Appends a 8bit unsigned value to a string buffer.
 515:../Generated_Code/UTIL1.c **** **     Parameters  :
 516:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 517:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 518:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 519:../Generated_Code/UTIL1.c **** **                           bytes).
 520:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 521:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 522:../Generated_Code/UTIL1.c **** ** ===================================================================
 523:../Generated_Code/UTIL1.c **** */
 524:../Generated_Code/UTIL1.c **** /*!
 525:../Generated_Code/UTIL1.c ****   \brief appends a 8bit unsigned number to a string. Always terminates the result string.
 526:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 527:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 528:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 529:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 530:../Generated_Code/UTIL1.c ****   \param[in] val The 8bit unsigned number to add
 531:../Generated_Code/UTIL1.c ****   */
 532:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8u(byte *dst, size_t dstSize, byte val)
 533:../Generated_Code/UTIL1.c **** {
 1194              		.loc 1 533 0
 1195              		.cfi_startproc
 1196 0000 80B5     		push	{r7, lr}
 1197              	.LCFI36:
 1198              		.cfi_def_cfa_offset 8
 1199              		.cfi_offset 7, -8
 1200              		.cfi_offset 14, -4
 1201 0002 86B0     		sub	sp, sp, #24
 1202              	.LCFI37:
 1203              		.cfi_def_cfa_offset 32
 1204 0004 00AF     		add	r7, sp, #0
 1205              	.LCFI38:
 1206              		.cfi_def_cfa_register 7
 1207 0006 F860     		str	r0, [r7, #12]
 1208 0008 B960     		str	r1, [r7, #8]
 1209 000a FB1D     		add	r3, r7, #7
 1210 000c 1A70     		strb	r2, [r3]
 534:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("256")]; /* maximum buffer size we need */
 535:../Generated_Code/UTIL1.c **** 
 536:../Generated_Code/UTIL1.c ****   UTIL1_Num8uToStr(buf, sizeof(buf), val);
 1211              		.loc 1 536 0
 1212 000e 3A1C     		mov	r2, r7
 1213 0010 1432     		add	r2, r2, #20
 1214 0012 FB1D     		add	r3, r7, #7
 1215 0014 1B78     		ldrb	r3, [r3]
 1216 0016 101C     		mov	r0, r2
 1217 0018 0421     		mov	r1, #4
 1218 001a 1A1C     		mov	r2, r3
 1219 001c FFF7FEFF 		bl	UTIL1_Num8uToStr
 537:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1220              		.loc 1 537 0
 1221 0020 F968     		ldr	r1, [r7, #12]
 1222 0022 BA68     		ldr	r2, [r7, #8]
 1223 0024 3B1C     		mov	r3, r7
 1224 0026 1433     		add	r3, r3, #20
 1225 0028 081C     		mov	r0, r1
 1226 002a 111C     		mov	r1, r2
 1227 002c 1A1C     		mov	r2, r3
 1228 002e FFF7FEFF 		bl	UTIL1_strcat
 538:../Generated_Code/UTIL1.c **** }
 1229              		.loc 1 538 0
 1230 0032 BD46     		mov	sp, r7
 1231 0034 06B0     		add	sp, sp, #24
 1232              		@ sp needed for prologue
 1233 0036 80BD     		pop	{r7, pc}
 1234              		.cfi_endproc
 1235              	.LFE12:
 1237              		.section	.text.UTIL1_strcatNum8s,"ax",%progbits
 1238              		.align	2
 1239              		.global	UTIL1_strcatNum8s
 1240              		.code	16
 1241              		.thumb_func
 1243              	UTIL1_strcatNum8s:
 1244              	.LFB13:
 539:../Generated_Code/UTIL1.c **** 
 540:../Generated_Code/UTIL1.c **** /*
 541:../Generated_Code/UTIL1.c **** ** ===================================================================
 542:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8s (component Utility)
 543:../Generated_Code/UTIL1.c **** **
 544:../Generated_Code/UTIL1.c **** **     Description :
 545:../Generated_Code/UTIL1.c **** **         Appends a 8bit signed value to a string buffer.
 546:../Generated_Code/UTIL1.c **** **     Parameters  :
 547:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 548:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 549:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 550:../Generated_Code/UTIL1.c **** **                           bytes).
 551:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 552:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 553:../Generated_Code/UTIL1.c **** ** ===================================================================
 554:../Generated_Code/UTIL1.c **** */
 555:../Generated_Code/UTIL1.c **** /*!
 556:../Generated_Code/UTIL1.c ****   \brief appends a 8bit signed number to a string. Always terminates the result string.
 557:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 558:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 559:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 560:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 561:../Generated_Code/UTIL1.c ****   \param[in] val The 8bit signed number to add
 562:../Generated_Code/UTIL1.c ****   */
 563:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8s(byte *dst, size_t dstSize, signed char val)
 564:../Generated_Code/UTIL1.c **** {
 1245              		.loc 1 564 0
 1246              		.cfi_startproc
 1247 0000 80B5     		push	{r7, lr}
 1248              	.LCFI39:
 1249              		.cfi_def_cfa_offset 8
 1250              		.cfi_offset 7, -8
 1251              		.cfi_offset 14, -4
 1252 0002 86B0     		sub	sp, sp, #24
 1253              	.LCFI40:
 1254              		.cfi_def_cfa_offset 32
 1255 0004 00AF     		add	r7, sp, #0
 1256              	.LCFI41:
 1257              		.cfi_def_cfa_register 7
 1258 0006 F860     		str	r0, [r7, #12]
 1259 0008 B960     		str	r1, [r7, #8]
 1260 000a FB1D     		add	r3, r7, #7
 1261 000c 1A70     		strb	r2, [r3]
 565:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-128")]; /* maximum buffer size we need */
 566:../Generated_Code/UTIL1.c **** 
 567:../Generated_Code/UTIL1.c ****   UTIL1_Num8sToStr(buf, sizeof(buf), val);
 1262              		.loc 1 567 0
 1263 000e 3A1C     		mov	r2, r7
 1264 0010 1032     		add	r2, r2, #16
 1265 0012 FB1D     		add	r3, r7, #7
 1266 0014 1B78     		ldrb	r3, [r3]
 1267 0016 5BB2     		sxtb	r3, r3
 1268 0018 101C     		mov	r0, r2
 1269 001a 0521     		mov	r1, #5
 1270 001c 1A1C     		mov	r2, r3
 1271 001e FFF7FEFF 		bl	UTIL1_Num8sToStr
 568:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1272              		.loc 1 568 0
 1273 0022 F968     		ldr	r1, [r7, #12]
 1274 0024 BA68     		ldr	r2, [r7, #8]
 1275 0026 3B1C     		mov	r3, r7
 1276 0028 1033     		add	r3, r3, #16
 1277 002a 081C     		mov	r0, r1
 1278 002c 111C     		mov	r1, r2
 1279 002e 1A1C     		mov	r2, r3
 1280 0030 FFF7FEFF 		bl	UTIL1_strcat
 569:../Generated_Code/UTIL1.c **** }
 1281              		.loc 1 569 0
 1282 0034 BD46     		mov	sp, r7
 1283 0036 06B0     		add	sp, sp, #24
 1284              		@ sp needed for prologue
 1285 0038 80BD     		pop	{r7, pc}
 1286              		.cfi_endproc
 1287              	.LFE13:
 1289 003a C046     		.section	.text.UTIL1_strcatNum16u,"ax",%progbits
 1290              		.align	2
 1291              		.global	UTIL1_strcatNum16u
 1292              		.code	16
 1293              		.thumb_func
 1295              	UTIL1_strcatNum16u:
 1296              	.LFB14:
 570:../Generated_Code/UTIL1.c **** 
 571:../Generated_Code/UTIL1.c **** /*
 572:../Generated_Code/UTIL1.c **** ** ===================================================================
 573:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16u (component Utility)
 574:../Generated_Code/UTIL1.c **** **
 575:../Generated_Code/UTIL1.c **** **     Description :
 576:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a string buffer.
 577:../Generated_Code/UTIL1.c **** **     Parameters  :
 578:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 579:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 580:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 581:../Generated_Code/UTIL1.c **** **                           bytes).
 582:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 583:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 584:../Generated_Code/UTIL1.c **** ** ===================================================================
 585:../Generated_Code/UTIL1.c **** */
 586:../Generated_Code/UTIL1.c **** /*!
 587:../Generated_Code/UTIL1.c ****   \brief appends a 16bit unsigned number to a string. Always terminates the result string.
 588:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 589:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 590:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 591:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 592:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 593:../Generated_Code/UTIL1.c ****   */
 594:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16u(byte *dst, size_t dstSize, word val)
 595:../Generated_Code/UTIL1.c **** {
 1297              		.loc 1 595 0
 1298              		.cfi_startproc
 1299 0000 80B5     		push	{r7, lr}
 1300              	.LCFI42:
 1301              		.cfi_def_cfa_offset 8
 1302              		.cfi_offset 7, -8
 1303              		.cfi_offset 14, -4
 1304 0002 86B0     		sub	sp, sp, #24
 1305              	.LCFI43:
 1306              		.cfi_def_cfa_offset 32
 1307 0004 00AF     		add	r7, sp, #0
 1308              	.LCFI44:
 1309              		.cfi_def_cfa_register 7
 1310 0006 F860     		str	r0, [r7, #12]
 1311 0008 B960     		str	r1, [r7, #8]
 1312 000a BB1D     		add	r3, r7, #6
 1313 000c 1A80     		strh	r2, [r3]
 596:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */
 597:../Generated_Code/UTIL1.c **** 
 598:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(buf, sizeof(buf), val);
 1314              		.loc 1 598 0
 1315 000e 3A1C     		mov	r2, r7
 1316 0010 1032     		add	r2, r2, #16
 1317 0012 BB1D     		add	r3, r7, #6
 1318 0014 1B88     		ldrh	r3, [r3]
 1319 0016 101C     		mov	r0, r2
 1320 0018 0621     		mov	r1, #6
 1321 001a 1A1C     		mov	r2, r3
 1322 001c FFF7FEFF 		bl	UTIL1_Num16uToStr
 599:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1323              		.loc 1 599 0
 1324 0020 F968     		ldr	r1, [r7, #12]
 1325 0022 BA68     		ldr	r2, [r7, #8]
 1326 0024 3B1C     		mov	r3, r7
 1327 0026 1033     		add	r3, r3, #16
 1328 0028 081C     		mov	r0, r1
 1329 002a 111C     		mov	r1, r2
 1330 002c 1A1C     		mov	r2, r3
 1331 002e FFF7FEFF 		bl	UTIL1_strcat
 600:../Generated_Code/UTIL1.c **** }
 1332              		.loc 1 600 0
 1333 0032 BD46     		mov	sp, r7
 1334 0034 06B0     		add	sp, sp, #24
 1335              		@ sp needed for prologue
 1336 0036 80BD     		pop	{r7, pc}
 1337              		.cfi_endproc
 1338              	.LFE14:
 1340              		.section	.text.UTIL1_strcatNum16s,"ax",%progbits
 1341              		.align	2
 1342              		.global	UTIL1_strcatNum16s
 1343              		.code	16
 1344              		.thumb_func
 1346              	UTIL1_strcatNum16s:
 1347              	.LFB15:
 601:../Generated_Code/UTIL1.c **** 
 602:../Generated_Code/UTIL1.c **** /*
 603:../Generated_Code/UTIL1.c **** ** ===================================================================
 604:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16s (component Utility)
 605:../Generated_Code/UTIL1.c **** **
 606:../Generated_Code/UTIL1.c **** **     Description :
 607:../Generated_Code/UTIL1.c **** **         Appends a 16bit signed value to a string buffer.
 608:../Generated_Code/UTIL1.c **** **     Parameters  :
 609:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 610:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 611:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 612:../Generated_Code/UTIL1.c **** **                           bytes).
 613:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 614:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 615:../Generated_Code/UTIL1.c **** ** ===================================================================
 616:../Generated_Code/UTIL1.c **** */
 617:../Generated_Code/UTIL1.c **** /*!
 618:../Generated_Code/UTIL1.c ****   \brief appends a 16bit signed number to a string. Always terminates the result string.
 619:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 620:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 621:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 622:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 623:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 624:../Generated_Code/UTIL1.c ****   */
 625:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16s(byte *dst, size_t dstSize, int16_t val)
 626:../Generated_Code/UTIL1.c **** {
 1348              		.loc 1 626 0
 1349              		.cfi_startproc
 1350 0000 80B5     		push	{r7, lr}
 1351              	.LCFI45:
 1352              		.cfi_def_cfa_offset 8
 1353              		.cfi_offset 7, -8
 1354              		.cfi_offset 14, -4
 1355 0002 86B0     		sub	sp, sp, #24
 1356              	.LCFI46:
 1357              		.cfi_def_cfa_offset 32
 1358 0004 00AF     		add	r7, sp, #0
 1359              	.LCFI47:
 1360              		.cfi_def_cfa_register 7
 1361 0006 F860     		str	r0, [r7, #12]
 1362 0008 B960     		str	r1, [r7, #8]
 1363 000a BB1D     		add	r3, r7, #6
 1364 000c 1A80     		strh	r2, [r3]
 627:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */
 628:../Generated_Code/UTIL1.c **** 
 629:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(buf, sizeof(buf), val);
 1365              		.loc 1 629 0
 1366 000e 3A1C     		mov	r2, r7
 1367 0010 1032     		add	r2, r2, #16
 1368 0012 BB1D     		add	r3, r7, #6
 1369 0014 0021     		mov	r1, #0
 1370 0016 5B5E     		ldrsh	r3, [r3, r1]
 1371 0018 101C     		mov	r0, r2
 1372 001a 0721     		mov	r1, #7
 1373 001c 1A1C     		mov	r2, r3
 1374 001e FFF7FEFF 		bl	UTIL1_Num16sToStr
 630:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1375              		.loc 1 630 0
 1376 0022 F968     		ldr	r1, [r7, #12]
 1377 0024 BA68     		ldr	r2, [r7, #8]
 1378 0026 3B1C     		mov	r3, r7
 1379 0028 1033     		add	r3, r3, #16
 1380 002a 081C     		mov	r0, r1
 1381 002c 111C     		mov	r1, r2
 1382 002e 1A1C     		mov	r2, r3
 1383 0030 FFF7FEFF 		bl	UTIL1_strcat
 631:../Generated_Code/UTIL1.c **** }
 1384              		.loc 1 631 0
 1385 0034 BD46     		mov	sp, r7
 1386 0036 06B0     		add	sp, sp, #24
 1387              		@ sp needed for prologue
 1388 0038 80BD     		pop	{r7, pc}
 1389              		.cfi_endproc
 1390              	.LFE15:
 1392 003a C046     		.section	.text.UTIL1_strcatNum16uFormatted,"ax",%progbits
 1393              		.align	2
 1394              		.global	UTIL1_strcatNum16uFormatted
 1395              		.code	16
 1396              		.thumb_func
 1398              	UTIL1_strcatNum16uFormatted:
 1399              	.LFB16:
 632:../Generated_Code/UTIL1.c **** 
 633:../Generated_Code/UTIL1.c **** /*
 634:../Generated_Code/UTIL1.c **** ** ===================================================================
 635:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16uFormatted (component Utility)
 636:../Generated_Code/UTIL1.c **** **
 637:../Generated_Code/UTIL1.c **** **     Description :
 638:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a string buffer in a
 639:../Generated_Code/UTIL1.c **** **         formatted way.
 640:../Generated_Code/UTIL1.c **** **     Parameters  :
 641:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 642:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 643:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 644:../Generated_Code/UTIL1.c **** **                           bytes).
 645:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 646:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 647:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 648:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 649:../Generated_Code/UTIL1.c **** ** ===================================================================
 650:../Generated_Code/UTIL1.c **** */
 651:../Generated_Code/UTIL1.c **** /*!
 652:../Generated_Code/UTIL1.c ****   \brief appends a 16bit unsigned number to a string, in a formatted way (like printf with "%0d".
 653:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 654:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 655:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 656:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 657:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 658:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 659:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 660:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 661:../Generated_Code/UTIL1.c ****   */
 662:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16uFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill)
 663:../Generated_Code/UTIL1.c **** {
 1400              		.loc 1 663 0
 1401              		.cfi_startproc
 1402 0000 90B5     		push	{r4, r7, lr}
 1403              	.LCFI48:
 1404              		.cfi_def_cfa_offset 12
 1405              		.cfi_offset 4, -12
 1406              		.cfi_offset 7, -8
 1407              		.cfi_offset 14, -4
 1408 0002 89B0     		sub	sp, sp, #36
 1409              	.LCFI49:
 1410              		.cfi_def_cfa_offset 48
 1411 0004 02AF     		add	r7, sp, #8
 1412              	.LCFI50:
 1413              		.cfi_def_cfa 7, 40
 1414 0006 F860     		str	r0, [r7, #12]
 1415 0008 B960     		str	r1, [r7, #8]
 1416 000a 111C     		mov	r1, r2
 1417 000c 1A1C     		mov	r2, r3
 1418 000e BB1D     		add	r3, r7, #6
 1419 0010 1980     		strh	r1, [r3]
 1420 0012 7B1D     		add	r3, r7, #5
 1421 0014 1A70     		strb	r2, [r3]
 664:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */
 665:../Generated_Code/UTIL1.c **** 
 666:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStrFormatted(buf, dstSize, val, fill, nofFill);
 1422              		.loc 1 666 0
 1423 0016 381C     		mov	r0, r7
 1424 0018 1030     		add	r0, r0, #16
 1425 001a B968     		ldr	r1, [r7, #8]
 1426 001c BB1D     		add	r3, r7, #6
 1427 001e 1A88     		ldrh	r2, [r3]
 1428 0020 7B1D     		add	r3, r7, #5
 1429 0022 1B78     		ldrb	r3, [r3]
 1430 0024 3C1C     		mov	r4, r7
 1431 0026 2834     		add	r4, r4, #40
 1432 0028 2478     		ldrb	r4, [r4]
 1433 002a 0094     		str	r4, [sp]
 1434 002c FFF7FEFF 		bl	UTIL1_Num16uToStrFormatted
 667:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1435              		.loc 1 667 0
 1436 0030 F968     		ldr	r1, [r7, #12]
 1437 0032 BA68     		ldr	r2, [r7, #8]
 1438 0034 3B1C     		mov	r3, r7
 1439 0036 1033     		add	r3, r3, #16
 1440 0038 081C     		mov	r0, r1
 1441 003a 111C     		mov	r1, r2
 1442 003c 1A1C     		mov	r2, r3
 1443 003e FFF7FEFF 		bl	UTIL1_strcat
 668:../Generated_Code/UTIL1.c **** }
 1444              		.loc 1 668 0
 1445 0042 BD46     		mov	sp, r7
 1446 0044 07B0     		add	sp, sp, #28
 1447              		@ sp needed for prologue
 1448 0046 90BD     		pop	{r4, r7, pc}
 1449              		.cfi_endproc
 1450              	.LFE16:
 1452              		.section	.text.UTIL1_strcatNum16sFormatted,"ax",%progbits
 1453              		.align	2
 1454              		.global	UTIL1_strcatNum16sFormatted
 1455              		.code	16
 1456              		.thumb_func
 1458              	UTIL1_strcatNum16sFormatted:
 1459              	.LFB17:
 669:../Generated_Code/UTIL1.c **** 
 670:../Generated_Code/UTIL1.c **** /*
 671:../Generated_Code/UTIL1.c **** ** ===================================================================
 672:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16sFormatted (component Utility)
 673:../Generated_Code/UTIL1.c **** **
 674:../Generated_Code/UTIL1.c **** **     Description :
 675:../Generated_Code/UTIL1.c **** **         Appends a 16bit signed value to a string buffer in a
 676:../Generated_Code/UTIL1.c **** **         formatted way.
 677:../Generated_Code/UTIL1.c **** **     Parameters  :
 678:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 679:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 680:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 681:../Generated_Code/UTIL1.c **** **                           bytes).
 682:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 683:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 684:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 685:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 686:../Generated_Code/UTIL1.c **** ** ===================================================================
 687:../Generated_Code/UTIL1.c **** */
 688:../Generated_Code/UTIL1.c **** /*!
 689:../Generated_Code/UTIL1.c ****   \brief appends a 16bit signed number to a string, in a formatted way (like printf with "%0d".
 690:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 691:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 692:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 693:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 694:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 695:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 696:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 697:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 698:../Generated_Code/UTIL1.c ****   */
 699:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16sFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill)
 700:../Generated_Code/UTIL1.c **** {
 1460              		.loc 1 700 0
 1461              		.cfi_startproc
 1462 0000 90B5     		push	{r4, r7, lr}
 1463              	.LCFI51:
 1464              		.cfi_def_cfa_offset 12
 1465              		.cfi_offset 4, -12
 1466              		.cfi_offset 7, -8
 1467              		.cfi_offset 14, -4
 1468 0002 89B0     		sub	sp, sp, #36
 1469              	.LCFI52:
 1470              		.cfi_def_cfa_offset 48
 1471 0004 02AF     		add	r7, sp, #8
 1472              	.LCFI53:
 1473              		.cfi_def_cfa 7, 40
 1474 0006 F860     		str	r0, [r7, #12]
 1475 0008 B960     		str	r1, [r7, #8]
 1476 000a 111C     		mov	r1, r2
 1477 000c 1A1C     		mov	r2, r3
 1478 000e BB1D     		add	r3, r7, #6
 1479 0010 1980     		strh	r1, [r3]
 1480 0012 7B1D     		add	r3, r7, #5
 1481 0014 1A70     		strb	r2, [r3]
 701:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */
 702:../Generated_Code/UTIL1.c **** 
 703:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStrFormatted(buf, dstSize, val, fill, nofFill);
 1482              		.loc 1 703 0
 1483 0016 381C     		mov	r0, r7
 1484 0018 1030     		add	r0, r0, #16
 1485 001a B968     		ldr	r1, [r7, #8]
 1486 001c BB1D     		add	r3, r7, #6
 1487 001e 0024     		mov	r4, #0
 1488 0020 1A5F     		ldrsh	r2, [r3, r4]
 1489 0022 7B1D     		add	r3, r7, #5
 1490 0024 1B78     		ldrb	r3, [r3]
 1491 0026 3C1C     		mov	r4, r7
 1492 0028 2834     		add	r4, r4, #40
 1493 002a 2478     		ldrb	r4, [r4]
 1494 002c 0094     		str	r4, [sp]
 1495 002e FFF7FEFF 		bl	UTIL1_Num16sToStrFormatted
 704:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1496              		.loc 1 704 0
 1497 0032 F968     		ldr	r1, [r7, #12]
 1498 0034 BA68     		ldr	r2, [r7, #8]
 1499 0036 3B1C     		mov	r3, r7
 1500 0038 1033     		add	r3, r3, #16
 1501 003a 081C     		mov	r0, r1
 1502 003c 111C     		mov	r1, r2
 1503 003e 1A1C     		mov	r2, r3
 1504 0040 FFF7FEFF 		bl	UTIL1_strcat
 705:../Generated_Code/UTIL1.c **** }
 1505              		.loc 1 705 0
 1506 0044 BD46     		mov	sp, r7
 1507 0046 07B0     		add	sp, sp, #28
 1508              		@ sp needed for prologue
 1509 0048 90BD     		pop	{r4, r7, pc}
 1510              		.cfi_endproc
 1511              	.LFE17:
 1513 004a C046     		.section	.text.UTIL1_strcatNum32uFormatted,"ax",%progbits
 1514              		.align	2
 1515              		.global	UTIL1_strcatNum32uFormatted
 1516              		.code	16
 1517              		.thumb_func
 1519              	UTIL1_strcatNum32uFormatted:
 1520              	.LFB18:
 706:../Generated_Code/UTIL1.c **** 
 707:../Generated_Code/UTIL1.c **** /*
 708:../Generated_Code/UTIL1.c **** ** ===================================================================
 709:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32uFormatted (component Utility)
 710:../Generated_Code/UTIL1.c **** **
 711:../Generated_Code/UTIL1.c **** **     Description :
 712:../Generated_Code/UTIL1.c **** **         Appends a 32bit unsigned value to a string buffer in a
 713:../Generated_Code/UTIL1.c **** **         formatted way.
 714:../Generated_Code/UTIL1.c **** **     Parameters  :
 715:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 716:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 717:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 718:../Generated_Code/UTIL1.c **** **                           bytes).
 719:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 720:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 721:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 722:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 723:../Generated_Code/UTIL1.c **** ** ===================================================================
 724:../Generated_Code/UTIL1.c **** */
 725:../Generated_Code/UTIL1.c **** /*!
 726:../Generated_Code/UTIL1.c ****   \brief appends a 32bit unsigned number to a string, in a formatted way (like printf with "%0d".
 727:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 728:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 729:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 730:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 731:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 732:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
 733:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 734:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 735:../Generated_Code/UTIL1.c ****   */
 736:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32uFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill)
 737:../Generated_Code/UTIL1.c **** {
 1521              		.loc 1 737 0
 1522              		.cfi_startproc
 1523 0000 90B5     		push	{r4, r7, lr}
 1524              	.LCFI54:
 1525              		.cfi_def_cfa_offset 12
 1526              		.cfi_offset 4, -12
 1527              		.cfi_offset 7, -8
 1528              		.cfi_offset 14, -4
 1529 0002 8BB0     		sub	sp, sp, #44
 1530              	.LCFI55:
 1531              		.cfi_def_cfa_offset 56
 1532 0004 02AF     		add	r7, sp, #8
 1533              	.LCFI56:
 1534              		.cfi_def_cfa 7, 48
 1535 0006 F860     		str	r0, [r7, #12]
 1536 0008 B960     		str	r1, [r7, #8]
 1537 000a 7A60     		str	r2, [r7, #4]
 1538 000c 1A1C     		mov	r2, r3
 1539 000e FB1C     		add	r3, r7, #3
 1540 0010 1A70     		strb	r2, [r3]
 738:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */
 739:../Generated_Code/UTIL1.c **** 
 740:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStrFormatted(buf, dstSize, val, fill, nofFill);
 1541              		.loc 1 740 0
 1542 0012 381C     		mov	r0, r7
 1543 0014 1430     		add	r0, r0, #20
 1544 0016 B968     		ldr	r1, [r7, #8]
 1545 0018 7A68     		ldr	r2, [r7, #4]
 1546 001a FB1C     		add	r3, r7, #3
 1547 001c 1B78     		ldrb	r3, [r3]
 1548 001e 3C1C     		mov	r4, r7
 1549 0020 3034     		add	r4, r4, #48
 1550 0022 2478     		ldrb	r4, [r4]
 1551 0024 0094     		str	r4, [sp]
 1552 0026 FFF7FEFF 		bl	UTIL1_Num32uToStrFormatted
 741:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1553              		.loc 1 741 0
 1554 002a F968     		ldr	r1, [r7, #12]
 1555 002c BA68     		ldr	r2, [r7, #8]
 1556 002e 3B1C     		mov	r3, r7
 1557 0030 1433     		add	r3, r3, #20
 1558 0032 081C     		mov	r0, r1
 1559 0034 111C     		mov	r1, r2
 1560 0036 1A1C     		mov	r2, r3
 1561 0038 FFF7FEFF 		bl	UTIL1_strcat
 742:../Generated_Code/UTIL1.c **** }
 1562              		.loc 1 742 0
 1563 003c BD46     		mov	sp, r7
 1564 003e 09B0     		add	sp, sp, #36
 1565              		@ sp needed for prologue
 1566 0040 90BD     		pop	{r4, r7, pc}
 1567              		.cfi_endproc
 1568              	.LFE18:
 1570 0042 C046     		.section	.text.UTIL1_strcatNum32sFormatted,"ax",%progbits
 1571              		.align	2
 1572              		.global	UTIL1_strcatNum32sFormatted
 1573              		.code	16
 1574              		.thumb_func
 1576              	UTIL1_strcatNum32sFormatted:
 1577              	.LFB19:
 743:../Generated_Code/UTIL1.c **** 
 744:../Generated_Code/UTIL1.c **** /*
 745:../Generated_Code/UTIL1.c **** ** ===================================================================
 746:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32sFormatted (component Utility)
 747:../Generated_Code/UTIL1.c **** **
 748:../Generated_Code/UTIL1.c **** **     Description :
 749:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer in a
 750:../Generated_Code/UTIL1.c **** **         formatted way.
 751:../Generated_Code/UTIL1.c **** **     Parameters  :
 752:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 753:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 754:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 755:../Generated_Code/UTIL1.c **** **                           bytes).
 756:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 757:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 758:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 759:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 760:../Generated_Code/UTIL1.c **** ** ===================================================================
 761:../Generated_Code/UTIL1.c **** */
 762:../Generated_Code/UTIL1.c **** /*!
 763:../Generated_Code/UTIL1.c ****   \brief appends a 32bit signed number to a string, in a formatted way (like printf with "%0d".
 764:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 765:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 766:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 767:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 768:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 769:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit signed number to add
 770:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 771:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 772:../Generated_Code/UTIL1.c ****   */
 773:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32sFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill)
 774:../Generated_Code/UTIL1.c **** {
 1578              		.loc 1 774 0
 1579              		.cfi_startproc
 1580 0000 90B5     		push	{r4, r7, lr}
 1581              	.LCFI57:
 1582              		.cfi_def_cfa_offset 12
 1583              		.cfi_offset 4, -12
 1584              		.cfi_offset 7, -8
 1585              		.cfi_offset 14, -4
 1586 0002 8BB0     		sub	sp, sp, #44
 1587              	.LCFI58:
 1588              		.cfi_def_cfa_offset 56
 1589 0004 02AF     		add	r7, sp, #8
 1590              	.LCFI59:
 1591              		.cfi_def_cfa 7, 48
 1592 0006 F860     		str	r0, [r7, #12]
 1593 0008 B960     		str	r1, [r7, #8]
 1594 000a 7A60     		str	r2, [r7, #4]
 1595 000c 1A1C     		mov	r2, r3
 1596 000e FB1C     		add	r3, r7, #3
 1597 0010 1A70     		strb	r2, [r3]
 775:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */
 776:../Generated_Code/UTIL1.c **** 
 777:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStrFormatted(buf, dstSize, val, fill, nofFill);
 1598              		.loc 1 777 0
 1599 0012 381C     		mov	r0, r7
 1600 0014 1430     		add	r0, r0, #20
 1601 0016 B968     		ldr	r1, [r7, #8]
 1602 0018 7A68     		ldr	r2, [r7, #4]
 1603 001a FB1C     		add	r3, r7, #3
 1604 001c 1B78     		ldrb	r3, [r3]
 1605 001e 3C1C     		mov	r4, r7
 1606 0020 3034     		add	r4, r4, #48
 1607 0022 2478     		ldrb	r4, [r4]
 1608 0024 0094     		str	r4, [sp]
 1609 0026 FFF7FEFF 		bl	UTIL1_Num32sToStrFormatted
 778:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1610              		.loc 1 778 0
 1611 002a F968     		ldr	r1, [r7, #12]
 1612 002c BA68     		ldr	r2, [r7, #8]
 1613 002e 3B1C     		mov	r3, r7
 1614 0030 1433     		add	r3, r3, #20
 1615 0032 081C     		mov	r0, r1
 1616 0034 111C     		mov	r1, r2
 1617 0036 1A1C     		mov	r2, r3
 1618 0038 FFF7FEFF 		bl	UTIL1_strcat
 779:../Generated_Code/UTIL1.c **** }
 1619              		.loc 1 779 0
 1620 003c BD46     		mov	sp, r7
 1621 003e 09B0     		add	sp, sp, #36
 1622              		@ sp needed for prologue
 1623 0040 90BD     		pop	{r4, r7, pc}
 1624              		.cfi_endproc
 1625              	.LFE19:
 1627 0042 C046     		.section	.text.UTIL1_strcatNum8Hex,"ax",%progbits
 1628              		.align	2
 1629              		.global	UTIL1_strcatNum8Hex
 1630              		.code	16
 1631              		.thumb_func
 1633              	UTIL1_strcatNum8Hex:
 1634              	.LFB20:
 780:../Generated_Code/UTIL1.c **** 
 781:../Generated_Code/UTIL1.c **** /*
 782:../Generated_Code/UTIL1.c **** ** ===================================================================
 783:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8Hex (component Utility)
 784:../Generated_Code/UTIL1.c **** **
 785:../Generated_Code/UTIL1.c **** **     Description :
 786:../Generated_Code/UTIL1.c **** **         Appends a 8bit unsigned value to a buffer as hex number
 787:../Generated_Code/UTIL1.c **** **         (without a 0x prefix).
 788:../Generated_Code/UTIL1.c **** **     Parameters  :
 789:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 790:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 791:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 792:../Generated_Code/UTIL1.c **** **                           bytes).
 793:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 794:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 795:../Generated_Code/UTIL1.c **** ** ===================================================================
 796:../Generated_Code/UTIL1.c **** */
 797:../Generated_Code/UTIL1.c **** /*!
 798:../Generated_Code/UTIL1.c ****   \brief Adds a 8bit number as hex value to a string.
 799:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 800:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 801:../Generated_Code/UTIL1.c ****   \param[in] num The 8bit number to add
 802:../Generated_Code/UTIL1.c ****   */
 803:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8Hex(byte *dst, size_t dstSize, byte num)
 804:../Generated_Code/UTIL1.c **** {
 1635              		.loc 1 804 0
 1636              		.cfi_startproc
 1637 0000 80B5     		push	{r7, lr}
 1638              	.LCFI60:
 1639              		.cfi_def_cfa_offset 8
 1640              		.cfi_offset 7, -8
 1641              		.cfi_offset 14, -4
 1642 0002 86B0     		sub	sp, sp, #24
 1643              	.LCFI61:
 1644              		.cfi_def_cfa_offset 32
 1645 0004 00AF     		add	r7, sp, #0
 1646              	.LCFI62:
 1647              		.cfi_def_cfa_register 7
 1648 0006 F860     		str	r0, [r7, #12]
 1649 0008 B960     		str	r1, [r7, #8]
 1650 000a FB1D     		add	r3, r7, #7
 1651 000c 1A70     		strb	r2, [r3]
 805:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FF")]; /* maximum buffer size we need */
 806:../Generated_Code/UTIL1.c ****   unsigned char hex;
 807:../Generated_Code/UTIL1.c **** 
 808:../Generated_Code/UTIL1.c ****   buf[2] = '\0';
 1652              		.loc 1 808 0
 1653 000e 3B1C     		mov	r3, r7
 1654 0010 1433     		add	r3, r3, #20
 1655 0012 0022     		mov	r2, #0
 1656 0014 9A70     		strb	r2, [r3, #2]
 809:../Generated_Code/UTIL1.c ****   hex = (char)(num & 0x0F);
 1657              		.loc 1 809 0
 1658 0016 3B1C     		mov	r3, r7
 1659 0018 1733     		add	r3, r3, #23
 1660 001a FA1D     		add	r2, r7, #7
 1661 001c 1178     		ldrb	r1, [r2]
 1662 001e 0F22     		mov	r2, #15
 1663 0020 0A40     		and	r2, r1
 1664 0022 1A70     		strb	r2, [r3]
 810:../Generated_Code/UTIL1.c ****   buf[1] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1665              		.loc 1 810 0
 1666 0024 3B1C     		mov	r3, r7
 1667 0026 1733     		add	r3, r3, #23
 1668 0028 1B78     		ldrb	r3, [r3]
 1669 002a 092B     		cmp	r3, #9
 1670 002c 01D8     		bhi	.L56
 1671              		.loc 1 810 0 is_stmt 0 discriminator 1
 1672 002e 3023     		mov	r3, #48
 1673 0030 00E0     		b	.L57
 1674              	.L56:
 1675              		.loc 1 810 0 discriminator 2
 1676 0032 3723     		mov	r3, #55
 1677              	.L57:
 1678              		.loc 1 810 0 discriminator 3
 1679 0034 3A1C     		mov	r2, r7
 1680 0036 1732     		add	r2, r2, #23
 1681 0038 1278     		ldrb	r2, [r2]
 1682 003a 9B18     		add	r3, r3, r2
 1683 003c DAB2     		uxtb	r2, r3
 1684 003e 3B1C     		mov	r3, r7
 1685 0040 1433     		add	r3, r3, #20
 1686 0042 5A70     		strb	r2, [r3, #1]
 811:../Generated_Code/UTIL1.c ****   hex = (char)((num>>4) & 0x0F);
 1687              		.loc 1 811 0 is_stmt 1 discriminator 3
 1688 0044 3B1C     		mov	r3, r7
 1689 0046 1733     		add	r3, r3, #23
 1690 0048 FA1D     		add	r2, r7, #7
 1691 004a 1278     		ldrb	r2, [r2]
 1692 004c 1209     		lsr	r2, r2, #4
 1693 004e 1A70     		strb	r2, [r3]
 812:../Generated_Code/UTIL1.c ****   buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1694              		.loc 1 812 0 discriminator 3
 1695 0050 3B1C     		mov	r3, r7
 1696 0052 1733     		add	r3, r3, #23
 1697 0054 1B78     		ldrb	r3, [r3]
 1698 0056 092B     		cmp	r3, #9
 1699 0058 01D8     		bhi	.L58
 1700              		.loc 1 812 0 is_stmt 0 discriminator 1
 1701 005a 3023     		mov	r3, #48
 1702 005c 00E0     		b	.L59
 1703              	.L58:
 1704              		.loc 1 812 0 discriminator 2
 1705 005e 3723     		mov	r3, #55
 1706              	.L59:
 1707              		.loc 1 812 0 discriminator 3
 1708 0060 3A1C     		mov	r2, r7
 1709 0062 1732     		add	r2, r2, #23
 1710 0064 1278     		ldrb	r2, [r2]
 1711 0066 9B18     		add	r3, r3, r2
 1712 0068 DAB2     		uxtb	r2, r3
 1713 006a 3B1C     		mov	r3, r7
 1714 006c 1433     		add	r3, r3, #20
 1715 006e 1A70     		strb	r2, [r3]
 813:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1716              		.loc 1 813 0 is_stmt 1 discriminator 3
 1717 0070 F968     		ldr	r1, [r7, #12]
 1718 0072 BA68     		ldr	r2, [r7, #8]
 1719 0074 3B1C     		mov	r3, r7
 1720 0076 1433     		add	r3, r3, #20
 1721 0078 081C     		mov	r0, r1
 1722 007a 111C     		mov	r1, r2
 1723 007c 1A1C     		mov	r2, r3
 1724 007e FFF7FEFF 		bl	UTIL1_strcat
 814:../Generated_Code/UTIL1.c **** }
 1725              		.loc 1 814 0 discriminator 3
 1726 0082 BD46     		mov	sp, r7
 1727 0084 06B0     		add	sp, sp, #24
 1728              		@ sp needed for prologue
 1729 0086 80BD     		pop	{r7, pc}
 1730              		.cfi_endproc
 1731              	.LFE20:
 1733              		.section	.text.UTIL1_strcatNum16Hex,"ax",%progbits
 1734              		.align	2
 1735              		.global	UTIL1_strcatNum16Hex
 1736              		.code	16
 1737              		.thumb_func
 1739              	UTIL1_strcatNum16Hex:
 1740              	.LFB21:
 815:../Generated_Code/UTIL1.c **** 
 816:../Generated_Code/UTIL1.c **** /*
 817:../Generated_Code/UTIL1.c **** ** ===================================================================
 818:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16Hex (component Utility)
 819:../Generated_Code/UTIL1.c **** **
 820:../Generated_Code/UTIL1.c **** **     Description :
 821:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a buffer as hex number
 822:../Generated_Code/UTIL1.c **** **         (without a 0x prefix).
 823:../Generated_Code/UTIL1.c **** **     Parameters  :
 824:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 825:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 826:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 827:../Generated_Code/UTIL1.c **** **                           bytes).
 828:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 829:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 830:../Generated_Code/UTIL1.c **** ** ===================================================================
 831:../Generated_Code/UTIL1.c **** */
 832:../Generated_Code/UTIL1.c **** /*!
 833:../Generated_Code/UTIL1.c ****   \brief Adds a 16bit number as hex value to a string.
 834:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 835:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 836:../Generated_Code/UTIL1.c ****   \param[in] num The 16bit number to add
 837:../Generated_Code/UTIL1.c ****   */
 838:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16Hex(byte *dst, size_t dstSize, word num)
 839:../Generated_Code/UTIL1.c **** {
 1741              		.loc 1 839 0
 1742              		.cfi_startproc
 1743 0000 80B5     		push	{r7, lr}
 1744              	.LCFI63:
 1745              		.cfi_def_cfa_offset 8
 1746              		.cfi_offset 7, -8
 1747              		.cfi_offset 14, -4
 1748 0002 86B0     		sub	sp, sp, #24
 1749              	.LCFI64:
 1750              		.cfi_def_cfa_offset 32
 1751 0004 00AF     		add	r7, sp, #0
 1752              	.LCFI65:
 1753              		.cfi_def_cfa_register 7
 1754 0006 F860     		str	r0, [r7, #12]
 1755 0008 B960     		str	r1, [r7, #8]
 1756 000a BB1D     		add	r3, r7, #6
 1757 000c 1A80     		strh	r2, [r3]
 840:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFF")]; /* maximum buffer size we need */
 841:../Generated_Code/UTIL1.c ****   unsigned char hex;
 842:../Generated_Code/UTIL1.c ****   int8_t i;
 843:../Generated_Code/UTIL1.c **** 
 844:../Generated_Code/UTIL1.c ****   buf[4] = '\0';
 1758              		.loc 1 844 0
 1759 000e 3B1C     		mov	r3, r7
 1760 0010 1033     		add	r3, r3, #16
 1761 0012 0022     		mov	r2, #0
 1762 0014 1A71     		strb	r2, [r3, #4]
 845:../Generated_Code/UTIL1.c ****   i = 3;
 1763              		.loc 1 845 0
 1764 0016 3B1C     		mov	r3, r7
 1765 0018 1733     		add	r3, r3, #23
 1766 001a 0322     		mov	r2, #3
 1767 001c 1A70     		strb	r2, [r3]
 1768              	.L63:
 846:../Generated_Code/UTIL1.c ****   do {
 847:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 1769              		.loc 1 847 0
 1770 001e BB1D     		add	r3, r7, #6
 1771 0020 1B88     		ldrh	r3, [r3]
 1772 0022 D9B2     		uxtb	r1, r3
 1773 0024 3B1C     		mov	r3, r7
 1774 0026 1633     		add	r3, r3, #22
 1775 0028 0F22     		mov	r2, #15
 1776 002a 0A40     		and	r2, r1
 1777 002c 1A70     		strb	r2, [r3]
 848:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1778              		.loc 1 848 0
 1779 002e 3B1C     		mov	r3, r7
 1780 0030 1733     		add	r3, r3, #23
 1781 0032 0022     		mov	r2, #0
 1782 0034 9A56     		ldrsb	r2, [r3, r2]
 1783 0036 3B1C     		mov	r3, r7
 1784 0038 1633     		add	r3, r3, #22
 1785 003a 1B78     		ldrb	r3, [r3]
 1786 003c 092B     		cmp	r3, #9
 1787 003e 01D8     		bhi	.L61
 1788              		.loc 1 848 0 is_stmt 0 discriminator 1
 1789 0040 3023     		mov	r3, #48
 1790 0042 00E0     		b	.L62
 1791              	.L61:
 1792              		.loc 1 848 0 discriminator 2
 1793 0044 3723     		mov	r3, #55
 1794              	.L62:
 1795              		.loc 1 848 0 discriminator 3
 1796 0046 391C     		mov	r1, r7
 1797 0048 1631     		add	r1, r1, #22
 1798 004a 0978     		ldrb	r1, [r1]
 1799 004c 5B18     		add	r3, r3, r1
 1800 004e D9B2     		uxtb	r1, r3
 1801 0050 3B1C     		mov	r3, r7
 1802 0052 1033     		add	r3, r3, #16
 1803 0054 9954     		strb	r1, [r3, r2]
 849:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 1804              		.loc 1 849 0 is_stmt 1 discriminator 3
 1805 0056 BB1D     		add	r3, r7, #6
 1806 0058 BA1D     		add	r2, r7, #6
 1807 005a 1288     		ldrh	r2, [r2]
 1808 005c 1209     		lsr	r2, r2, #4
 1809 005e 1A80     		strh	r2, [r3]
 850:../Generated_Code/UTIL1.c ****     i--;
 1810              		.loc 1 850 0 discriminator 3
 1811 0060 3B1C     		mov	r3, r7
 1812 0062 1733     		add	r3, r3, #23
 1813 0064 3A1C     		mov	r2, r7
 1814 0066 1732     		add	r2, r2, #23
 1815 0068 1278     		ldrb	r2, [r2]
 1816 006a 013A     		sub	r2, r2, #1
 1817 006c 1A70     		strb	r2, [r3]
 851:../Generated_Code/UTIL1.c ****   } while (i>=0);
 1818              		.loc 1 851 0 discriminator 3
 1819 006e 3B1C     		mov	r3, r7
 1820 0070 1733     		add	r3, r3, #23
 1821 0072 1B78     		ldrb	r3, [r3]
 1822 0074 7F2B     		cmp	r3, #127
 1823 0076 D2D9     		bls	.L63
 852:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1824              		.loc 1 852 0
 1825 0078 F968     		ldr	r1, [r7, #12]
 1826 007a BA68     		ldr	r2, [r7, #8]
 1827 007c 3B1C     		mov	r3, r7
 1828 007e 1033     		add	r3, r3, #16
 1829 0080 081C     		mov	r0, r1
 1830 0082 111C     		mov	r1, r2
 1831 0084 1A1C     		mov	r2, r3
 1832 0086 FFF7FEFF 		bl	UTIL1_strcat
 853:../Generated_Code/UTIL1.c **** }
 1833              		.loc 1 853 0
 1834 008a BD46     		mov	sp, r7
 1835 008c 06B0     		add	sp, sp, #24
 1836              		@ sp needed for prologue
 1837 008e 80BD     		pop	{r7, pc}
 1838              		.cfi_endproc
 1839              	.LFE21:
 1841              		.section	.text.UTIL1_strcatNum24Hex,"ax",%progbits
 1842              		.align	2
 1843              		.global	UTIL1_strcatNum24Hex
 1844              		.code	16
 1845              		.thumb_func
 1847              	UTIL1_strcatNum24Hex:
 1848              	.LFB22:
 854:../Generated_Code/UTIL1.c **** 
 855:../Generated_Code/UTIL1.c **** /*
 856:../Generated_Code/UTIL1.c **** ** ===================================================================
 857:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum24Hex (component Utility)
 858:../Generated_Code/UTIL1.c **** **
 859:../Generated_Code/UTIL1.c **** **     Description :
 860:../Generated_Code/UTIL1.c **** **         Appends a 32bit unsigned value to a buffer as hex number
 861:../Generated_Code/UTIL1.c **** **         (without a 0x prefix). Only 24bits are used.
 862:../Generated_Code/UTIL1.c **** **     Parameters  :
 863:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 864:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 865:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 866:../Generated_Code/UTIL1.c **** **                           bytes).
 867:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 868:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 869:../Generated_Code/UTIL1.c **** ** ===================================================================
 870:../Generated_Code/UTIL1.c **** */
 871:../Generated_Code/UTIL1.c **** /*!
 872:../Generated_Code/UTIL1.c ****   \brief Adds a 24bit number as hex value to a string.
 873:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 874:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 875:../Generated_Code/UTIL1.c ****   \param[in] num The 24bit number to add
 876:../Generated_Code/UTIL1.c ****   */
 877:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum24Hex(byte *dst, size_t dstSize, dword num)
 878:../Generated_Code/UTIL1.c **** {
 1849              		.loc 1 878 0
 1850              		.cfi_startproc
 1851 0000 80B5     		push	{r7, lr}
 1852              	.LCFI66:
 1853              		.cfi_def_cfa_offset 8
 1854              		.cfi_offset 7, -8
 1855              		.cfi_offset 14, -4
 1856 0002 88B0     		sub	sp, sp, #32
 1857              	.LCFI67:
 1858              		.cfi_def_cfa_offset 40
 1859 0004 00AF     		add	r7, sp, #0
 1860              	.LCFI68:
 1861              		.cfi_def_cfa_register 7
 1862 0006 F860     		str	r0, [r7, #12]
 1863 0008 B960     		str	r1, [r7, #8]
 1864 000a 7A60     		str	r2, [r7, #4]
 879:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFFFF")]; /* maximum buffer size we need */
 880:../Generated_Code/UTIL1.c ****   unsigned char hex;
 881:../Generated_Code/UTIL1.c ****   int8_t i;
 882:../Generated_Code/UTIL1.c **** 
 883:../Generated_Code/UTIL1.c ****   buf[6] = '\0';
 1865              		.loc 1 883 0
 1866 000c 3B1C     		mov	r3, r7
 1867 000e 1433     		add	r3, r3, #20
 1868 0010 0022     		mov	r2, #0
 1869 0012 9A71     		strb	r2, [r3, #6]
 884:../Generated_Code/UTIL1.c ****   i = 5;
 1870              		.loc 1 884 0
 1871 0014 3B1C     		mov	r3, r7
 1872 0016 1F33     		add	r3, r3, #31
 1873 0018 0522     		mov	r2, #5
 1874 001a 1A70     		strb	r2, [r3]
 1875              	.L67:
 885:../Generated_Code/UTIL1.c ****   do {
 886:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 1876              		.loc 1 886 0
 1877 001c 7B68     		ldr	r3, [r7, #4]
 1878 001e D9B2     		uxtb	r1, r3
 1879 0020 3B1C     		mov	r3, r7
 1880 0022 1E33     		add	r3, r3, #30
 1881 0024 0F22     		mov	r2, #15
 1882 0026 0A40     		and	r2, r1
 1883 0028 1A70     		strb	r2, [r3]
 887:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1884              		.loc 1 887 0
 1885 002a 3B1C     		mov	r3, r7
 1886 002c 1F33     		add	r3, r3, #31
 1887 002e 0022     		mov	r2, #0
 1888 0030 9A56     		ldrsb	r2, [r3, r2]
 1889 0032 3B1C     		mov	r3, r7
 1890 0034 1E33     		add	r3, r3, #30
 1891 0036 1B78     		ldrb	r3, [r3]
 1892 0038 092B     		cmp	r3, #9
 1893 003a 01D8     		bhi	.L65
 1894              		.loc 1 887 0 is_stmt 0 discriminator 1
 1895 003c 3023     		mov	r3, #48
 1896 003e 00E0     		b	.L66
 1897              	.L65:
 1898              		.loc 1 887 0 discriminator 2
 1899 0040 3723     		mov	r3, #55
 1900              	.L66:
 1901              		.loc 1 887 0 discriminator 3
 1902 0042 391C     		mov	r1, r7
 1903 0044 1E31     		add	r1, r1, #30
 1904 0046 0978     		ldrb	r1, [r1]
 1905 0048 5B18     		add	r3, r3, r1
 1906 004a D9B2     		uxtb	r1, r3
 1907 004c 3B1C     		mov	r3, r7
 1908 004e 1433     		add	r3, r3, #20
 1909 0050 9954     		strb	r1, [r3, r2]
 888:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 1910              		.loc 1 888 0 is_stmt 1 discriminator 3
 1911 0052 7B68     		ldr	r3, [r7, #4]
 1912 0054 1B09     		lsr	r3, r3, #4
 1913 0056 7B60     		str	r3, [r7, #4]
 889:../Generated_Code/UTIL1.c ****     i--;
 1914              		.loc 1 889 0 discriminator 3
 1915 0058 3B1C     		mov	r3, r7
 1916 005a 1F33     		add	r3, r3, #31
 1917 005c 3A1C     		mov	r2, r7
 1918 005e 1F32     		add	r2, r2, #31
 1919 0060 1278     		ldrb	r2, [r2]
 1920 0062 013A     		sub	r2, r2, #1
 1921 0064 1A70     		strb	r2, [r3]
 890:../Generated_Code/UTIL1.c ****   } while (i>=0);
 1922              		.loc 1 890 0 discriminator 3
 1923 0066 3B1C     		mov	r3, r7
 1924 0068 1F33     		add	r3, r3, #31
 1925 006a 1B78     		ldrb	r3, [r3]
 1926 006c 7F2B     		cmp	r3, #127
 1927 006e D5D9     		bls	.L67
 891:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1928              		.loc 1 891 0
 1929 0070 F968     		ldr	r1, [r7, #12]
 1930 0072 BA68     		ldr	r2, [r7, #8]
 1931 0074 3B1C     		mov	r3, r7
 1932 0076 1433     		add	r3, r3, #20
 1933 0078 081C     		mov	r0, r1
 1934 007a 111C     		mov	r1, r2
 1935 007c 1A1C     		mov	r2, r3
 1936 007e FFF7FEFF 		bl	UTIL1_strcat
 892:../Generated_Code/UTIL1.c **** }
 1937              		.loc 1 892 0
 1938 0082 BD46     		mov	sp, r7
 1939 0084 08B0     		add	sp, sp, #32
 1940              		@ sp needed for prologue
 1941 0086 80BD     		pop	{r7, pc}
 1942              		.cfi_endproc
 1943              	.LFE22:
 1945              		.section	.text.UTIL1_strcatNum32Hex,"ax",%progbits
 1946              		.align	2
 1947              		.global	UTIL1_strcatNum32Hex
 1948              		.code	16
 1949              		.thumb_func
 1951              	UTIL1_strcatNum32Hex:
 1952              	.LFB23:
 893:../Generated_Code/UTIL1.c **** 
 894:../Generated_Code/UTIL1.c **** /*
 895:../Generated_Code/UTIL1.c **** ** ===================================================================
 896:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32Hex (component Utility)
 897:../Generated_Code/UTIL1.c **** **
 898:../Generated_Code/UTIL1.c **** **     Description :
 899:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a buffer as hex number
 900:../Generated_Code/UTIL1.c **** **         (without a 0x prefix).
 901:../Generated_Code/UTIL1.c **** **     Parameters  :
 902:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 903:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 904:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 905:../Generated_Code/UTIL1.c **** **                           bytes).
 906:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 907:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 908:../Generated_Code/UTIL1.c **** ** ===================================================================
 909:../Generated_Code/UTIL1.c **** */
 910:../Generated_Code/UTIL1.c **** /*!
 911:../Generated_Code/UTIL1.c ****   \brief Adds a 32bit number as hex value to a string.
 912:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 913:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 914:../Generated_Code/UTIL1.c ****   \param[in] num The 32bit number to add
 915:../Generated_Code/UTIL1.c ****   */
 916:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32Hex(byte *dst, size_t dstSize, dword num)
 917:../Generated_Code/UTIL1.c **** {
 1953              		.loc 1 917 0
 1954              		.cfi_startproc
 1955 0000 80B5     		push	{r7, lr}
 1956              	.LCFI69:
 1957              		.cfi_def_cfa_offset 8
 1958              		.cfi_offset 7, -8
 1959              		.cfi_offset 14, -4
 1960 0002 88B0     		sub	sp, sp, #32
 1961              	.LCFI70:
 1962              		.cfi_def_cfa_offset 40
 1963 0004 00AF     		add	r7, sp, #0
 1964              	.LCFI71:
 1965              		.cfi_def_cfa_register 7
 1966 0006 F860     		str	r0, [r7, #12]
 1967 0008 B960     		str	r1, [r7, #8]
 1968 000a 7A60     		str	r2, [r7, #4]
 918:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFFFFFF")]; /* maximum buffer size we need */
 919:../Generated_Code/UTIL1.c ****   unsigned char hex;
 920:../Generated_Code/UTIL1.c ****   int8_t i;
 921:../Generated_Code/UTIL1.c **** 
 922:../Generated_Code/UTIL1.c ****   buf[8] = '\0';
 1969              		.loc 1 922 0
 1970 000c 3B1C     		mov	r3, r7
 1971 000e 1433     		add	r3, r3, #20
 1972 0010 0022     		mov	r2, #0
 1973 0012 1A72     		strb	r2, [r3, #8]
 923:../Generated_Code/UTIL1.c ****   i = 7;
 1974              		.loc 1 923 0
 1975 0014 3B1C     		mov	r3, r7
 1976 0016 1F33     		add	r3, r3, #31
 1977 0018 0722     		mov	r2, #7
 1978 001a 1A70     		strb	r2, [r3]
 1979              	.L71:
 924:../Generated_Code/UTIL1.c ****   do {
 925:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 1980              		.loc 1 925 0
 1981 001c 7B68     		ldr	r3, [r7, #4]
 1982 001e D9B2     		uxtb	r1, r3
 1983 0020 3B1C     		mov	r3, r7
 1984 0022 1E33     		add	r3, r3, #30
 1985 0024 0F22     		mov	r2, #15
 1986 0026 0A40     		and	r2, r1
 1987 0028 1A70     		strb	r2, [r3]
 926:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1988              		.loc 1 926 0
 1989 002a 3B1C     		mov	r3, r7
 1990 002c 1F33     		add	r3, r3, #31
 1991 002e 0022     		mov	r2, #0
 1992 0030 9A56     		ldrsb	r2, [r3, r2]
 1993 0032 3B1C     		mov	r3, r7
 1994 0034 1E33     		add	r3, r3, #30
 1995 0036 1B78     		ldrb	r3, [r3]
 1996 0038 092B     		cmp	r3, #9
 1997 003a 01D8     		bhi	.L69
 1998              		.loc 1 926 0 is_stmt 0 discriminator 1
 1999 003c 3023     		mov	r3, #48
 2000 003e 00E0     		b	.L70
 2001              	.L69:
 2002              		.loc 1 926 0 discriminator 2
 2003 0040 3723     		mov	r3, #55
 2004              	.L70:
 2005              		.loc 1 926 0 discriminator 3
 2006 0042 391C     		mov	r1, r7
 2007 0044 1E31     		add	r1, r1, #30
 2008 0046 0978     		ldrb	r1, [r1]
 2009 0048 5B18     		add	r3, r3, r1
 2010 004a D9B2     		uxtb	r1, r3
 2011 004c 3B1C     		mov	r3, r7
 2012 004e 1433     		add	r3, r3, #20
 2013 0050 9954     		strb	r1, [r3, r2]
 927:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 2014              		.loc 1 927 0 is_stmt 1 discriminator 3
 2015 0052 7B68     		ldr	r3, [r7, #4]
 2016 0054 1B09     		lsr	r3, r3, #4
 2017 0056 7B60     		str	r3, [r7, #4]
 928:../Generated_Code/UTIL1.c ****     i--;
 2018              		.loc 1 928 0 discriminator 3
 2019 0058 3B1C     		mov	r3, r7
 2020 005a 1F33     		add	r3, r3, #31
 2021 005c 3A1C     		mov	r2, r7
 2022 005e 1F32     		add	r2, r2, #31
 2023 0060 1278     		ldrb	r2, [r2]
 2024 0062 013A     		sub	r2, r2, #1
 2025 0064 1A70     		strb	r2, [r3]
 929:../Generated_Code/UTIL1.c ****   } while (i>=0);
 2026              		.loc 1 929 0 discriminator 3
 2027 0066 3B1C     		mov	r3, r7
 2028 0068 1F33     		add	r3, r3, #31
 2029 006a 1B78     		ldrb	r3, [r3]
 2030 006c 7F2B     		cmp	r3, #127
 2031 006e D5D9     		bls	.L71
 930:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 2032              		.loc 1 930 0
 2033 0070 F968     		ldr	r1, [r7, #12]
 2034 0072 BA68     		ldr	r2, [r7, #8]
 2035 0074 3B1C     		mov	r3, r7
 2036 0076 1433     		add	r3, r3, #20
 2037 0078 081C     		mov	r0, r1
 2038 007a 111C     		mov	r1, r2
 2039 007c 1A1C     		mov	r2, r3
 2040 007e FFF7FEFF 		bl	UTIL1_strcat
 931:../Generated_Code/UTIL1.c **** }
 2041              		.loc 1 931 0
 2042 0082 BD46     		mov	sp, r7
 2043 0084 08B0     		add	sp, sp, #32
 2044              		@ sp needed for prologue
 2045 0086 80BD     		pop	{r7, pc}
 2046              		.cfi_endproc
 2047              	.LFE23:
 2049              		.section	.text.UTIL1_strcatNum32s,"ax",%progbits
 2050              		.align	2
 2051              		.global	UTIL1_strcatNum32s
 2052              		.code	16
 2053              		.thumb_func
 2055              	UTIL1_strcatNum32s:
 2056              	.LFB24:
 932:../Generated_Code/UTIL1.c **** 
 933:../Generated_Code/UTIL1.c **** /*
 934:../Generated_Code/UTIL1.c **** ** ===================================================================
 935:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32s (component Utility)
 936:../Generated_Code/UTIL1.c **** **
 937:../Generated_Code/UTIL1.c **** **     Description :
 938:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer.
 939:../Generated_Code/UTIL1.c **** **     Parameters  :
 940:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 941:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 942:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 943:../Generated_Code/UTIL1.c **** **                           bytes).
 944:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 945:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 946:../Generated_Code/UTIL1.c **** ** ===================================================================
 947:../Generated_Code/UTIL1.c **** */
 948:../Generated_Code/UTIL1.c **** /*!
 949:../Generated_Code/UTIL1.c ****   \brief appends a 32bit (long) number to a string. Always terminates the result string.
 950:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 951:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 952:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 953:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 954:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit number to add
 955:../Generated_Code/UTIL1.c ****   */
 956:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32s(byte *dst, size_t dstSize, long val)
 957:../Generated_Code/UTIL1.c **** {
 2057              		.loc 1 957 0
 2058              		.cfi_startproc
 2059 0000 80B5     		push	{r7, lr}
 2060              	.LCFI72:
 2061              		.cfi_def_cfa_offset 8
 2062              		.cfi_offset 7, -8
 2063              		.cfi_offset 14, -4
 2064 0002 88B0     		sub	sp, sp, #32
 2065              	.LCFI73:
 2066              		.cfi_def_cfa_offset 40
 2067 0004 00AF     		add	r7, sp, #0
 2068              	.LCFI74:
 2069              		.cfi_def_cfa_register 7
 2070 0006 F860     		str	r0, [r7, #12]
 2071 0008 B960     		str	r1, [r7, #8]
 2072 000a 7A60     		str	r2, [r7, #4]
 958:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */
 959:../Generated_Code/UTIL1.c **** 
 960:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStr(buf, sizeof(buf), val);
 2073              		.loc 1 960 0
 2074 000c 3A1C     		mov	r2, r7
 2075 000e 1432     		add	r2, r2, #20
 2076 0010 7B68     		ldr	r3, [r7, #4]
 2077 0012 101C     		mov	r0, r2
 2078 0014 0C21     		mov	r1, #12
 2079 0016 1A1C     		mov	r2, r3
 2080 0018 FFF7FEFF 		bl	UTIL1_Num32sToStr
 961:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 2081              		.loc 1 961 0
 2082 001c F968     		ldr	r1, [r7, #12]
 2083 001e BA68     		ldr	r2, [r7, #8]
 2084 0020 3B1C     		mov	r3, r7
 2085 0022 1433     		add	r3, r3, #20
 2086 0024 081C     		mov	r0, r1
 2087 0026 111C     		mov	r1, r2
 2088 0028 1A1C     		mov	r2, r3
 2089 002a FFF7FEFF 		bl	UTIL1_strcat
 962:../Generated_Code/UTIL1.c **** }
 2090              		.loc 1 962 0
 2091 002e BD46     		mov	sp, r7
 2092 0030 08B0     		add	sp, sp, #32
 2093              		@ sp needed for prologue
 2094 0032 80BD     		pop	{r7, pc}
 2095              		.cfi_endproc
 2096              	.LFE24:
 2098              		.section	.text.UTIL1_strcatNum32u,"ax",%progbits
 2099              		.align	2
 2100              		.global	UTIL1_strcatNum32u
 2101              		.code	16
 2102              		.thumb_func
 2104              	UTIL1_strcatNum32u:
 2105              	.LFB25:
 963:../Generated_Code/UTIL1.c **** 
 964:../Generated_Code/UTIL1.c **** /*
 965:../Generated_Code/UTIL1.c **** ** ===================================================================
 966:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32u (component Utility)
 967:../Generated_Code/UTIL1.c **** **
 968:../Generated_Code/UTIL1.c **** **     Description :
 969:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer.
 970:../Generated_Code/UTIL1.c **** **     Parameters  :
 971:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 972:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 973:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 974:../Generated_Code/UTIL1.c **** **                           bytes).
 975:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 976:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 977:../Generated_Code/UTIL1.c **** ** ===================================================================
 978:../Generated_Code/UTIL1.c **** */
 979:../Generated_Code/UTIL1.c **** /*!
 980:../Generated_Code/UTIL1.c ****   \brief appends a 32bit (unsigned long) number to a string. Always terminates the result string.
 981:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 982:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 983:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 984:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 985:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
 986:../Generated_Code/UTIL1.c ****   */
 987:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32u(byte *dst, size_t dstSize, dword val)
 988:../Generated_Code/UTIL1.c **** {
 2106              		.loc 1 988 0
 2107              		.cfi_startproc
 2108 0000 80B5     		push	{r7, lr}
 2109              	.LCFI75:
 2110              		.cfi_def_cfa_offset 8
 2111              		.cfi_offset 7, -8
 2112              		.cfi_offset 14, -4
 2113 0002 88B0     		sub	sp, sp, #32
 2114              	.LCFI76:
 2115              		.cfi_def_cfa_offset 40
 2116 0004 00AF     		add	r7, sp, #0
 2117              	.LCFI77:
 2118              		.cfi_def_cfa_register 7
 2119 0006 F860     		str	r0, [r7, #12]
 2120 0008 B960     		str	r1, [r7, #8]
 2121 000a 7A60     		str	r2, [r7, #4]
 989:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */
 990:../Generated_Code/UTIL1.c **** 
 991:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStr(buf, sizeof(buf), val);
 2122              		.loc 1 991 0
 2123 000c 3A1C     		mov	r2, r7
 2124 000e 1432     		add	r2, r2, #20
 2125 0010 7B68     		ldr	r3, [r7, #4]
 2126 0012 101C     		mov	r0, r2
 2127 0014 0B21     		mov	r1, #11
 2128 0016 1A1C     		mov	r2, r3
 2129 0018 FFF7FEFF 		bl	UTIL1_Num32uToStr
 992:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 2130              		.loc 1 992 0
 2131 001c F968     		ldr	r1, [r7, #12]
 2132 001e BA68     		ldr	r2, [r7, #8]
 2133 0020 3B1C     		mov	r3, r7
 2134 0022 1433     		add	r3, r3, #20
 2135 0024 081C     		mov	r0, r1
 2136 0026 111C     		mov	r1, r2
 2137 0028 1A1C     		mov	r2, r3
 2138 002a FFF7FEFF 		bl	UTIL1_strcat
 993:../Generated_Code/UTIL1.c **** }
 2139              		.loc 1 993 0
 2140 002e BD46     		mov	sp, r7
 2141 0030 08B0     		add	sp, sp, #32
 2142              		@ sp needed for prologue
 2143 0032 80BD     		pop	{r7, pc}
 2144              		.cfi_endproc
 2145              	.LFE25:
 2147              		.section	.text.UTIL1_Num32sToStr,"ax",%progbits
 2148              		.align	2
 2149              		.global	UTIL1_Num32sToStr
 2150              		.code	16
 2151              		.thumb_func
 2153              	UTIL1_Num32sToStr:
 2154              	.LFB26:
 994:../Generated_Code/UTIL1.c **** 
 995:../Generated_Code/UTIL1.c **** /*
 996:../Generated_Code/UTIL1.c **** ** ===================================================================
 997:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32sToStr (component Utility)
 998:../Generated_Code/UTIL1.c **** **
 999:../Generated_Code/UTIL1.c **** **     Description :
1000:../Generated_Code/UTIL1.c **** **         Converts a signed 32bit value into a string.
1001:../Generated_Code/UTIL1.c **** **     Parameters  :
1002:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1003:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
1004:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
1005:../Generated_Code/UTIL1.c **** **                           bytes).
1006:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
1007:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
1008:../Generated_Code/UTIL1.c **** ** ===================================================================
1009:../Generated_Code/UTIL1.c **** */
1010:../Generated_Code/UTIL1.c **** /*!
1011:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit number to a string.
1012:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
1013:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
1014:../Generated_Code/UTIL1.c ****   \param[in] val 32bit signed number to convert.
1015:../Generated_Code/UTIL1.c ****  */
1016:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStr(byte *dst, size_t dstSize, long val)
1017:../Generated_Code/UTIL1.c **** {
 2155              		.loc 1 1017 0
 2156              		.cfi_startproc
 2157 0000 90B5     		push	{r4, r7, lr}
 2158              	.LCFI78:
 2159              		.cfi_def_cfa_offset 12
 2160              		.cfi_offset 4, -12
 2161              		.cfi_offset 7, -8
 2162              		.cfi_offset 14, -4
 2163 0002 89B0     		sub	sp, sp, #36
 2164              	.LCFI79:
 2165              		.cfi_def_cfa_offset 48
 2166 0004 00AF     		add	r7, sp, #0
 2167              	.LCFI80:
 2168              		.cfi_def_cfa_register 7
 2169 0006 F860     		str	r0, [r7, #12]
 2170 0008 B960     		str	r1, [r7, #8]
 2171 000a 7A60     		str	r2, [r7, #4]
1018:../Generated_Code/UTIL1.c ****   unsigned char *ptr =  ((unsigned char *)dst);
 2172              		.loc 1 1018 0
 2173 000c FB68     		ldr	r3, [r7, #12]
 2174 000e BB61     		str	r3, [r7, #24]
1019:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 2175              		.loc 1 1019 0
 2176 0010 3B1C     		mov	r3, r7
 2177 0012 1F33     		add	r3, r3, #31
 2178 0014 0022     		mov	r2, #0
 2179 0016 1A70     		strb	r2, [r3]
1020:../Generated_Code/UTIL1.c ****   unsigned char tmp;
1021:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 2180              		.loc 1 1021 0
 2181 0018 3B1C     		mov	r3, r7
 2182 001a 1733     		add	r3, r3, #23
 2183 001c 7A68     		ldr	r2, [r7, #4]
 2184 001e D20F     		lsr	r2, r2, #31
 2185 0020 1A70     		strb	r2, [r3]
1022:../Generated_Code/UTIL1.c **** 
1023:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 2186              		.loc 1 1023 0
 2187 0022 BB68     		ldr	r3, [r7, #8]
 2188 0024 013B     		sub	r3, r3, #1
 2189 0026 BB60     		str	r3, [r7, #8]
1024:../Generated_Code/UTIL1.c ****   if (sign){
 2190              		.loc 1 1024 0
 2191 0028 3B1C     		mov	r3, r7
 2192 002a 1733     		add	r3, r3, #23
 2193 002c 1B78     		ldrb	r3, [r3]
 2194 002e 002B     		cmp	r3, #0
 2195 0030 02D0     		beq	.L75
1025:../Generated_Code/UTIL1.c ****     val *= -1;
 2196              		.loc 1 1025 0
 2197 0032 7B68     		ldr	r3, [r7, #4]
 2198 0034 5B42     		neg	r3, r3
 2199 0036 7B60     		str	r3, [r7, #4]
 2200              	.L75:
1026:../Generated_Code/UTIL1.c ****   }
1027:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 2201              		.loc 1 1027 0
 2202 0038 7B68     		ldr	r3, [r7, #4]
 2203 003a 002B     		cmp	r3, #0
 2204 003c 34D1     		bne	.L77
 2205              		.loc 1 1027 0 is_stmt 0 discriminator 1
 2206 003e BB68     		ldr	r3, [r7, #8]
 2207 0040 002B     		cmp	r3, #0
 2208 0042 31D0     		beq	.L77
1028:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 2209              		.loc 1 1028 0 is_stmt 1
 2210 0044 3B1C     		mov	r3, r7
 2211 0046 1F33     		add	r3, r3, #31
 2212 0048 1B78     		ldrb	r3, [r3]
 2213 004a BA69     		ldr	r2, [r7, #24]
 2214 004c D318     		add	r3, r2, r3
 2215 004e 3022     		mov	r2, #48
 2216 0050 1A70     		strb	r2, [r3]
 2217 0052 3B1C     		mov	r3, r7
 2218 0054 1F33     		add	r3, r3, #31
 2219 0056 3A1C     		mov	r2, r7
 2220 0058 1F32     		add	r2, r2, #31
 2221 005a 1278     		ldrb	r2, [r2]
 2222 005c 0132     		add	r2, r2, #1
 2223 005e 1A70     		strb	r2, [r3]
1029:../Generated_Code/UTIL1.c ****     dstSize--;
 2224              		.loc 1 1029 0
 2225 0060 BB68     		ldr	r3, [r7, #8]
 2226 0062 013B     		sub	r3, r3, #1
 2227 0064 BB60     		str	r3, [r7, #8]
1030:../Generated_Code/UTIL1.c ****   }
1031:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2228              		.loc 1 1031 0
 2229 0066 1FE0     		b	.L77
 2230              	.L79:
1032:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 2231              		.loc 1 1032 0
 2232 0068 3B1C     		mov	r3, r7
 2233 006a 1F33     		add	r3, r3, #31
 2234 006c 1B78     		ldrb	r3, [r3]
 2235 006e BA69     		ldr	r2, [r7, #24]
 2236 0070 D418     		add	r4, r2, r3
 2237 0072 7B68     		ldr	r3, [r7, #4]
 2238 0074 181C     		mov	r0, r3
 2239 0076 0A21     		mov	r1, #10
 2240 0078 FFF7FEFF 		bl	__aeabi_idivmod
 2241 007c 0B1C     		mov	r3, r1
 2242 007e DBB2     		uxtb	r3, r3
 2243 0080 3033     		add	r3, r3, #48
 2244 0082 DBB2     		uxtb	r3, r3
 2245 0084 2370     		strb	r3, [r4]
 2246 0086 3B1C     		mov	r3, r7
 2247 0088 1F33     		add	r3, r3, #31
 2248 008a 3A1C     		mov	r2, r7
 2249 008c 1F32     		add	r2, r2, #31
 2250 008e 1278     		ldrb	r2, [r2]
 2251 0090 0132     		add	r2, r2, #1
 2252 0092 1A70     		strb	r2, [r3]
1033:../Generated_Code/UTIL1.c ****     dstSize--;
 2253              		.loc 1 1033 0
 2254 0094 BB68     		ldr	r3, [r7, #8]
 2255 0096 013B     		sub	r3, r3, #1
 2256 0098 BB60     		str	r3, [r7, #8]
1034:../Generated_Code/UTIL1.c ****     val /= 10;
 2257              		.loc 1 1034 0
 2258 009a 7B68     		ldr	r3, [r7, #4]
 2259 009c 181C     		mov	r0, r3
 2260 009e 0A21     		mov	r1, #10
 2261 00a0 FFF7FEFF 		bl	__aeabi_idiv
 2262 00a4 031C     		mov	r3, r0
 2263 00a6 7B60     		str	r3, [r7, #4]
 2264              	.L77:
1031:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2265              		.loc 1 1031 0 discriminator 1
 2266 00a8 7B68     		ldr	r3, [r7, #4]
 2267 00aa 002B     		cmp	r3, #0
 2268 00ac 02DD     		ble	.L78
1031:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2269              		.loc 1 1031 0 is_stmt 0 discriminator 2
 2270 00ae BB68     		ldr	r3, [r7, #8]
 2271 00b0 002B     		cmp	r3, #0
 2272 00b2 D9D1     		bne	.L79
 2273              	.L78:
1035:../Generated_Code/UTIL1.c ****   }
1036:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 2274              		.loc 1 1036 0 is_stmt 1
 2275 00b4 3B1C     		mov	r3, r7
 2276 00b6 1733     		add	r3, r3, #23
 2277 00b8 1B78     		ldrb	r3, [r3]
 2278 00ba 002B     		cmp	r3, #0
 2279 00bc 13D0     		beq	.L80
 2280              		.loc 1 1036 0 is_stmt 0 discriminator 1
 2281 00be BB68     		ldr	r3, [r7, #8]
 2282 00c0 002B     		cmp	r3, #0
 2283 00c2 10D0     		beq	.L80
1037:../Generated_Code/UTIL1.c ****     ptr[i++] = '-';
 2284              		.loc 1 1037 0 is_stmt 1
 2285 00c4 3B1C     		mov	r3, r7
 2286 00c6 1F33     		add	r3, r3, #31
 2287 00c8 1B78     		ldrb	r3, [r3]
 2288 00ca BA69     		ldr	r2, [r7, #24]
 2289 00cc D318     		add	r3, r2, r3
 2290 00ce 2D22     		mov	r2, #45
 2291 00d0 1A70     		strb	r2, [r3]
 2292 00d2 3B1C     		mov	r3, r7
 2293 00d4 1F33     		add	r3, r3, #31
 2294 00d6 3A1C     		mov	r2, r7
 2295 00d8 1F32     		add	r2, r2, #31
 2296 00da 1278     		ldrb	r2, [r2]
 2297 00dc 0132     		add	r2, r2, #1
 2298 00de 1A70     		strb	r2, [r3]
1038:../Generated_Code/UTIL1.c ****     dstSize--;
 2299              		.loc 1 1038 0
 2300 00e0 BB68     		ldr	r3, [r7, #8]
 2301 00e2 013B     		sub	r3, r3, #1
 2302 00e4 BB60     		str	r3, [r7, #8]
 2303              	.L80:
1039:../Generated_Code/UTIL1.c ****   }
1040:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2304              		.loc 1 1040 0
 2305 00e6 3B1C     		mov	r3, r7
 2306 00e8 1E33     		add	r3, r3, #30
 2307 00ea 0022     		mov	r2, #0
 2308 00ec 1A70     		strb	r2, [r3]
 2309 00ee 2EE0     		b	.L81
 2310              	.L82:
1041:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 2311              		.loc 1 1041 0 discriminator 2
 2312 00f0 3B1C     		mov	r3, r7
 2313 00f2 1E33     		add	r3, r3, #30
 2314 00f4 1B78     		ldrb	r3, [r3]
 2315 00f6 BA69     		ldr	r2, [r7, #24]
 2316 00f8 D218     		add	r2, r2, r3
 2317 00fa 3B1C     		mov	r3, r7
 2318 00fc 1633     		add	r3, r3, #22
 2319 00fe 1278     		ldrb	r2, [r2]
 2320 0100 1A70     		strb	r2, [r3]
1042:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 2321              		.loc 1 1042 0 discriminator 2
 2322 0102 3B1C     		mov	r3, r7
 2323 0104 1E33     		add	r3, r3, #30
 2324 0106 1B78     		ldrb	r3, [r3]
 2325 0108 BA69     		ldr	r2, [r7, #24]
 2326 010a D318     		add	r3, r2, r3
 2327 010c 3A1C     		mov	r2, r7
 2328 010e 1F32     		add	r2, r2, #31
 2329 0110 1178     		ldrb	r1, [r2]
 2330 0112 3A1C     		mov	r2, r7
 2331 0114 1E32     		add	r2, r2, #30
 2332 0116 1278     		ldrb	r2, [r2]
 2333 0118 8A1A     		sub	r2, r1, r2
 2334 011a 013A     		sub	r2, r2, #1
 2335 011c B969     		ldr	r1, [r7, #24]
 2336 011e 8A18     		add	r2, r1, r2
 2337 0120 1278     		ldrb	r2, [r2]
 2338 0122 1A70     		strb	r2, [r3]
1043:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 2339              		.loc 1 1043 0 discriminator 2
 2340 0124 3B1C     		mov	r3, r7
 2341 0126 1F33     		add	r3, r3, #31
 2342 0128 1A78     		ldrb	r2, [r3]
 2343 012a 3B1C     		mov	r3, r7
 2344 012c 1E33     		add	r3, r3, #30
 2345 012e 1B78     		ldrb	r3, [r3]
 2346 0130 D31A     		sub	r3, r2, r3
 2347 0132 013B     		sub	r3, r3, #1
 2348 0134 BA69     		ldr	r2, [r7, #24]
 2349 0136 D318     		add	r3, r2, r3
 2350 0138 3A1C     		mov	r2, r7
 2351 013a 1632     		add	r2, r2, #22
 2352 013c 1278     		ldrb	r2, [r2]
 2353 013e 1A70     		strb	r2, [r3]
1040:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2354              		.loc 1 1040 0 discriminator 2
 2355 0140 3B1C     		mov	r3, r7
 2356 0142 1E33     		add	r3, r3, #30
 2357 0144 3A1C     		mov	r2, r7
 2358 0146 1E32     		add	r2, r2, #30
 2359 0148 1278     		ldrb	r2, [r2]
 2360 014a 0132     		add	r2, r2, #1
 2361 014c 1A70     		strb	r2, [r3]
 2362              	.L81:
1040:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2363              		.loc 1 1040 0 is_stmt 0 discriminator 1
 2364 014e 3B1C     		mov	r3, r7
 2365 0150 1F33     		add	r3, r3, #31
 2366 0152 1B78     		ldrb	r3, [r3]
 2367 0154 5B08     		lsr	r3, r3, #1
 2368 0156 DBB2     		uxtb	r3, r3
 2369 0158 3A1C     		mov	r2, r7
 2370 015a 1E32     		add	r2, r2, #30
 2371 015c 1278     		ldrb	r2, [r2]
 2372 015e 9A42     		cmp	r2, r3
 2373 0160 C6D3     		bcc	.L82
1044:../Generated_Code/UTIL1.c ****   }
1045:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 2374              		.loc 1 1045 0 is_stmt 1
 2375 0162 3B1C     		mov	r3, r7
 2376 0164 1F33     		add	r3, r3, #31
 2377 0166 1B78     		ldrb	r3, [r3]
 2378 0168 BA69     		ldr	r2, [r7, #24]
 2379 016a D318     		add	r3, r2, r3
 2380 016c 0022     		mov	r2, #0
 2381 016e 1A70     		strb	r2, [r3]
1046:../Generated_Code/UTIL1.c **** }
 2382              		.loc 1 1046 0
 2383 0170 BD46     		mov	sp, r7
 2384 0172 09B0     		add	sp, sp, #36
 2385              		@ sp needed for prologue
 2386 0174 90BD     		pop	{r4, r7, pc}
 2387              		.cfi_endproc
 2388              	.LFE26:
 2390 0176 C046     		.section	.text.UTIL1_Num32uToStr,"ax",%progbits
 2391              		.align	2
 2392              		.global	UTIL1_Num32uToStr
 2393              		.code	16
 2394              		.thumb_func
 2396              	UTIL1_Num32uToStr:
 2397              	.LFB27:
1047:../Generated_Code/UTIL1.c **** 
1048:../Generated_Code/UTIL1.c **** /*
1049:../Generated_Code/UTIL1.c **** ** ===================================================================
1050:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32uToStr (component Utility)
1051:../Generated_Code/UTIL1.c **** **
1052:../Generated_Code/UTIL1.c **** **     Description :
1053:../Generated_Code/UTIL1.c **** **         Converts an unsigned 32bit value into a string.
1054:../Generated_Code/UTIL1.c **** **     Parameters  :
1055:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1056:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
1057:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
1058:../Generated_Code/UTIL1.c **** **                           bytes).
1059:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
1060:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
1061:../Generated_Code/UTIL1.c **** ** ===================================================================
1062:../Generated_Code/UTIL1.c **** */
1063:../Generated_Code/UTIL1.c **** /*!
1064:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit signed number to a string.
1065:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
1066:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
1067:../Generated_Code/UTIL1.c ****   \param[in] val 32bit unsigned number to convert.
1068:../Generated_Code/UTIL1.c ****  */
1069:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStr(byte *dst, size_t dstSize, dword val)
1070:../Generated_Code/UTIL1.c **** {
 2398              		.loc 1 1070 0
 2399              		.cfi_startproc
 2400 0000 90B5     		push	{r4, r7, lr}
 2401              	.LCFI81:
 2402              		.cfi_def_cfa_offset 12
 2403              		.cfi_offset 4, -12
 2404              		.cfi_offset 7, -8
 2405              		.cfi_offset 14, -4
 2406 0002 89B0     		sub	sp, sp, #36
 2407              	.LCFI82:
 2408              		.cfi_def_cfa_offset 48
 2409 0004 00AF     		add	r7, sp, #0
 2410              	.LCFI83:
 2411              		.cfi_def_cfa_register 7
 2412 0006 F860     		str	r0, [r7, #12]
 2413 0008 B960     		str	r1, [r7, #8]
 2414 000a 7A60     		str	r2, [r7, #4]
1071:../Generated_Code/UTIL1.c ****   unsigned char *ptr = ((unsigned char *)dst);
 2415              		.loc 1 1071 0
 2416 000c FB68     		ldr	r3, [r7, #12]
 2417 000e BB61     		str	r3, [r7, #24]
1072:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 2418              		.loc 1 1072 0
 2419 0010 3B1C     		mov	r3, r7
 2420 0012 1F33     		add	r3, r3, #31
 2421 0014 0022     		mov	r2, #0
 2422 0016 1A70     		strb	r2, [r3]
1073:../Generated_Code/UTIL1.c ****   unsigned char tmp;
1074:../Generated_Code/UTIL1.c **** 
1075:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 2423              		.loc 1 1075 0
 2424 0018 BB68     		ldr	r3, [r7, #8]
 2425 001a 013B     		sub	r3, r3, #1
 2426 001c BB60     		str	r3, [r7, #8]
1076:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 2427              		.loc 1 1076 0
 2428 001e 7B68     		ldr	r3, [r7, #4]
 2429 0020 002B     		cmp	r3, #0
 2430 0022 34D1     		bne	.L85
 2431              		.loc 1 1076 0 is_stmt 0 discriminator 1
 2432 0024 BB68     		ldr	r3, [r7, #8]
 2433 0026 002B     		cmp	r3, #0
 2434 0028 31D0     		beq	.L85
1077:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 2435              		.loc 1 1077 0 is_stmt 1
 2436 002a 3B1C     		mov	r3, r7
 2437 002c 1F33     		add	r3, r3, #31
 2438 002e 1B78     		ldrb	r3, [r3]
 2439 0030 BA69     		ldr	r2, [r7, #24]
 2440 0032 D318     		add	r3, r2, r3
 2441 0034 3022     		mov	r2, #48
 2442 0036 1A70     		strb	r2, [r3]
 2443 0038 3B1C     		mov	r3, r7
 2444 003a 1F33     		add	r3, r3, #31
 2445 003c 3A1C     		mov	r2, r7
 2446 003e 1F32     		add	r2, r2, #31
 2447 0040 1278     		ldrb	r2, [r2]
 2448 0042 0132     		add	r2, r2, #1
 2449 0044 1A70     		strb	r2, [r3]
1078:../Generated_Code/UTIL1.c ****     dstSize--;
 2450              		.loc 1 1078 0
 2451 0046 BB68     		ldr	r3, [r7, #8]
 2452 0048 013B     		sub	r3, r3, #1
 2453 004a BB60     		str	r3, [r7, #8]
1079:../Generated_Code/UTIL1.c ****   }
1080:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2454              		.loc 1 1080 0
 2455 004c 1FE0     		b	.L85
 2456              	.L87:
1081:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 2457              		.loc 1 1081 0
 2458 004e 3B1C     		mov	r3, r7
 2459 0050 1F33     		add	r3, r3, #31
 2460 0052 1B78     		ldrb	r3, [r3]
 2461 0054 BA69     		ldr	r2, [r7, #24]
 2462 0056 D418     		add	r4, r2, r3
 2463 0058 7B68     		ldr	r3, [r7, #4]
 2464 005a 181C     		mov	r0, r3
 2465 005c 0A21     		mov	r1, #10
 2466 005e FFF7FEFF 		bl	__aeabi_uidivmod
 2467 0062 0B1C     		mov	r3, r1
 2468 0064 DBB2     		uxtb	r3, r3
 2469 0066 3033     		add	r3, r3, #48
 2470 0068 DBB2     		uxtb	r3, r3
 2471 006a 2370     		strb	r3, [r4]
 2472 006c 3B1C     		mov	r3, r7
 2473 006e 1F33     		add	r3, r3, #31
 2474 0070 3A1C     		mov	r2, r7
 2475 0072 1F32     		add	r2, r2, #31
 2476 0074 1278     		ldrb	r2, [r2]
 2477 0076 0132     		add	r2, r2, #1
 2478 0078 1A70     		strb	r2, [r3]
1082:../Generated_Code/UTIL1.c ****     dstSize--;
 2479              		.loc 1 1082 0
 2480 007a BB68     		ldr	r3, [r7, #8]
 2481 007c 013B     		sub	r3, r3, #1
 2482 007e BB60     		str	r3, [r7, #8]
1083:../Generated_Code/UTIL1.c ****     val /= 10;
 2483              		.loc 1 1083 0
 2484 0080 7B68     		ldr	r3, [r7, #4]
 2485 0082 181C     		mov	r0, r3
 2486 0084 0A21     		mov	r1, #10
 2487 0086 FFF7FEFF 		bl	__aeabi_uidiv
 2488 008a 031C     		mov	r3, r0
 2489 008c 7B60     		str	r3, [r7, #4]
 2490              	.L85:
1080:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2491              		.loc 1 1080 0 discriminator 1
 2492 008e 7B68     		ldr	r3, [r7, #4]
 2493 0090 002B     		cmp	r3, #0
 2494 0092 02D0     		beq	.L86
1080:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2495              		.loc 1 1080 0 is_stmt 0 discriminator 2
 2496 0094 BB68     		ldr	r3, [r7, #8]
 2497 0096 002B     		cmp	r3, #0
 2498 0098 D9D1     		bne	.L87
 2499              	.L86:
1084:../Generated_Code/UTIL1.c ****   }
1085:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2500              		.loc 1 1085 0 is_stmt 1
 2501 009a 3B1C     		mov	r3, r7
 2502 009c 1E33     		add	r3, r3, #30
 2503 009e 0022     		mov	r2, #0
 2504 00a0 1A70     		strb	r2, [r3]
 2505 00a2 2EE0     		b	.L88
 2506              	.L89:
1086:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 2507              		.loc 1 1086 0 discriminator 2
 2508 00a4 3B1C     		mov	r3, r7
 2509 00a6 1E33     		add	r3, r3, #30
 2510 00a8 1B78     		ldrb	r3, [r3]
 2511 00aa BA69     		ldr	r2, [r7, #24]
 2512 00ac D218     		add	r2, r2, r3
 2513 00ae 3B1C     		mov	r3, r7
 2514 00b0 1733     		add	r3, r3, #23
 2515 00b2 1278     		ldrb	r2, [r2]
 2516 00b4 1A70     		strb	r2, [r3]
1087:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 2517              		.loc 1 1087 0 discriminator 2
 2518 00b6 3B1C     		mov	r3, r7
 2519 00b8 1E33     		add	r3, r3, #30
 2520 00ba 1B78     		ldrb	r3, [r3]
 2521 00bc BA69     		ldr	r2, [r7, #24]
 2522 00be D318     		add	r3, r2, r3
 2523 00c0 3A1C     		mov	r2, r7
 2524 00c2 1F32     		add	r2, r2, #31
 2525 00c4 1178     		ldrb	r1, [r2]
 2526 00c6 3A1C     		mov	r2, r7
 2527 00c8 1E32     		add	r2, r2, #30
 2528 00ca 1278     		ldrb	r2, [r2]
 2529 00cc 8A1A     		sub	r2, r1, r2
 2530 00ce 013A     		sub	r2, r2, #1
 2531 00d0 B969     		ldr	r1, [r7, #24]
 2532 00d2 8A18     		add	r2, r1, r2
 2533 00d4 1278     		ldrb	r2, [r2]
 2534 00d6 1A70     		strb	r2, [r3]
1088:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 2535              		.loc 1 1088 0 discriminator 2
 2536 00d8 3B1C     		mov	r3, r7
 2537 00da 1F33     		add	r3, r3, #31
 2538 00dc 1A78     		ldrb	r2, [r3]
 2539 00de 3B1C     		mov	r3, r7
 2540 00e0 1E33     		add	r3, r3, #30
 2541 00e2 1B78     		ldrb	r3, [r3]
 2542 00e4 D31A     		sub	r3, r2, r3
 2543 00e6 013B     		sub	r3, r3, #1
 2544 00e8 BA69     		ldr	r2, [r7, #24]
 2545 00ea D318     		add	r3, r2, r3
 2546 00ec 3A1C     		mov	r2, r7
 2547 00ee 1732     		add	r2, r2, #23
 2548 00f0 1278     		ldrb	r2, [r2]
 2549 00f2 1A70     		strb	r2, [r3]
1085:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2550              		.loc 1 1085 0 discriminator 2
 2551 00f4 3B1C     		mov	r3, r7
 2552 00f6 1E33     		add	r3, r3, #30
 2553 00f8 3A1C     		mov	r2, r7
 2554 00fa 1E32     		add	r2, r2, #30
 2555 00fc 1278     		ldrb	r2, [r2]
 2556 00fe 0132     		add	r2, r2, #1
 2557 0100 1A70     		strb	r2, [r3]
 2558              	.L88:
1085:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2559              		.loc 1 1085 0 is_stmt 0 discriminator 1
 2560 0102 3B1C     		mov	r3, r7
 2561 0104 1F33     		add	r3, r3, #31
 2562 0106 1B78     		ldrb	r3, [r3]
 2563 0108 5B08     		lsr	r3, r3, #1
 2564 010a DBB2     		uxtb	r3, r3
 2565 010c 3A1C     		mov	r2, r7
 2566 010e 1E32     		add	r2, r2, #30
 2567 0110 1278     		ldrb	r2, [r2]
 2568 0112 9A42     		cmp	r2, r3
 2569 0114 C6D3     		bcc	.L89
1089:../Generated_Code/UTIL1.c ****   }
1090:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 2570              		.loc 1 1090 0 is_stmt 1
 2571 0116 3B1C     		mov	r3, r7
 2572 0118 1F33     		add	r3, r3, #31
 2573 011a 1B78     		ldrb	r3, [r3]
 2574 011c BA69     		ldr	r2, [r7, #24]
 2575 011e D318     		add	r3, r2, r3
 2576 0120 0022     		mov	r2, #0
 2577 0122 1A70     		strb	r2, [r3]
1091:../Generated_Code/UTIL1.c **** }
 2578              		.loc 1 1091 0
 2579 0124 BD46     		mov	sp, r7
 2580 0126 09B0     		add	sp, sp, #36
 2581              		@ sp needed for prologue
 2582 0128 90BD     		pop	{r4, r7, pc}
 2583              		.cfi_endproc
 2584              	.LFE27:
 2586 012a C046     		.section	.text.UTIL1_IsLeapYear,"ax",%progbits
 2587              		.align	2
 2588              		.global	UTIL1_IsLeapYear
 2589              		.code	16
 2590              		.thumb_func
 2592              	UTIL1_IsLeapYear:
 2593              	.LFB28:
1092:../Generated_Code/UTIL1.c **** 
1093:../Generated_Code/UTIL1.c **** /*
1094:../Generated_Code/UTIL1.c **** ** ===================================================================
1095:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_IsLeapYear (component Utility)
1096:../Generated_Code/UTIL1.c **** **
1097:../Generated_Code/UTIL1.c **** **     Description :
1098:../Generated_Code/UTIL1.c **** **         Returns true if a given year is a leap year
1099:../Generated_Code/UTIL1.c **** **     Parameters  :
1100:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1101:../Generated_Code/UTIL1.c **** **         year            - Year, in the YYYY format.
1102:../Generated_Code/UTIL1.c **** **     Returns     :
1103:../Generated_Code/UTIL1.c **** **         ---             - If the year is a leap year or not.
1104:../Generated_Code/UTIL1.c **** ** ===================================================================
1105:../Generated_Code/UTIL1.c **** */
1106:../Generated_Code/UTIL1.c **** bool UTIL1_IsLeapYear(word year)
1107:../Generated_Code/UTIL1.c **** {
 2594              		.loc 1 1107 0
 2595              		.cfi_startproc
 2596 0000 80B5     		push	{r7, lr}
 2597              	.LCFI84:
 2598              		.cfi_def_cfa_offset 8
 2599              		.cfi_offset 7, -8
 2600              		.cfi_offset 14, -4
 2601 0002 82B0     		sub	sp, sp, #8
 2602              	.LCFI85:
 2603              		.cfi_def_cfa_offset 16
 2604 0004 00AF     		add	r7, sp, #0
 2605              	.LCFI86:
 2606              		.cfi_def_cfa_register 7
 2607 0006 021C     		mov	r2, r0
 2608 0008 BB1D     		add	r3, r7, #6
 2609 000a 1A80     		strh	r2, [r3]
1108:../Generated_Code/UTIL1.c ****   return ((((year%4)==0) && (year%100)!=0) || (year%400)==0);
 2610              		.loc 1 1108 0
 2611 000c BB1D     		add	r3, r7, #6
 2612 000e 1A88     		ldrh	r2, [r3]
 2613 0010 0323     		mov	r3, #3
 2614 0012 1340     		and	r3, r2
 2615 0014 9BB2     		uxth	r3, r3
 2616 0016 002B     		cmp	r3, #0
 2617 0018 09D1     		bne	.L91
 2618              		.loc 1 1108 0 is_stmt 0 discriminator 1
 2619 001a BB1D     		add	r3, r7, #6
 2620 001c 1B88     		ldrh	r3, [r3]
 2621 001e 181C     		mov	r0, r3
 2622 0020 6421     		mov	r1, #100
 2623 0022 FFF7FEFF 		bl	__aeabi_uidivmod
 2624 0026 0B1C     		mov	r3, r1
 2625 0028 9BB2     		uxth	r3, r3
 2626 002a 002B     		cmp	r3, #0
 2627 002c 0AD1     		bne	.L92
 2628              	.L91:
 2629              		.loc 1 1108 0 discriminator 2
 2630 002e BB1D     		add	r3, r7, #6
 2631 0030 1B88     		ldrh	r3, [r3]
 2632 0032 181C     		mov	r0, r3
 2633 0034 C823     		mov	r3, #200
 2634 0036 5900     		lsl	r1, r3, #1
 2635 0038 FFF7FEFF 		bl	__aeabi_uidivmod
 2636 003c 0B1C     		mov	r3, r1
 2637 003e 9BB2     		uxth	r3, r3
 2638 0040 002B     		cmp	r3, #0
 2639 0042 01D1     		bne	.L93
 2640              	.L92:
 2641              		.loc 1 1108 0 discriminator 1
 2642 0044 0123     		mov	r3, #1
 2643 0046 00E0     		b	.L94
 2644              	.L93:
 2645 0048 0023     		mov	r3, #0
 2646              	.L94:
 2647              		.loc 1 1108 0 discriminator 3
 2648 004a DBB2     		uxtb	r3, r3
1109:../Generated_Code/UTIL1.c **** }
 2649              		.loc 1 1109 0 is_stmt 1 discriminator 3
 2650 004c 181C     		mov	r0, r3
 2651 004e BD46     		mov	sp, r7
 2652 0050 02B0     		add	sp, sp, #8
 2653              		@ sp needed for prologue
 2654 0052 80BD     		pop	{r7, pc}
 2655              		.cfi_endproc
 2656              	.LFE28:
 2658              		.section	.text.UTIL1_WeekDay,"ax",%progbits
 2659              		.align	2
 2660              		.global	UTIL1_WeekDay
 2661              		.code	16
 2662              		.thumb_func
 2664              	UTIL1_WeekDay:
 2665              	.LFB29:
1110:../Generated_Code/UTIL1.c **** 
1111:../Generated_Code/UTIL1.c **** /*
1112:../Generated_Code/UTIL1.c **** ** ===================================================================
1113:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_WeekDay (component Utility)
1114:../Generated_Code/UTIL1.c **** **
1115:../Generated_Code/UTIL1.c **** **     Description :
1116:../Generated_Code/UTIL1.c **** **         Returns the weekday for a given date >= 1.Jan.1900
1117:../Generated_Code/UTIL1.c **** **     Parameters  :
1118:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1119:../Generated_Code/UTIL1.c **** **         year            - year in YYYY format
1120:../Generated_Code/UTIL1.c **** **         month           - month of the year (1: January, 2:
1121:../Generated_Code/UTIL1.c **** **                           February, etc)
1122:../Generated_Code/UTIL1.c **** **         day             - day of the moth (starting with 1)
1123:../Generated_Code/UTIL1.c **** **     Returns     :
1124:../Generated_Code/UTIL1.c **** **         ---             - Returns the weekday, 0 for Sunday, 1 for
1125:../Generated_Code/UTIL1.c **** **                           Monday, 2 for Tuesday, etc.
1126:../Generated_Code/UTIL1.c **** ** ===================================================================
1127:../Generated_Code/UTIL1.c **** */
1128:../Generated_Code/UTIL1.c **** byte UTIL1_WeekDay(word year, byte month, byte day)
1129:../Generated_Code/UTIL1.c **** {
 2666              		.loc 1 1129 0
 2667              		.cfi_startproc
 2668 0000 90B5     		push	{r4, r7, lr}
 2669              	.LCFI87:
 2670              		.cfi_def_cfa_offset 12
 2671              		.cfi_offset 4, -12
 2672              		.cfi_offset 7, -8
 2673              		.cfi_offset 14, -4
 2674 0002 85B0     		sub	sp, sp, #20
 2675              	.LCFI88:
 2676              		.cfi_def_cfa_offset 32
 2677 0004 00AF     		add	r7, sp, #0
 2678              	.LCFI89:
 2679              		.cfi_def_cfa_register 7
 2680 0006 BB1D     		add	r3, r7, #6
 2681 0008 1880     		strh	r0, [r3]
 2682 000a 7B1D     		add	r3, r7, #5
 2683 000c 1970     		strb	r1, [r3]
 2684 000e 3B1D     		add	r3, r7, #4
 2685 0010 1A70     		strb	r2, [r3]
1130:../Generated_Code/UTIL1.c ****   /* see http://klausler.com/new-dayofweek.html */
1131:../Generated_Code/UTIL1.c ****   static const byte skew[12] = {0,3,3,6,1,4,6,2,5,0,3,5};
1132:../Generated_Code/UTIL1.c ****   word sum;
1133:../Generated_Code/UTIL1.c **** 
1134:../Generated_Code/UTIL1.c ****   sum = (word)(year-1900);
 2686              		.loc 1 1134 0
 2687 0012 3B1C     		mov	r3, r7
 2688 0014 0E33     		add	r3, r3, #14
 2689 0016 BA1D     		add	r2, r7, #6
 2690 0018 1288     		ldrh	r2, [r2]
 2691 001a 3249     		ldr	r1, .L98
 2692 001c 5218     		add	r2, r2, r1
 2693 001e 1A80     		strh	r2, [r3]
1135:../Generated_Code/UTIL1.c ****   sum += sum/4;
 2694              		.loc 1 1135 0
 2695 0020 3B1C     		mov	r3, r7
 2696 0022 0E33     		add	r3, r3, #14
 2697 0024 1B88     		ldrh	r3, [r3]
 2698 0026 9B08     		lsr	r3, r3, #2
 2699 0028 99B2     		uxth	r1, r3
 2700 002a 3B1C     		mov	r3, r7
 2701 002c 0E33     		add	r3, r3, #14
 2702 002e 3A1C     		mov	r2, r7
 2703 0030 0E32     		add	r2, r2, #14
 2704 0032 1288     		ldrh	r2, [r2]
 2705 0034 8A18     		add	r2, r1, r2
 2706 0036 1A80     		strh	r2, [r3]
1136:../Generated_Code/UTIL1.c ****   sum %= 7;
 2707              		.loc 1 1136 0
 2708 0038 3C1C     		mov	r4, r7
 2709 003a 0E34     		add	r4, r4, #14
 2710 003c 3B1C     		mov	r3, r7
 2711 003e 0E33     		add	r3, r3, #14
 2712 0040 1B88     		ldrh	r3, [r3]
 2713 0042 181C     		mov	r0, r3
 2714 0044 0721     		mov	r1, #7
 2715 0046 FFF7FEFF 		bl	__aeabi_uidivmod
 2716 004a 0B1C     		mov	r3, r1
 2717 004c 2380     		strh	r3, [r4]
1137:../Generated_Code/UTIL1.c ****   if (UTIL1_IsLeapYear(year) && (month==1 || month==2)) {
 2718              		.loc 1 1137 0
 2719 004e BB1D     		add	r3, r7, #6
 2720 0050 1B88     		ldrh	r3, [r3]
 2721 0052 181C     		mov	r0, r3
 2722 0054 FFF7FEFF 		bl	UTIL1_IsLeapYear
 2723 0058 031C     		mov	r3, r0
 2724 005a 0ED0     		beq	.L96
 2725              		.loc 1 1137 0 is_stmt 0 discriminator 1
 2726 005c 7B1D     		add	r3, r7, #5
 2727 005e 1B78     		ldrb	r3, [r3]
 2728 0060 012B     		cmp	r3, #1
 2729 0062 03D0     		beq	.L97
 2730 0064 7B1D     		add	r3, r7, #5
 2731 0066 1B78     		ldrb	r3, [r3]
 2732 0068 022B     		cmp	r3, #2
 2733 006a 06D1     		bne	.L96
 2734              	.L97:
1138:../Generated_Code/UTIL1.c ****     sum--;
 2735              		.loc 1 1138 0 is_stmt 1
 2736 006c 3B1C     		mov	r3, r7
 2737 006e 0E33     		add	r3, r3, #14
 2738 0070 3A1C     		mov	r2, r7
 2739 0072 0E32     		add	r2, r2, #14
 2740 0074 1288     		ldrh	r2, [r2]
 2741 0076 013A     		sub	r2, r2, #1
 2742 0078 1A80     		strh	r2, [r3]
 2743              	.L96:
1139:../Generated_Code/UTIL1.c ****   }
1140:../Generated_Code/UTIL1.c ****   sum += day;
 2744              		.loc 1 1140 0
 2745 007a 3B1D     		add	r3, r7, #4
 2746 007c 1B78     		ldrb	r3, [r3]
 2747 007e 99B2     		uxth	r1, r3
 2748 0080 3B1C     		mov	r3, r7
 2749 0082 0E33     		add	r3, r3, #14
 2750 0084 3A1C     		mov	r2, r7
 2751 0086 0E32     		add	r2, r2, #14
 2752 0088 1288     		ldrh	r2, [r2]
 2753 008a 8A18     		add	r2, r1, r2
 2754 008c 1A80     		strh	r2, [r3]
1141:../Generated_Code/UTIL1.c ****   sum %= 7;
 2755              		.loc 1 1141 0
 2756 008e 3C1C     		mov	r4, r7
 2757 0090 0E34     		add	r4, r4, #14
 2758 0092 3B1C     		mov	r3, r7
 2759 0094 0E33     		add	r3, r3, #14
 2760 0096 1B88     		ldrh	r3, [r3]
 2761 0098 181C     		mov	r0, r3
 2762 009a 0721     		mov	r1, #7
 2763 009c FFF7FEFF 		bl	__aeabi_uidivmod
 2764 00a0 0B1C     		mov	r3, r1
 2765 00a2 2380     		strh	r3, [r4]
1142:../Generated_Code/UTIL1.c ****   sum += skew[month-1];
 2766              		.loc 1 1142 0
 2767 00a4 7B1D     		add	r3, r7, #5
 2768 00a6 1B78     		ldrb	r3, [r3]
 2769 00a8 013B     		sub	r3, r3, #1
 2770 00aa 0F4A     		ldr	r2, .L98+4
 2771 00ac D35C     		ldrb	r3, [r2, r3]
 2772 00ae 191C     		mov	r1, r3
 2773 00b0 3B1C     		mov	r3, r7
 2774 00b2 0E33     		add	r3, r3, #14
 2775 00b4 3A1C     		mov	r2, r7
 2776 00b6 0E32     		add	r2, r2, #14
 2777 00b8 1288     		ldrh	r2, [r2]
 2778 00ba 8A18     		add	r2, r1, r2
 2779 00bc 1A80     		strh	r2, [r3]
1143:../Generated_Code/UTIL1.c ****   sum %= 7;
 2780              		.loc 1 1143 0
 2781 00be 3C1C     		mov	r4, r7
 2782 00c0 0E34     		add	r4, r4, #14
 2783 00c2 3B1C     		mov	r3, r7
 2784 00c4 0E33     		add	r3, r3, #14
 2785 00c6 1B88     		ldrh	r3, [r3]
 2786 00c8 181C     		mov	r0, r3
 2787 00ca 0721     		mov	r1, #7
 2788 00cc FFF7FEFF 		bl	__aeabi_uidivmod
 2789 00d0 0B1C     		mov	r3, r1
 2790 00d2 2380     		strh	r3, [r4]
1144:../Generated_Code/UTIL1.c ****   return (byte)sum; /* 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, ... */
 2791              		.loc 1 1144 0
 2792 00d4 3B1C     		mov	r3, r7
 2793 00d6 0E33     		add	r3, r3, #14
 2794 00d8 1B88     		ldrh	r3, [r3]
 2795 00da DBB2     		uxtb	r3, r3
1145:../Generated_Code/UTIL1.c **** }
 2796              		.loc 1 1145 0
 2797 00dc 181C     		mov	r0, r3
 2798 00de BD46     		mov	sp, r7
 2799 00e0 05B0     		add	sp, sp, #20
 2800              		@ sp needed for prologue
 2801 00e2 90BD     		pop	{r4, r7, pc}
 2802              	.L99:
 2803              		.align	2
 2804              	.L98:
 2805 00e4 94F8FFFF 		.word	-1900
 2806 00e8 00000000 		.word	skew.6198
 2807              		.cfi_endproc
 2808              	.LFE29:
 2810              		.section	.rodata
 2811              		.align	2
 2812              	.LC1:
 2813 0000 00       		.ascii	"\000"
 2814 0001 000000   		.section	.text.UTIL1_ReadEscapedName,"ax",%progbits
 2815              		.align	2
 2816              		.global	UTIL1_ReadEscapedName
 2817              		.code	16
 2818              		.thumb_func
 2820              	UTIL1_ReadEscapedName:
 2821              	.LFB30:
1146:../Generated_Code/UTIL1.c **** 
1147:../Generated_Code/UTIL1.c **** /*
1148:../Generated_Code/UTIL1.c **** ** ===================================================================
1149:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ReadEscapedName (component Utility)
1150:../Generated_Code/UTIL1.c **** **
1151:../Generated_Code/UTIL1.c **** **     Description :
1152:../Generated_Code/UTIL1.c **** **         Scans an escaped name from a string. This is useful e.g. for
1153:../Generated_Code/UTIL1.c **** **         double quoted file names.
1154:../Generated_Code/UTIL1.c **** **     Parameters  :
1155:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1156:../Generated_Code/UTIL1.c **** **       * filename        - the name to be copied. Names may
1157:../Generated_Code/UTIL1.c **** **                           be in quoted format
1158:../Generated_Code/UTIL1.c **** **       * destname        - the destination of the copy.
1159:../Generated_Code/UTIL1.c **** **                           Names are not in quoted format. destname
1160:../Generated_Code/UTIL1.c **** **                           may be NULL to get the other return values
1161:../Generated_Code/UTIL1.c **** **                           only
1162:../Generated_Code/UTIL1.c **** **         maxlen          - length allocated for destname
1163:../Generated_Code/UTIL1.c **** **       * lenRead         - length read in filename to copy
1164:../Generated_Code/UTIL1.c **** **                           the whole name. Note that filenames maybe
1165:../Generated_Code/UTIL1.c **** **                           space terminated, so *lenRead <
1166:../Generated_Code/UTIL1.c **** **                           strlen(filename)
1167:../Generated_Code/UTIL1.c **** **         lenWritten      - the size written in destname.
1168:../Generated_Code/UTIL1.c **** **                           In case of overflows in destname,
1169:../Generated_Code/UTIL1.c **** **                           lenWritten is still increased but destname
1170:../Generated_Code/UTIL1.c **** **                           no longer written. The have the string
1171:../Generated_Code/UTIL1.c **** **                           length in these cases use strlen(destname)
1172:../Generated_Code/UTIL1.c **** **         terminators     - additional characters
1173:../Generated_Code/UTIL1.c **** **                           where a name should terminate. May be NULL
1174:../Generated_Code/UTIL1.c **** **     Returns     :
1175:../Generated_Code/UTIL1.c **** **         ---             - Error code
1176:../Generated_Code/UTIL1.c **** ** ===================================================================
1177:../Generated_Code/UTIL1.c **** */
1178:../Generated_Code/UTIL1.c **** byte UTIL1_ReadEscapedName(const unsigned char *filename, byte *destname, size_t maxlen, size_t *le
1179:../Generated_Code/UTIL1.c **** {
 2822              		.loc 1 1179 0
 2823              		.cfi_startproc
 2824 0000 80B5     		push	{r7, lr}
 2825              	.LCFI90:
 2826              		.cfi_def_cfa_offset 8
 2827              		.cfi_offset 7, -8
 2828              		.cfi_offset 14, -4
 2829 0002 88B0     		sub	sp, sp, #32
 2830              	.LCFI91:
 2831              		.cfi_def_cfa_offset 40
 2832 0004 00AF     		add	r7, sp, #0
 2833              	.LCFI92:
 2834              		.cfi_def_cfa_register 7
 2835 0006 F860     		str	r0, [r7, #12]
 2836 0008 B960     		str	r1, [r7, #8]
 2837 000a 7A60     		str	r2, [r7, #4]
 2838 000c 3B60     		str	r3, [r7]
1180:../Generated_Code/UTIL1.c ****   size_t lenCopied = 0, lenOverread = 0;
 2839              		.loc 1 1180 0
 2840 000e 0023     		mov	r3, #0
 2841 0010 FB61     		str	r3, [r7, #28]
 2842 0012 0023     		mov	r3, #0
 2843 0014 BB61     		str	r3, [r7, #24]
1181:../Generated_Code/UTIL1.c ****   bool quoteMode = FALSE;  /* quoteMode means the name is surrounded by ". In this mode, only a sec
 2844              		.loc 1 1181 0
 2845 0016 3B1C     		mov	r3, r7
 2846 0018 1733     		add	r3, r3, #23
 2847 001a 0022     		mov	r2, #0
 2848 001c 1A70     		strb	r2, [r3]
1182:../Generated_Code/UTIL1.c ****                               terminates the string. In !quoteMode a space or a '\0' may also termi
1183:../Generated_Code/UTIL1.c ****   bool res = ERR_OK;
 2849              		.loc 1 1183 0
 2850 001e 3B1C     		mov	r3, r7
 2851 0020 1633     		add	r3, r3, #22
 2852 0022 0022     		mov	r2, #0
 2853 0024 1A70     		strb	r2, [r3]
1184:../Generated_Code/UTIL1.c ****   #define IS_SPACE(ch) ((ch)==' '||(ch)=='\t'||(ch)=='\n'||(ch)=='\v'||(ch)=='\f'||(ch)=='\r')
1185:../Generated_Code/UTIL1.c **** 
1186:../Generated_Code/UTIL1.c ****   if (filename==NULL || (destname!=NULL && maxlen<=0)) {
 2854              		.loc 1 1186 0
 2855 0026 FB68     		ldr	r3, [r7, #12]
 2856 0028 002B     		cmp	r3, #0
 2857 002a 05D0     		beq	.L101
 2858              		.loc 1 1186 0 is_stmt 0 discriminator 1
 2859 002c BB68     		ldr	r3, [r7, #8]
 2860 002e 002B     		cmp	r3, #0
 2861 0030 04D0     		beq	.L102
 2862 0032 7B68     		ldr	r3, [r7, #4]
 2863 0034 002B     		cmp	r3, #0
 2864 0036 01D1     		bne	.L102
 2865              	.L101:
1187:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 2866              		.loc 1 1187 0 is_stmt 1
 2867 0038 1B23     		mov	r3, #27
 2868 003a 88E0     		b	.L103
 2869              	.L102:
1188:../Generated_Code/UTIL1.c ****   }
1189:../Generated_Code/UTIL1.c ****   if (filename[0] == '"') { /* translated mode */
 2870              		.loc 1 1189 0
 2871 003c FB68     		ldr	r3, [r7, #12]
 2872 003e 1B78     		ldrb	r3, [r3]
 2873 0040 222B     		cmp	r3, #34
 2874 0042 09D1     		bne	.L104
1190:../Generated_Code/UTIL1.c ****     filename++; /* overread '"' */
 2875              		.loc 1 1190 0
 2876 0044 FB68     		ldr	r3, [r7, #12]
 2877 0046 0133     		add	r3, r3, #1
 2878 0048 FB60     		str	r3, [r7, #12]
1191:../Generated_Code/UTIL1.c ****     lenOverread++;
 2879              		.loc 1 1191 0
 2880 004a BB69     		ldr	r3, [r7, #24]
 2881 004c 0133     		add	r3, r3, #1
 2882 004e BB61     		str	r3, [r7, #24]
1192:../Generated_Code/UTIL1.c ****     quoteMode=TRUE;
 2883              		.loc 1 1192 0
 2884 0050 3B1C     		mov	r3, r7
 2885 0052 1733     		add	r3, r3, #23
 2886 0054 0122     		mov	r2, #1
 2887 0056 1A70     		strb	r2, [r3]
 2888              	.L104:
1193:../Generated_Code/UTIL1.c ****   }
1194:../Generated_Code/UTIL1.c ****   if (terminators == NULL) {
 2889              		.loc 1 1194 0
 2890 0058 FB6A     		ldr	r3, [r7, #44]
 2891 005a 002B     		cmp	r3, #0
 2892 005c 01D1     		bne	.L105
1195:../Generated_Code/UTIL1.c ****     terminators = "";
 2893              		.loc 1 1195 0
 2894 005e 3E4B     		ldr	r3, .L116
 2895 0060 FB62     		str	r3, [r7, #44]
 2896              	.L105:
1196:../Generated_Code/UTIL1.c ****   }
1197:../Generated_Code/UTIL1.c ****   for (;;) {
1198:../Generated_Code/UTIL1.c ****     if (quoteMode) {
 2897              		.loc 1 1198 0
 2898 0062 3B1C     		mov	r3, r7
 2899 0064 1733     		add	r3, r3, #23
 2900 0066 1B78     		ldrb	r3, [r3]
 2901 0068 002B     		cmp	r3, #0
 2902 006a 16D0     		beq	.L106
1199:../Generated_Code/UTIL1.c ****       if (filename[0] == '"') {
 2903              		.loc 1 1199 0
 2904 006c FB68     		ldr	r3, [r7, #12]
 2905 006e 1B78     		ldrb	r3, [r3]
 2906 0070 222B     		cmp	r3, #34
 2907 0072 09D1     		bne	.L107
1200:../Generated_Code/UTIL1.c ****         filename++; /* overread '"' */
 2908              		.loc 1 1200 0
 2909 0074 FB68     		ldr	r3, [r7, #12]
 2910 0076 0133     		add	r3, r3, #1
 2911 0078 FB60     		str	r3, [r7, #12]
1201:../Generated_Code/UTIL1.c ****         lenOverread++;
 2912              		.loc 1 1201 0
 2913 007a BB69     		ldr	r3, [r7, #24]
 2914 007c 0133     		add	r3, r3, #1
 2915 007e BB61     		str	r3, [r7, #24]
1202:../Generated_Code/UTIL1.c ****         if (filename[0] != '"') { /* quoteMode is terminated by a single quote. A double quote is t
 2916              		.loc 1 1202 0
 2917 0080 FB68     		ldr	r3, [r7, #12]
 2918 0082 1B78     		ldrb	r3, [r3]
 2919 0084 222B     		cmp	r3, #34
 2920 0086 49D1     		bne	.L115
 2921              	.L107:
1203:../Generated_Code/UTIL1.c ****           break; /* successfully finished with this name */
1204:../Generated_Code/UTIL1.c ****         } /* else we copy the second quote " */
1205:../Generated_Code/UTIL1.c ****       }
1206:../Generated_Code/UTIL1.c ****       if (filename[0] == '\0') { /* unexpected 0. stop */
 2922              		.loc 1 1206 0
 2923 0088 FB68     		ldr	r3, [r7, #12]
 2924 008a 1B78     		ldrb	r3, [r3]
 2925 008c 002B     		cmp	r3, #0
 2926 008e 29D1     		bne	.L109
1207:../Generated_Code/UTIL1.c ****         res = ERR_FAILED;
 2927              		.loc 1 1207 0
 2928 0090 3B1C     		mov	r3, r7
 2929 0092 1633     		add	r3, r3, #22
 2930 0094 1B22     		mov	r2, #27
 2931 0096 1A70     		strb	r2, [r3]
1208:../Generated_Code/UTIL1.c ****         break; /* error case: no terminating double quote (") was found */
 2932              		.loc 1 1208 0
 2933 0098 41E0     		b	.L108
 2934              	.L106:
1209:../Generated_Code/UTIL1.c ****       }
1210:../Generated_Code/UTIL1.c ****     } else { /* copy mode */
1211:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2935              		.loc 1 1211 0
 2936 009a FB68     		ldr	r3, [r7, #12]
 2937 009c 1B78     		ldrb	r3, [r3]
 2938 009e 202B     		cmp	r3, #32
 2939 00a0 3DD0     		beq	.L108
 2940              		.loc 1 1211 0 is_stmt 0 discriminator 1
 2941 00a2 FB68     		ldr	r3, [r7, #12]
 2942 00a4 1B78     		ldrb	r3, [r3]
 2943 00a6 092B     		cmp	r3, #9
 2944 00a8 39D0     		beq	.L108
 2945 00aa FB68     		ldr	r3, [r7, #12]
 2946 00ac 1B78     		ldrb	r3, [r3]
 2947 00ae 0A2B     		cmp	r3, #10
 2948 00b0 35D0     		beq	.L108
 2949              		.loc 1 1211 0 discriminator 2
 2950 00b2 FB68     		ldr	r3, [r7, #12]
 2951 00b4 1B78     		ldrb	r3, [r3]
 2952 00b6 0B2B     		cmp	r3, #11
 2953 00b8 31D0     		beq	.L108
 2954              		.loc 1 1211 0 discriminator 3
 2955 00ba FB68     		ldr	r3, [r7, #12]
 2956 00bc 1B78     		ldrb	r3, [r3]
 2957 00be 0C2B     		cmp	r3, #12
 2958 00c0 2DD0     		beq	.L108
 2959              		.loc 1 1211 0 discriminator 4
 2960 00c2 FB68     		ldr	r3, [r7, #12]
 2961 00c4 1B78     		ldrb	r3, [r3]
 2962 00c6 0D2B     		cmp	r3, #13
 2963 00c8 29D0     		beq	.L108
 2964              		.loc 1 1211 0 discriminator 5
 2965 00ca FB68     		ldr	r3, [r7, #12]
 2966 00cc 1B78     		ldrb	r3, [r3]
 2967 00ce 002B     		cmp	r3, #0
 2968 00d0 25D0     		beq	.L108
 2969              		.loc 1 1211 0 discriminator 1
 2970 00d2 FB68     		ldr	r3, [r7, #12]
 2971 00d4 1B78     		ldrb	r3, [r3]
 2972 00d6 FA6A     		ldr	r2, [r7, #44]
 2973 00d8 101C     		mov	r0, r2
 2974 00da 191C     		mov	r1, r3
 2975 00dc FFF7FEFF 		bl	strchr
 2976 00e0 031C     		mov	r3, r0
 2977 00e2 1CD1     		bne	.L108
 2978              	.L109:
1212:../Generated_Code/UTIL1.c ****         break;
1213:../Generated_Code/UTIL1.c ****       }
1214:../Generated_Code/UTIL1.c ****     }
1215:../Generated_Code/UTIL1.c ****     if (destname != NULL) {
 2979              		.loc 1 1215 0 is_stmt 1
 2980 00e4 BB68     		ldr	r3, [r7, #8]
 2981 00e6 002B     		cmp	r3, #0
 2982 00e8 11D0     		beq	.L110
1216:../Generated_Code/UTIL1.c ****       if (lenCopied + 1 < maxlen) {
 2983              		.loc 1 1216 0
 2984 00ea FB69     		ldr	r3, [r7, #28]
 2985 00ec 5A1C     		add	r2, r3, #1
 2986 00ee 7B68     		ldr	r3, [r7, #4]
 2987 00f0 9A42     		cmp	r2, r3
 2988 00f2 07D2     		bcs	.L111
1217:../Generated_Code/UTIL1.c ****         destname[0] = filename[0];
 2989              		.loc 1 1217 0
 2990 00f4 FB68     		ldr	r3, [r7, #12]
 2991 00f6 1A78     		ldrb	r2, [r3]
 2992 00f8 BB68     		ldr	r3, [r7, #8]
 2993 00fa 1A70     		strb	r2, [r3]
1218:../Generated_Code/UTIL1.c ****         destname++;
 2994              		.loc 1 1218 0
 2995 00fc BB68     		ldr	r3, [r7, #8]
 2996 00fe 0133     		add	r3, r3, #1
 2997 0100 BB60     		str	r3, [r7, #8]
 2998 0102 04E0     		b	.L110
 2999              	.L111:
1219:../Generated_Code/UTIL1.c ****       } else {
1220:../Generated_Code/UTIL1.c ****         destname[0] = '\0'; /* terminate string */
 3000              		.loc 1 1220 0
 3001 0104 BB68     		ldr	r3, [r7, #8]
 3002 0106 0022     		mov	r2, #0
 3003 0108 1A70     		strb	r2, [r3]
1221:../Generated_Code/UTIL1.c ****         destname = NULL; /* avoid it to overwrite not allocated space */
 3004              		.loc 1 1221 0
 3005 010a 0023     		mov	r3, #0
 3006 010c BB60     		str	r3, [r7, #8]
 3007              	.L110:
1222:../Generated_Code/UTIL1.c ****       }
1223:../Generated_Code/UTIL1.c ****     }
1224:../Generated_Code/UTIL1.c ****     lenCopied++;
 3008              		.loc 1 1224 0
 3009 010e FB69     		ldr	r3, [r7, #28]
 3010 0110 0133     		add	r3, r3, #1
 3011 0112 FB61     		str	r3, [r7, #28]
1225:../Generated_Code/UTIL1.c ****     filename++;
 3012              		.loc 1 1225 0
 3013 0114 FB68     		ldr	r3, [r7, #12]
 3014 0116 0133     		add	r3, r3, #1
 3015 0118 FB60     		str	r3, [r7, #12]
1226:../Generated_Code/UTIL1.c ****   }
 3016              		.loc 1 1226 0
 3017 011a A2E7     		b	.L105
 3018              	.L115:
1203:../Generated_Code/UTIL1.c ****           break; /* successfully finished with this name */
 3019              		.loc 1 1203 0
 3020 011c C046     		mov	r8, r8
 3021              	.L108:
1227:../Generated_Code/UTIL1.c ****   if (destname != NULL) {
 3022              		.loc 1 1227 0
 3023 011e BB68     		ldr	r3, [r7, #8]
 3024 0120 002B     		cmp	r3, #0
 3025 0122 02D0     		beq	.L112
1228:../Generated_Code/UTIL1.c ****     destname[0] = '\0';
 3026              		.loc 1 1228 0
 3027 0124 BB68     		ldr	r3, [r7, #8]
 3028 0126 0022     		mov	r2, #0
 3029 0128 1A70     		strb	r2, [r3]
 3030              	.L112:
1229:../Generated_Code/UTIL1.c ****   }
1230:../Generated_Code/UTIL1.c ****   if (lenRead != NULL) {
 3031              		.loc 1 1230 0
 3032 012a 3B68     		ldr	r3, [r7]
 3033 012c 002B     		cmp	r3, #0
 3034 012e 04D0     		beq	.L113
1231:../Generated_Code/UTIL1.c ****     *lenRead = lenCopied+lenOverread;
 3035              		.loc 1 1231 0
 3036 0130 FA69     		ldr	r2, [r7, #28]
 3037 0132 BB69     		ldr	r3, [r7, #24]
 3038 0134 D218     		add	r2, r2, r3
 3039 0136 3B68     		ldr	r3, [r7]
 3040 0138 1A60     		str	r2, [r3]
 3041              	.L113:
1232:../Generated_Code/UTIL1.c ****   }
1233:../Generated_Code/UTIL1.c ****   if (lenWritten != NULL) {
 3042              		.loc 1 1233 0
 3043 013a BB6A     		ldr	r3, [r7, #40]
 3044 013c 002B     		cmp	r3, #0
 3045 013e 03D0     		beq	.L114
1234:../Generated_Code/UTIL1.c ****     *lenWritten = lenCopied + 1; /* additionally a zero byte written */
 3046              		.loc 1 1234 0
 3047 0140 FB69     		ldr	r3, [r7, #28]
 3048 0142 5A1C     		add	r2, r3, #1
 3049 0144 BB6A     		ldr	r3, [r7, #40]
 3050 0146 1A60     		str	r2, [r3]
 3051              	.L114:
1235:../Generated_Code/UTIL1.c ****   }
1236:../Generated_Code/UTIL1.c ****   return res;
 3052              		.loc 1 1236 0
 3053 0148 3B1C     		mov	r3, r7
 3054 014a 1633     		add	r3, r3, #22
 3055 014c 1B78     		ldrb	r3, [r3]
 3056              	.L103:
1237:../Generated_Code/UTIL1.c **** }
 3057              		.loc 1 1237 0
 3058 014e 181C     		mov	r0, r3
 3059 0150 BD46     		mov	sp, r7
 3060 0152 08B0     		add	sp, sp, #32
 3061              		@ sp needed for prologue
 3062 0154 80BD     		pop	{r7, pc}
 3063              	.L117:
 3064 0156 C046     		.align	2
 3065              	.L116:
 3066 0158 00000000 		.word	.LC1
 3067              		.cfi_endproc
 3068              	.LFE30:
 3070              		.section	.text.UTIL1_xatoi,"ax",%progbits
 3071              		.align	2
 3072              		.global	UTIL1_xatoi
 3073              		.code	16
 3074              		.thumb_func
 3076              	UTIL1_xatoi:
 3077              	.LFB31:
1238:../Generated_Code/UTIL1.c **** 
1239:../Generated_Code/UTIL1.c **** /*
1240:../Generated_Code/UTIL1.c **** ** ===================================================================
1241:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_xatoi (component Utility)
1242:../Generated_Code/UTIL1.c **** **
1243:../Generated_Code/UTIL1.c **** **     Description :
1244:../Generated_Code/UTIL1.c **** **         Custom atoi() (ascii to int) implementation by Elm Chan
1245:../Generated_Code/UTIL1.c **** **     Parameters  :
1246:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1247:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string to scan. Returns until
1248:../Generated_Code/UTIL1.c **** **                           where it has scanned.
1249:../Generated_Code/UTIL1.c **** **       * res             - Pointer to where to store the result
1250:../Generated_Code/UTIL1.c **** **     Returns     :
1251:../Generated_Code/UTIL1.c **** **         ---             - Error code
1252:../Generated_Code/UTIL1.c **** ** ===================================================================
1253:../Generated_Code/UTIL1.c **** */
1254:../Generated_Code/UTIL1.c **** /*------------------------------------------------------------------------/
1255:../Generated_Code/UTIL1.c **** /  Universal string handler for user console interface
1256:../Generated_Code/UTIL1.c **** /-------------------------------------------------------------------------/
1257:../Generated_Code/UTIL1.c **** /
1258:../Generated_Code/UTIL1.c **** /  Copyright (C) 2010, ChaN, all right reserved.
1259:../Generated_Code/UTIL1.c **** /
1260:../Generated_Code/UTIL1.c **** / * This software is a free software and there is NO WARRANTY.
1261:../Generated_Code/UTIL1.c **** / * No restriction on use. You can use, modify and redistribute it for
1262:../Generated_Code/UTIL1.c **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
1263:../Generated_Code/UTIL1.c **** / * Redistributions of source code must retain the above copyright notice.
1264:../Generated_Code/UTIL1.c **** /
1265:../Generated_Code/UTIL1.c **** /-------------------------------------------------------------------------*/
1266:../Generated_Code/UTIL1.c **** #ifdef __HC12__
1267:../Generated_Code/UTIL1.c ****   #pragma MESSAGE DISABLE C12056  /* message about SP debug info */
1268:../Generated_Code/UTIL1.c **** #endif
1269:../Generated_Code/UTIL1.c **** byte UTIL1_xatoi(const unsigned char **str, long *res)
1270:../Generated_Code/UTIL1.c **** {
 3078              		.loc 1 1270 0
 3079              		.cfi_startproc
 3080 0000 80B5     		push	{r7, lr}
 3081              	.LCFI93:
 3082              		.cfi_def_cfa_offset 8
 3083              		.cfi_offset 7, -8
 3084              		.cfi_offset 14, -4
 3085 0002 84B0     		sub	sp, sp, #16
 3086              	.LCFI94:
 3087              		.cfi_def_cfa_offset 24
 3088 0004 00AF     		add	r7, sp, #0
 3089              	.LCFI95:
 3090              		.cfi_def_cfa_register 7
 3091 0006 7860     		str	r0, [r7, #4]
 3092 0008 3960     		str	r1, [r7]
1271:../Generated_Code/UTIL1.c **** /* 123 -5   0x3ff 0b1111 0377 3.25  w "
1272:../Generated_Code/UTIL1.c ****       ^                               1st call returns 123 and next ptr
1273:../Generated_Code/UTIL1.c ****          ^                            2nd call returns -5 and next ptr
1274:../Generated_Code/UTIL1.c ****                  ^                    3rd call returns 1023 and next ptr
1275:../Generated_Code/UTIL1.c ****                         ^             4th call returns 15 and next ptr
1276:../Generated_Code/UTIL1.c ****                              ^        5th call returns 255 and next ptr
1277:../Generated_Code/UTIL1.c ****                                ^      6th call returns 3 and next ptr, caller needs to read '.'
1278:../Generated_Code/UTIL1.c ****                                  ^    7th call returns 25 and next ptr
1279:../Generated_Code/UTIL1.c ****                                     ^ 8th call fails and returns ERR_FAILED
1280:../Generated_Code/UTIL1.c **** */
1281:../Generated_Code/UTIL1.c ****   unsigned long val;
1282:../Generated_Code/UTIL1.c ****   unsigned char c, r, s = 0;
 3093              		.loc 1 1282 0
 3094 000a 3B1C     		mov	r3, r7
 3095 000c 0933     		add	r3, r3, #9
 3096 000e 0022     		mov	r2, #0
 3097 0010 1A70     		strb	r2, [r3]
1283:../Generated_Code/UTIL1.c **** 
1284:../Generated_Code/UTIL1.c ****   *res = 0;
 3098              		.loc 1 1284 0
 3099 0012 3B68     		ldr	r3, [r7]
 3100 0014 0022     		mov	r2, #0
 3101 0016 1A60     		str	r2, [r3]
1285:../Generated_Code/UTIL1.c ****   while (**str==' ') {
 3102              		.loc 1 1285 0
 3103 0018 04E0     		b	.L119
 3104              	.L120:
1286:../Generated_Code/UTIL1.c ****     (*str)++;                          /* Skip leading spaces */
 3105              		.loc 1 1286 0
 3106 001a 7B68     		ldr	r3, [r7, #4]
 3107 001c 1B68     		ldr	r3, [r3]
 3108 001e 5A1C     		add	r2, r3, #1
 3109 0020 7B68     		ldr	r3, [r7, #4]
 3110 0022 1A60     		str	r2, [r3]
 3111              	.L119:
1285:../Generated_Code/UTIL1.c ****   while (**str==' ') {
 3112              		.loc 1 1285 0 discriminator 1
 3113 0024 7B68     		ldr	r3, [r7, #4]
 3114 0026 1B68     		ldr	r3, [r3]
 3115 0028 1B78     		ldrb	r3, [r3]
 3116 002a 202B     		cmp	r3, #32
 3117 002c F5D0     		beq	.L120
1287:../Generated_Code/UTIL1.c ****   }
1288:../Generated_Code/UTIL1.c ****   c = **str;
 3118              		.loc 1 1288 0
 3119 002e 7B68     		ldr	r3, [r7, #4]
 3120 0030 1A68     		ldr	r2, [r3]
 3121 0032 3B1C     		mov	r3, r7
 3122 0034 0B33     		add	r3, r3, #11
 3123 0036 1278     		ldrb	r2, [r2]
 3124 0038 1A70     		strb	r2, [r3]
1289:../Generated_Code/UTIL1.c ****   if (c == '-') {                      /* negative? */
 3125              		.loc 1 1289 0
 3126 003a 3B1C     		mov	r3, r7
 3127 003c 0B33     		add	r3, r3, #11
 3128 003e 1B78     		ldrb	r3, [r3]
 3129 0040 2D2B     		cmp	r3, #45
 3130 0042 0ED1     		bne	.L121
1290:../Generated_Code/UTIL1.c ****     s = 1;
 3131              		.loc 1 1290 0
 3132 0044 3B1C     		mov	r3, r7
 3133 0046 0933     		add	r3, r3, #9
 3134 0048 0122     		mov	r2, #1
 3135 004a 1A70     		strb	r2, [r3]
1291:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 3136              		.loc 1 1291 0
 3137 004c 7B68     		ldr	r3, [r7, #4]
 3138 004e 1B68     		ldr	r3, [r3]
 3139 0050 5A1C     		add	r2, r3, #1
 3140 0052 7B68     		ldr	r3, [r7, #4]
 3141 0054 1A60     		str	r2, [r3]
 3142 0056 7B68     		ldr	r3, [r7, #4]
 3143 0058 1A68     		ldr	r2, [r3]
 3144 005a 3B1C     		mov	r3, r7
 3145 005c 0B33     		add	r3, r3, #11
 3146 005e 1278     		ldrb	r2, [r2]
 3147 0060 1A70     		strb	r2, [r3]
 3148              	.L121:
1292:../Generated_Code/UTIL1.c ****   }
1293:../Generated_Code/UTIL1.c ****   if (c == '0') {
 3149              		.loc 1 1293 0
 3150 0062 3B1C     		mov	r3, r7
 3151 0064 0B33     		add	r3, r3, #11
 3152 0066 1B78     		ldrb	r3, [r3]
 3153 0068 302B     		cmp	r3, #48
 3154 006a 4FD1     		bne	.L122
1294:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 3155              		.loc 1 1294 0
 3156 006c 7B68     		ldr	r3, [r7, #4]
 3157 006e 1B68     		ldr	r3, [r3]
 3158 0070 5A1C     		add	r2, r3, #1
 3159 0072 7B68     		ldr	r3, [r7, #4]
 3160 0074 1A60     		str	r2, [r3]
 3161 0076 7B68     		ldr	r3, [r7, #4]
 3162 0078 1A68     		ldr	r2, [r3]
 3163 007a 3B1C     		mov	r3, r7
 3164 007c 0B33     		add	r3, r3, #11
 3165 007e 1278     		ldrb	r2, [r2]
 3166 0080 1A70     		strb	r2, [r3]
1295:../Generated_Code/UTIL1.c ****     switch (c) {
 3167              		.loc 1 1295 0
 3168 0082 3B1C     		mov	r3, r7
 3169 0084 0B33     		add	r3, r3, #11
 3170 0086 1B78     		ldrb	r3, [r3]
 3171 0088 622B     		cmp	r3, #98
 3172 008a 11D0     		beq	.L124
 3173 008c 782B     		cmp	r3, #120
 3174 008e 20D1     		bne	.L142
 3175              	.L125:
1296:../Generated_Code/UTIL1.c ****       case 'x':                        /* hexadecimal */
1297:../Generated_Code/UTIL1.c ****         r = 16; c = *(++(*str));
 3176              		.loc 1 1297 0
 3177 0090 3B1C     		mov	r3, r7
 3178 0092 0A33     		add	r3, r3, #10
 3179 0094 1022     		mov	r2, #16
 3180 0096 1A70     		strb	r2, [r3]
 3181 0098 7B68     		ldr	r3, [r7, #4]
 3182 009a 1B68     		ldr	r3, [r3]
 3183 009c 5A1C     		add	r2, r3, #1
 3184 009e 7B68     		ldr	r3, [r7, #4]
 3185 00a0 1A60     		str	r2, [r3]
 3186 00a2 7B68     		ldr	r3, [r7, #4]
 3187 00a4 1A68     		ldr	r2, [r3]
 3188 00a6 3B1C     		mov	r3, r7
 3189 00a8 0B33     		add	r3, r3, #11
 3190 00aa 1278     		ldrb	r2, [r2]
 3191 00ac 1A70     		strb	r2, [r3]
1298:../Generated_Code/UTIL1.c ****         break;
 3192              		.loc 1 1298 0
 3193 00ae 3DE0     		b	.L132
 3194              	.L124:
1299:../Generated_Code/UTIL1.c ****       case 'b':                        /* binary */
1300:../Generated_Code/UTIL1.c ****         r = 2; c = *(++(*str));
 3195              		.loc 1 1300 0
 3196 00b0 3B1C     		mov	r3, r7
 3197 00b2 0A33     		add	r3, r3, #10
 3198 00b4 0222     		mov	r2, #2
 3199 00b6 1A70     		strb	r2, [r3]
 3200 00b8 7B68     		ldr	r3, [r7, #4]
 3201 00ba 1B68     		ldr	r3, [r3]
 3202 00bc 5A1C     		add	r2, r3, #1
 3203 00be 7B68     		ldr	r3, [r7, #4]
 3204 00c0 1A60     		str	r2, [r3]
 3205 00c2 7B68     		ldr	r3, [r7, #4]
 3206 00c4 1A68     		ldr	r2, [r3]
 3207 00c6 3B1C     		mov	r3, r7
 3208 00c8 0B33     		add	r3, r3, #11
 3209 00ca 1278     		ldrb	r2, [r2]
 3210 00cc 1A70     		strb	r2, [r3]
1301:../Generated_Code/UTIL1.c ****         break;
 3211              		.loc 1 1301 0
 3212 00ce C046     		mov	r8, r8
 3213 00d0 2CE0     		b	.L132
 3214              	.L142:
1302:../Generated_Code/UTIL1.c ****       default:
1303:../Generated_Code/UTIL1.c ****         if (c <= ' ' || c == '.') {
 3215              		.loc 1 1303 0
 3216 00d2 3B1C     		mov	r3, r7
 3217 00d4 0B33     		add	r3, r3, #11
 3218 00d6 1B78     		ldrb	r3, [r3]
 3219 00d8 202B     		cmp	r3, #32
 3220 00da 04D9     		bls	.L127
 3221              		.loc 1 1303 0 is_stmt 0 discriminator 1
 3222 00dc 3B1C     		mov	r3, r7
 3223 00de 0B33     		add	r3, r3, #11
 3224 00e0 1B78     		ldrb	r3, [r3]
 3225 00e2 2E2B     		cmp	r3, #46
 3226 00e4 01D1     		bne	.L128
 3227              	.L127:
1304:../Generated_Code/UTIL1.c ****           return ERR_OK;               /* single zero */
 3228              		.loc 1 1304 0 is_stmt 1
 3229 00e6 0023     		mov	r3, #0
 3230 00e8 7EE0     		b	.L129
 3231              	.L128:
1305:../Generated_Code/UTIL1.c ****         }
1306:../Generated_Code/UTIL1.c ****         if (c < '0' || c > '9') {
 3232              		.loc 1 1306 0
 3233 00ea 3B1C     		mov	r3, r7
 3234 00ec 0B33     		add	r3, r3, #11
 3235 00ee 1B78     		ldrb	r3, [r3]
 3236 00f0 2F2B     		cmp	r3, #47
 3237 00f2 04D9     		bls	.L130
 3238              		.loc 1 1306 0 is_stmt 0 discriminator 1
 3239 00f4 3B1C     		mov	r3, r7
 3240 00f6 0B33     		add	r3, r3, #11
 3241 00f8 1B78     		ldrb	r3, [r3]
 3242 00fa 392B     		cmp	r3, #57
 3243 00fc 01D9     		bls	.L131
 3244              	.L130:
1307:../Generated_Code/UTIL1.c ****           return ERR_FAILED;           /* invalid char */
 3245              		.loc 1 1307 0 is_stmt 1
 3246 00fe 1B23     		mov	r3, #27
 3247 0100 72E0     		b	.L129
 3248              	.L131:
1308:../Generated_Code/UTIL1.c ****         }
1309:../Generated_Code/UTIL1.c ****         r = 8;                         /* octal */
 3249              		.loc 1 1309 0
 3250 0102 3B1C     		mov	r3, r7
 3251 0104 0A33     		add	r3, r3, #10
 3252 0106 0822     		mov	r2, #8
 3253 0108 1A70     		strb	r2, [r3]
1310:../Generated_Code/UTIL1.c ****         break;
 3254              		.loc 1 1310 0
 3255 010a 0FE0     		b	.L132
 3256              	.L122:
1311:../Generated_Code/UTIL1.c ****     } /* switch */
1312:../Generated_Code/UTIL1.c ****   } else {
1313:../Generated_Code/UTIL1.c ****     if (c < '0' || c > '9') {
 3257              		.loc 1 1313 0
 3258 010c 3B1C     		mov	r3, r7
 3259 010e 0B33     		add	r3, r3, #11
 3260 0110 1B78     		ldrb	r3, [r3]
 3261 0112 2F2B     		cmp	r3, #47
 3262 0114 04D9     		bls	.L133
 3263              		.loc 1 1313 0 is_stmt 0 discriminator 1
 3264 0116 3B1C     		mov	r3, r7
 3265 0118 0B33     		add	r3, r3, #11
 3266 011a 1B78     		ldrb	r3, [r3]
 3267 011c 392B     		cmp	r3, #57
 3268 011e 01D9     		bls	.L134
 3269              	.L133:
1314:../Generated_Code/UTIL1.c ****       return ERR_FAILED;               /* EOL or invalid char */
 3270              		.loc 1 1314 0 is_stmt 1
 3271 0120 1B23     		mov	r3, #27
 3272 0122 61E0     		b	.L129
 3273              	.L134:
1315:../Generated_Code/UTIL1.c ****     }
1316:../Generated_Code/UTIL1.c ****     r = 10;                            /* decimal */
 3274              		.loc 1 1316 0
 3275 0124 3B1C     		mov	r3, r7
 3276 0126 0A33     		add	r3, r3, #10
 3277 0128 0A22     		mov	r2, #10
 3278 012a 1A70     		strb	r2, [r3]
 3279              	.L132:
1317:../Generated_Code/UTIL1.c ****   }
1318:../Generated_Code/UTIL1.c ****   val = 0;
 3280              		.loc 1 1318 0
 3281 012c 0023     		mov	r3, #0
 3282 012e FB60     		str	r3, [r7, #12]
1319:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
 3283              		.loc 1 1319 0
 3284 0130 44E0     		b	.L135
 3285              	.L140:
1320:../Generated_Code/UTIL1.c ****     if (c >= 'a') c -= 0x20;
 3286              		.loc 1 1320 0
 3287 0132 3B1C     		mov	r3, r7
 3288 0134 0B33     		add	r3, r3, #11
 3289 0136 1B78     		ldrb	r3, [r3]
 3290 0138 602B     		cmp	r3, #96
 3291 013a 06D9     		bls	.L136
 3292              		.loc 1 1320 0 is_stmt 0 discriminator 1
 3293 013c 3B1C     		mov	r3, r7
 3294 013e 0B33     		add	r3, r3, #11
 3295 0140 3A1C     		mov	r2, r7
 3296 0142 0B32     		add	r2, r2, #11
 3297 0144 1278     		ldrb	r2, [r2]
 3298 0146 203A     		sub	r2, r2, #32
 3299 0148 1A70     		strb	r2, [r3]
 3300              	.L136:
1321:../Generated_Code/UTIL1.c ****     c -= '0';
 3301              		.loc 1 1321 0 is_stmt 1
 3302 014a 3B1C     		mov	r3, r7
 3303 014c 0B33     		add	r3, r3, #11
 3304 014e 3A1C     		mov	r2, r7
 3305 0150 0B32     		add	r2, r2, #11
 3306 0152 1278     		ldrb	r2, [r2]
 3307 0154 303A     		sub	r2, r2, #48
 3308 0156 1A70     		strb	r2, [r3]
1322:../Generated_Code/UTIL1.c ****     if (c >= 17) {
 3309              		.loc 1 1322 0
 3310 0158 3B1C     		mov	r3, r7
 3311 015a 0B33     		add	r3, r3, #11
 3312 015c 1B78     		ldrb	r3, [r3]
 3313 015e 102B     		cmp	r3, #16
 3314 0160 0DD9     		bls	.L137
1323:../Generated_Code/UTIL1.c ****       c -= 7;
 3315              		.loc 1 1323 0
 3316 0162 3B1C     		mov	r3, r7
 3317 0164 0B33     		add	r3, r3, #11
 3318 0166 3A1C     		mov	r2, r7
 3319 0168 0B32     		add	r2, r2, #11
 3320 016a 1278     		ldrb	r2, [r2]
 3321 016c 073A     		sub	r2, r2, #7
 3322 016e 1A70     		strb	r2, [r3]
1324:../Generated_Code/UTIL1.c ****       if (c <= 9) return ERR_FAILED;   /* invalid char */
 3323              		.loc 1 1324 0
 3324 0170 3B1C     		mov	r3, r7
 3325 0172 0B33     		add	r3, r3, #11
 3326 0174 1B78     		ldrb	r3, [r3]
 3327 0176 092B     		cmp	r3, #9
 3328 0178 01D8     		bhi	.L137
 3329              		.loc 1 1324 0 is_stmt 0 discriminator 1
 3330 017a 1B23     		mov	r3, #27
 3331 017c 34E0     		b	.L129
 3332              	.L137:
1325:../Generated_Code/UTIL1.c ****     }
1326:../Generated_Code/UTIL1.c ****     if (c >= r) return ERR_FAILED;     /* invalid char for current radix */
 3333              		.loc 1 1326 0 is_stmt 1
 3334 017e 3A1C     		mov	r2, r7
 3335 0180 0B32     		add	r2, r2, #11
 3336 0182 3B1C     		mov	r3, r7
 3337 0184 0A33     		add	r3, r3, #10
 3338 0186 1278     		ldrb	r2, [r2]
 3339 0188 1B78     		ldrb	r3, [r3]
 3340 018a 9A42     		cmp	r2, r3
 3341 018c 01D3     		bcc	.L138
 3342              		.loc 1 1326 0 is_stmt 0 discriminator 1
 3343 018e 1B23     		mov	r3, #27
 3344 0190 2AE0     		b	.L129
 3345              	.L138:
1327:../Generated_Code/UTIL1.c ****     val = val * r + c;
 3346              		.loc 1 1327 0 is_stmt 1
 3347 0192 3B1C     		mov	r3, r7
 3348 0194 0A33     		add	r3, r3, #10
 3349 0196 1B78     		ldrb	r3, [r3]
 3350 0198 FA68     		ldr	r2, [r7, #12]
 3351 019a 5A43     		mul	r2, r3
 3352 019c 3B1C     		mov	r3, r7
 3353 019e 0B33     		add	r3, r3, #11
 3354 01a0 1B78     		ldrb	r3, [r3]
 3355 01a2 D318     		add	r3, r2, r3
 3356 01a4 FB60     		str	r3, [r7, #12]
1328:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 3357              		.loc 1 1328 0
 3358 01a6 7B68     		ldr	r3, [r7, #4]
 3359 01a8 1B68     		ldr	r3, [r3]
 3360 01aa 5A1C     		add	r2, r3, #1
 3361 01ac 7B68     		ldr	r3, [r7, #4]
 3362 01ae 1A60     		str	r2, [r3]
 3363 01b0 7B68     		ldr	r3, [r7, #4]
 3364 01b2 1A68     		ldr	r2, [r3]
 3365 01b4 3B1C     		mov	r3, r7
 3366 01b6 0B33     		add	r3, r3, #11
 3367 01b8 1278     		ldrb	r2, [r2]
 3368 01ba 1A70     		strb	r2, [r3]
 3369              	.L135:
1319:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
 3370              		.loc 1 1319 0 discriminator 1
 3371 01bc 3B1C     		mov	r3, r7
 3372 01be 0B33     		add	r3, r3, #11
 3373 01c0 1B78     		ldrb	r3, [r3]
 3374 01c2 202B     		cmp	r3, #32
 3375 01c4 04D9     		bls	.L139
1319:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
 3376              		.loc 1 1319 0 is_stmt 0 discriminator 2
 3377 01c6 3B1C     		mov	r3, r7
 3378 01c8 0B33     		add	r3, r3, #11
 3379 01ca 1B78     		ldrb	r3, [r3]
 3380 01cc 2E2B     		cmp	r3, #46
 3381 01ce B0D1     		bne	.L140
 3382              	.L139:
1329:../Generated_Code/UTIL1.c ****   } /* while */
1330:../Generated_Code/UTIL1.c ****   if (s) val = 0 - val;                /* apply sign if needed */
 3383              		.loc 1 1330 0 is_stmt 1
 3384 01d0 3B1C     		mov	r3, r7
 3385 01d2 0933     		add	r3, r3, #9
 3386 01d4 1B78     		ldrb	r3, [r3]
 3387 01d6 002B     		cmp	r3, #0
 3388 01d8 02D0     		beq	.L141
 3389              		.loc 1 1330 0 is_stmt 0 discriminator 1
 3390 01da FB68     		ldr	r3, [r7, #12]
 3391 01dc 5B42     		neg	r3, r3
 3392 01de FB60     		str	r3, [r7, #12]
 3393              	.L141:
1331:../Generated_Code/UTIL1.c ****   *res = (long)val;
 3394              		.loc 1 1331 0 is_stmt 1
 3395 01e0 FA68     		ldr	r2, [r7, #12]
 3396 01e2 3B68     		ldr	r3, [r7]
 3397 01e4 1A60     		str	r2, [r3]
1332:../Generated_Code/UTIL1.c ****   return ERR_OK;
 3398              		.loc 1 1332 0
 3399 01e6 0023     		mov	r3, #0
 3400              	.L129:
1333:../Generated_Code/UTIL1.c **** }
 3401              		.loc 1 1333 0
 3402 01e8 181C     		mov	r0, r3
 3403 01ea BD46     		mov	sp, r7
 3404 01ec 04B0     		add	sp, sp, #16
 3405              		@ sp needed for prologue
 3406 01ee 80BD     		pop	{r7, pc}
 3407              		.cfi_endproc
 3408              	.LFE31:
 3410              		.section	.text.UTIL1_ScanDate,"ax",%progbits
 3411              		.align	2
 3412              		.global	UTIL1_ScanDate
 3413              		.code	16
 3414              		.thumb_func
 3416              	UTIL1_ScanDate:
 3417              	.LFB32:
1334:../Generated_Code/UTIL1.c **** #ifdef __HC12__
1335:../Generated_Code/UTIL1.c ****   #pragma MESSAGE DEFAULT C12056  /* message about SP debug info */
1336:../Generated_Code/UTIL1.c **** #endif
1337:../Generated_Code/UTIL1.c **** 
1338:../Generated_Code/UTIL1.c **** /*
1339:../Generated_Code/UTIL1.c **** ** ===================================================================
1340:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDate (component Utility)
1341:../Generated_Code/UTIL1.c **** **
1342:../Generated_Code/UTIL1.c **** **     Description :
1343:../Generated_Code/UTIL1.c **** **         Scans a date in the format "dd.mm.yyyy" or "dd-mm-yyyy". For
1344:../Generated_Code/UTIL1.c **** **         yy it will expand it to 20yy.
1345:../Generated_Code/UTIL1.c **** **     Parameters  :
1346:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1347:../Generated_Code/UTIL1.c **** **       * str             - Pointer to the string to be scanned. The
1348:../Generated_Code/UTIL1.c **** **                           function advances the pointer.
1349:../Generated_Code/UTIL1.c **** **       * day             - Pointer to where to store the day value
1350:../Generated_Code/UTIL1.c **** **       * month           - Pointer to where to store the month
1351:../Generated_Code/UTIL1.c **** **                           value
1352:../Generated_Code/UTIL1.c **** **       * year            - Pointer to where to store the year value
1353:../Generated_Code/UTIL1.c **** **     Returns     :
1354:../Generated_Code/UTIL1.c **** **         ---             - Error code
1355:../Generated_Code/UTIL1.c **** ** ===================================================================
1356:../Generated_Code/UTIL1.c **** */
1357:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDate(const unsigned char **str, byte *day, byte *month, word *year)
1358:../Generated_Code/UTIL1.c **** {
 3418              		.loc 1 1358 0
 3419              		.cfi_startproc
 3420 0000 80B5     		push	{r7, lr}
 3421              	.LCFI96:
 3422              		.cfi_def_cfa_offset 8
 3423              		.cfi_offset 7, -8
 3424              		.cfi_offset 14, -4
 3425 0002 86B0     		sub	sp, sp, #24
 3426              	.LCFI97:
 3427              		.cfi_def_cfa_offset 32
 3428 0004 00AF     		add	r7, sp, #0
 3429              	.LCFI98:
 3430              		.cfi_def_cfa_register 7
 3431 0006 F860     		str	r0, [r7, #12]
 3432 0008 B960     		str	r1, [r7, #8]
 3433 000a 7A60     		str	r2, [r7, #4]
 3434 000c 3B60     		str	r3, [r7]
1359:../Generated_Code/UTIL1.c ****   /* precondition: string points to starting of date, e.g. "01.01.10" or "12.5.2010", and date is i
1360:../Generated_Code/UTIL1.c ****   const unsigned char *p;
1361:../Generated_Code/UTIL1.c **** 
1362:../Generated_Code/UTIL1.c ****   p = *str;
 3435              		.loc 1 1362 0
 3436 000e FB68     		ldr	r3, [r7, #12]
 3437 0010 1B68     		ldr	r3, [r3]
 3438 0012 7B61     		str	r3, [r7, #20]
1363:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 3439              		.loc 1 1363 0
 3440 0014 02E0     		b	.L144
 3441              	.L145:
1364:../Generated_Code/UTIL1.c ****     p++; /* skip leading spaces */
 3442              		.loc 1 1364 0
 3443 0016 7B69     		ldr	r3, [r7, #20]
 3444 0018 0133     		add	r3, r3, #1
 3445 001a 7B61     		str	r3, [r7, #20]
 3446              	.L144:
1363:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 3447              		.loc 1 1363 0 discriminator 1
 3448 001c 7B69     		ldr	r3, [r7, #20]
 3449 001e 1B78     		ldrb	r3, [r3]
 3450 0020 202B     		cmp	r3, #32
 3451 0022 F8D0     		beq	.L145
1365:../Generated_Code/UTIL1.c ****   }
1366:../Generated_Code/UTIL1.c ****   if (   UTIL1_ScanDecimal8uNumber(&p, day)==ERR_OK
 3452              		.loc 1 1366 0
 3453 0024 3A1C     		mov	r2, r7
 3454 0026 1432     		add	r2, r2, #20
 3455 0028 BB68     		ldr	r3, [r7, #8]
 3456 002a 101C     		mov	r0, r2
 3457 002c 191C     		mov	r1, r3
 3458 002e FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3459 0032 031C     		mov	r3, r0
 3460 0034 51D1     		bne	.L146
1367:../Generated_Code/UTIL1.c ****       && *day > 0 && *day <= 31
 3461              		.loc 1 1367 0
 3462 0036 BB68     		ldr	r3, [r7, #8]
 3463 0038 1B78     		ldrb	r3, [r3]
 3464 003a 002B     		cmp	r3, #0
 3465 003c 4DD0     		beq	.L146
 3466              		.loc 1 1367 0 is_stmt 0 discriminator 1
 3467 003e BB68     		ldr	r3, [r7, #8]
 3468 0040 1B78     		ldrb	r3, [r3]
 3469 0042 1F2B     		cmp	r3, #31
 3470 0044 49D8     		bhi	.L146
1368:../Generated_Code/UTIL1.c ****       && (*p=='.' || *p=='-')
 3471              		.loc 1 1368 0 is_stmt 1
 3472 0046 7B69     		ldr	r3, [r7, #20]
 3473 0048 1B78     		ldrb	r3, [r3]
 3474 004a 2E2B     		cmp	r3, #46
 3475 004c 03D0     		beq	.L147
 3476              		.loc 1 1368 0 is_stmt 0 discriminator 1
 3477 004e 7B69     		ldr	r3, [r7, #20]
 3478 0050 1B78     		ldrb	r3, [r3]
 3479 0052 2D2B     		cmp	r3, #45
 3480 0054 41D1     		bne	.L146
 3481              	.L147:
1369:../Generated_Code/UTIL1.c ****      )
1370:../Generated_Code/UTIL1.c ****   {
1371:../Generated_Code/UTIL1.c ****     p++;
 3482              		.loc 1 1371 0 is_stmt 1
 3483 0056 7B69     		ldr	r3, [r7, #20]
 3484 0058 0133     		add	r3, r3, #1
 3485 005a 7B61     		str	r3, [r7, #20]
1372:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, month)==ERR_OK
 3486              		.loc 1 1372 0
 3487 005c 3A1C     		mov	r2, r7
 3488 005e 1432     		add	r2, r2, #20
 3489 0060 7B68     		ldr	r3, [r7, #4]
 3490 0062 101C     		mov	r0, r2
 3491 0064 191C     		mov	r1, r3
 3492 0066 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3493 006a 031C     		mov	r3, r0
 3494 006c 35D1     		bne	.L146
1373:../Generated_Code/UTIL1.c ****         && *month > 0 && *month <= 12
 3495              		.loc 1 1373 0
 3496 006e 7B68     		ldr	r3, [r7, #4]
 3497 0070 1B78     		ldrb	r3, [r3]
 3498 0072 002B     		cmp	r3, #0
 3499 0074 31D0     		beq	.L146
 3500              		.loc 1 1373 0 is_stmt 0 discriminator 1
 3501 0076 7B68     		ldr	r3, [r7, #4]
 3502 0078 1B78     		ldrb	r3, [r3]
 3503 007a 0C2B     		cmp	r3, #12
 3504 007c 2DD8     		bhi	.L146
1374:../Generated_Code/UTIL1.c ****         && (*p=='.' || *p=='-')
 3505              		.loc 1 1374 0 is_stmt 1
 3506 007e 7B69     		ldr	r3, [r7, #20]
 3507 0080 1B78     		ldrb	r3, [r3]
 3508 0082 2E2B     		cmp	r3, #46
 3509 0084 03D0     		beq	.L148
 3510              		.loc 1 1374 0 is_stmt 0 discriminator 1
 3511 0086 7B69     		ldr	r3, [r7, #20]
 3512 0088 1B78     		ldrb	r3, [r3]
 3513 008a 2D2B     		cmp	r3, #45
 3514 008c 25D1     		bne	.L146
 3515              	.L148:
1375:../Generated_Code/UTIL1.c ****        )
1376:../Generated_Code/UTIL1.c ****     {
1377:../Generated_Code/UTIL1.c ****       p++;
 3516              		.loc 1 1377 0 is_stmt 1
 3517 008e 7B69     		ldr	r3, [r7, #20]
 3518 0090 0133     		add	r3, r3, #1
 3519 0092 7B61     		str	r3, [r7, #20]
1378:../Generated_Code/UTIL1.c ****       if (   UTIL1_ScanDecimal16uNumber(&p, year)==ERR_OK
 3520              		.loc 1 1378 0
 3521 0094 3A1C     		mov	r2, r7
 3522 0096 1432     		add	r2, r2, #20
 3523 0098 3B68     		ldr	r3, [r7]
 3524 009a 101C     		mov	r0, r2
 3525 009c 191C     		mov	r1, r3
 3526 009e FFF7FEFF 		bl	UTIL1_ScanDecimal16uNumber
 3527 00a2 031C     		mov	r3, r0
 3528 00a4 19D1     		bne	.L146
1379:../Generated_Code/UTIL1.c ****           && *year > 0 && *year <= 3000 /* hopefully this is enough :-) */
 3529              		.loc 1 1379 0
 3530 00a6 3B68     		ldr	r3, [r7]
 3531 00a8 1B88     		ldrh	r3, [r3]
 3532 00aa 002B     		cmp	r3, #0
 3533 00ac 15D0     		beq	.L146
 3534              		.loc 1 1379 0 is_stmt 0 discriminator 1
 3535 00ae 3B68     		ldr	r3, [r7]
 3536 00b0 1A88     		ldrh	r2, [r3]
 3537 00b2 114B     		ldr	r3, .L151
 3538 00b4 9A42     		cmp	r2, r3
 3539 00b6 10D8     		bhi	.L146
1380:../Generated_Code/UTIL1.c ****          )
1381:../Generated_Code/UTIL1.c ****       {
1382:../Generated_Code/UTIL1.c ****         if (*year < 100) {
 3540              		.loc 1 1382 0 is_stmt 1
 3541 00b8 3B68     		ldr	r3, [r7]
 3542 00ba 1B88     		ldrh	r3, [r3]
 3543 00bc 632B     		cmp	r3, #99
 3544 00be 07D8     		bhi	.L149
1383:../Generated_Code/UTIL1.c ****           *year += 2000; /* transform '10' into '2010' */
 3545              		.loc 1 1383 0
 3546 00c0 3B68     		ldr	r3, [r7]
 3547 00c2 1B88     		ldrh	r3, [r3]
 3548 00c4 FA22     		mov	r2, #250
 3549 00c6 D200     		lsl	r2, r2, #3
 3550 00c8 9B18     		add	r3, r3, r2
 3551 00ca 9AB2     		uxth	r2, r3
 3552 00cc 3B68     		ldr	r3, [r7]
 3553 00ce 1A80     		strh	r2, [r3]
 3554              	.L149:
1384:../Generated_Code/UTIL1.c ****         }
1385:../Generated_Code/UTIL1.c ****         *str = p; /* advance pointer for caller */
 3555              		.loc 1 1385 0
 3556 00d0 7A69     		ldr	r2, [r7, #20]
 3557 00d2 FB68     		ldr	r3, [r7, #12]
 3558 00d4 1A60     		str	r2, [r3]
1386:../Generated_Code/UTIL1.c ****         return ERR_OK;
 3559              		.loc 1 1386 0
 3560 00d6 0023     		mov	r3, #0
 3561 00d8 09E0     		b	.L150
 3562              	.L146:
1387:../Generated_Code/UTIL1.c ****       }
1388:../Generated_Code/UTIL1.c ****     }
1389:../Generated_Code/UTIL1.c ****   }
1390:../Generated_Code/UTIL1.c ****   *day = 0;
 3563              		.loc 1 1390 0
 3564 00da BB68     		ldr	r3, [r7, #8]
 3565 00dc 0022     		mov	r2, #0
 3566 00de 1A70     		strb	r2, [r3]
1391:../Generated_Code/UTIL1.c ****   *month = 0;
 3567              		.loc 1 1391 0
 3568 00e0 7B68     		ldr	r3, [r7, #4]
 3569 00e2 0022     		mov	r2, #0
 3570 00e4 1A70     		strb	r2, [r3]
1392:../Generated_Code/UTIL1.c ****   *year = 0;
 3571              		.loc 1 1392 0
 3572 00e6 3B68     		ldr	r3, [r7]
 3573 00e8 0022     		mov	r2, #0
 3574 00ea 1A80     		strh	r2, [r3]
1393:../Generated_Code/UTIL1.c ****   return ERR_FAILED; /* wrong format */
 3575              		.loc 1 1393 0
 3576 00ec 1B23     		mov	r3, #27
 3577              	.L150:
1394:../Generated_Code/UTIL1.c **** }
 3578              		.loc 1 1394 0
 3579 00ee 181C     		mov	r0, r3
 3580 00f0 BD46     		mov	sp, r7
 3581 00f2 06B0     		add	sp, sp, #24
 3582              		@ sp needed for prologue
 3583 00f4 80BD     		pop	{r7, pc}
 3584              	.L152:
 3585 00f6 C046     		.align	2
 3586              	.L151:
 3587 00f8 B80B0000 		.word	3000
 3588              		.cfi_endproc
 3589              	.LFE32:
 3591              		.section	.text.UTIL1_ScanTime,"ax",%progbits
 3592              		.align	2
 3593              		.global	UTIL1_ScanTime
 3594              		.code	16
 3595              		.thumb_func
 3597              	UTIL1_ScanTime:
 3598              	.LFB33:
1395:../Generated_Code/UTIL1.c **** 
1396:../Generated_Code/UTIL1.c **** /*
1397:../Generated_Code/UTIL1.c **** ** ===================================================================
1398:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanTime (component Utility)
1399:../Generated_Code/UTIL1.c **** **
1400:../Generated_Code/UTIL1.c **** **     Description :
1401:../Generated_Code/UTIL1.c **** **         Scans a time string in the format "hh:mm:ss,hh" with the
1402:../Generated_Code/UTIL1.c **** **         part for the ",hh" is optional.
1403:../Generated_Code/UTIL1.c **** **     Parameters  :
1404:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1405:../Generated_Code/UTIL1.c **** **         str             - Pointer to the string to be scanned. The
1406:../Generated_Code/UTIL1.c **** **                           function advances the pointer.
1407:../Generated_Code/UTIL1.c **** **       * hour            - Pointer to where to store the hour value
1408:../Generated_Code/UTIL1.c **** **       * minute          - Pointer to where to store the minute
1409:../Generated_Code/UTIL1.c **** **                           value
1410:../Generated_Code/UTIL1.c **** **       * second          - Pointer to where to store the second
1411:../Generated_Code/UTIL1.c **** **                           value
1412:../Generated_Code/UTIL1.c **** **       * hSecond         - Pointer to scans the hundreds of
1413:../Generated_Code/UTIL1.c **** **                           second part. If not present in string, zero
1414:../Generated_Code/UTIL1.c **** **                           is stored
1415:../Generated_Code/UTIL1.c **** **     Returns     :
1416:../Generated_Code/UTIL1.c **** **         ---             - Error code
1417:../Generated_Code/UTIL1.c **** ** ===================================================================
1418:../Generated_Code/UTIL1.c **** */
1419:../Generated_Code/UTIL1.c **** byte UTIL1_ScanTime(const unsigned char **str, byte *hour, byte *minute, byte *second, byte *hSecon
1420:../Generated_Code/UTIL1.c **** {
 3599              		.loc 1 1420 0
 3600              		.cfi_startproc
 3601 0000 80B5     		push	{r7, lr}
 3602              	.LCFI99:
 3603              		.cfi_def_cfa_offset 8
 3604              		.cfi_offset 7, -8
 3605              		.cfi_offset 14, -4
 3606 0002 86B0     		sub	sp, sp, #24
 3607              	.LCFI100:
 3608              		.cfi_def_cfa_offset 32
 3609 0004 00AF     		add	r7, sp, #0
 3610              	.LCFI101:
 3611              		.cfi_def_cfa_register 7
 3612 0006 F860     		str	r0, [r7, #12]
 3613 0008 B960     		str	r1, [r7, #8]
 3614 000a 7A60     		str	r2, [r7, #4]
 3615 000c 3B60     		str	r3, [r7]
1421:../Generated_Code/UTIL1.c ****   /* precondition: string points to starting of time string, e.g. "03:15:05" or "03:15:05,3" or "03
1422:../Generated_Code/UTIL1.c ****   const unsigned char *p;
1423:../Generated_Code/UTIL1.c ****   #define SCAN_IS_DIGIT(ch) ((ch)>='0'&&(ch)<='9')
1424:../Generated_Code/UTIL1.c **** 
1425:../Generated_Code/UTIL1.c ****   *hour = 0;
 3616              		.loc 1 1425 0
 3617 000e BB68     		ldr	r3, [r7, #8]
 3618 0010 0022     		mov	r2, #0
 3619 0012 1A70     		strb	r2, [r3]
1426:../Generated_Code/UTIL1.c ****   *minute = 0;
 3620              		.loc 1 1426 0
 3621 0014 7B68     		ldr	r3, [r7, #4]
 3622 0016 0022     		mov	r2, #0
 3623 0018 1A70     		strb	r2, [r3]
1427:../Generated_Code/UTIL1.c ****   *second = 0;
 3624              		.loc 1 1427 0
 3625 001a 3B68     		ldr	r3, [r7]
 3626 001c 0022     		mov	r2, #0
 3627 001e 1A70     		strb	r2, [r3]
1428:../Generated_Code/UTIL1.c ****   *hSecond = 0;
 3628              		.loc 1 1428 0
 3629 0020 3B6A     		ldr	r3, [r7, #32]
 3630 0022 0022     		mov	r2, #0
 3631 0024 1A70     		strb	r2, [r3]
1429:../Generated_Code/UTIL1.c ****   p = *str;
 3632              		.loc 1 1429 0
 3633 0026 FB68     		ldr	r3, [r7, #12]
 3634 0028 1B68     		ldr	r3, [r3]
 3635 002a 7B61     		str	r3, [r7, #20]
1430:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 3636              		.loc 1 1430 0
 3637 002c 02E0     		b	.L154
 3638              	.L155:
1431:../Generated_Code/UTIL1.c ****     p++; /* skip leading spaces */
 3639              		.loc 1 1431 0
 3640 002e 7B69     		ldr	r3, [r7, #20]
 3641 0030 0133     		add	r3, r3, #1
 3642 0032 7B61     		str	r3, [r7, #20]
 3643              	.L154:
1430:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 3644              		.loc 1 1430 0 discriminator 1
 3645 0034 7B69     		ldr	r3, [r7, #20]
 3646 0036 1B78     		ldrb	r3, [r3]
 3647 0038 202B     		cmp	r3, #32
 3648 003a F8D0     		beq	.L155
1432:../Generated_Code/UTIL1.c ****   }
1433:../Generated_Code/UTIL1.c ****   if (   UTIL1_ScanDecimal8uNumber(&p, hour)==ERR_OK
 3649              		.loc 1 1433 0
 3650 003c 3A1C     		mov	r2, r7
 3651 003e 1432     		add	r2, r2, #20
 3652 0040 BB68     		ldr	r3, [r7, #8]
 3653 0042 101C     		mov	r0, r2
 3654 0044 191C     		mov	r1, r3
 3655 0046 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3656 004a 031C     		mov	r3, r0
 3657 004c 00D0     		beq	.LCB2940
 3658 004e 89E0     		b	.L156	@long jump
 3659              	.LCB2940:
1434:../Generated_Code/UTIL1.c ****       && *hour <= 24
 3660              		.loc 1 1434 0
 3661 0050 BB68     		ldr	r3, [r7, #8]
 3662 0052 1B78     		ldrb	r3, [r3]
 3663 0054 182B     		cmp	r3, #24
 3664 0056 00D9     		bls	.LCB2944
 3665 0058 84E0     		b	.L156	@long jump
 3666              	.LCB2944:
1435:../Generated_Code/UTIL1.c ****       && *p==':'
 3667              		.loc 1 1435 0
 3668 005a 7B69     		ldr	r3, [r7, #20]
 3669 005c 1B78     		ldrb	r3, [r3]
 3670 005e 3A2B     		cmp	r3, #58
 3671 0060 00D0     		beq	.LCB2948
 3672 0062 7FE0     		b	.L156	@long jump
 3673              	.LCB2948:
1436:../Generated_Code/UTIL1.c ****      )
1437:../Generated_Code/UTIL1.c ****   {
1438:../Generated_Code/UTIL1.c ****     p++; /* skip ':' */
 3674              		.loc 1 1438 0
 3675 0064 7B69     		ldr	r3, [r7, #20]
 3676 0066 0133     		add	r3, r3, #1
 3677 0068 7B61     		str	r3, [r7, #20]
1439:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, minute)==ERR_OK
 3678              		.loc 1 1439 0
 3679 006a 3A1C     		mov	r2, r7
 3680 006c 1432     		add	r2, r2, #20
 3681 006e 7B68     		ldr	r3, [r7, #4]
 3682 0070 101C     		mov	r0, r2
 3683 0072 191C     		mov	r1, r3
 3684 0074 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3685 0078 031C     		mov	r3, r0
 3686 007a 00D0     		beq	.LCB2960
 3687 007c 72E0     		b	.L156	@long jump
 3688              	.LCB2960:
1440:../Generated_Code/UTIL1.c ****         && *minute <= 60
 3689              		.loc 1 1440 0
 3690 007e 7B68     		ldr	r3, [r7, #4]
 3691 0080 1B78     		ldrb	r3, [r3]
 3692 0082 3C2B     		cmp	r3, #60
 3693 0084 00D9     		bls	.LCB2964
 3694 0086 6DE0     		b	.L156	@long jump
 3695              	.LCB2964:
1441:../Generated_Code/UTIL1.c ****        )
1442:../Generated_Code/UTIL1.c ****     {
1443:../Generated_Code/UTIL1.c ****       if (*p==':') { /* there is more after the minute */
 3696              		.loc 1 1443 0
 3697 0088 7B69     		ldr	r3, [r7, #20]
 3698 008a 1B78     		ldrb	r3, [r3]
 3699 008c 3A2B     		cmp	r3, #58
 3700 008e 5CD1     		bne	.L157
1444:../Generated_Code/UTIL1.c ****         p++; /* skip ':' */
 3701              		.loc 1 1444 0
 3702 0090 7B69     		ldr	r3, [r7, #20]
 3703 0092 0133     		add	r3, r3, #1
 3704 0094 7B61     		str	r3, [r7, #20]
1445:../Generated_Code/UTIL1.c ****         if (   UTIL1_ScanDecimal8uNumber(&p, second)==ERR_OK
 3705              		.loc 1 1445 0
 3706 0096 3A1C     		mov	r2, r7
 3707 0098 1432     		add	r2, r2, #20
 3708 009a 3B68     		ldr	r3, [r7]
 3709 009c 101C     		mov	r0, r2
 3710 009e 191C     		mov	r1, r3
 3711 00a0 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3712 00a4 031C     		mov	r3, r0
 3713 00a6 5DD1     		bne	.L156
1446:../Generated_Code/UTIL1.c ****             && *second <= 60
 3714              		.loc 1 1446 0
 3715 00a8 3B68     		ldr	r3, [r7]
 3716 00aa 1B78     		ldrb	r3, [r3]
 3717 00ac 3C2B     		cmp	r3, #60
 3718 00ae 59D8     		bhi	.L156
1447:../Generated_Code/UTIL1.c ****            )
1448:../Generated_Code/UTIL1.c ****         {
1449:../Generated_Code/UTIL1.c ****           if (*p==',') { /* we do have either ",z" or ",hh" */
 3719              		.loc 1 1449 0
 3720 00b0 7B69     		ldr	r3, [r7, #20]
 3721 00b2 1B78     		ldrb	r3, [r3]
 3722 00b4 2C2B     		cmp	r3, #44
 3723 00b6 43D1     		bne	.L158
1450:../Generated_Code/UTIL1.c ****             p++; /* skip ',' */
 3724              		.loc 1 1450 0
 3725 00b8 7B69     		ldr	r3, [r7, #20]
 3726 00ba 0133     		add	r3, r3, #1
 3727 00bc 7B61     		str	r3, [r7, #20]
1451:../Generated_Code/UTIL1.c ****             if (SCAN_IS_DIGIT(*p)) {
 3728              		.loc 1 1451 0
 3729 00be 7B69     		ldr	r3, [r7, #20]
 3730 00c0 1B78     		ldrb	r3, [r3]
 3731 00c2 2F2B     		cmp	r3, #47
 3732 00c4 3AD9     		bls	.L159
 3733              		.loc 1 1451 0 is_stmt 0 discriminator 1
 3734 00c6 7B69     		ldr	r3, [r7, #20]
 3735 00c8 1B78     		ldrb	r3, [r3]
 3736 00ca 392B     		cmp	r3, #57
 3737 00cc 36D8     		bhi	.L159
1452:../Generated_Code/UTIL1.c ****               if (SCAN_IS_DIGIT(*(p+1))) { /* ,hh format */
 3738              		.loc 1 1452 0 is_stmt 1
 3739 00ce 7B69     		ldr	r3, [r7, #20]
 3740 00d0 0133     		add	r3, r3, #1
 3741 00d2 1B78     		ldrb	r3, [r3]
 3742 00d4 2F2B     		cmp	r3, #47
 3743 00d6 1ED9     		bls	.L160
 3744              		.loc 1 1452 0 is_stmt 0 discriminator 1
 3745 00d8 7B69     		ldr	r3, [r7, #20]
 3746 00da 0133     		add	r3, r3, #1
 3747 00dc 1B78     		ldrb	r3, [r3]
 3748 00de 392B     		cmp	r3, #57
 3749 00e0 19D8     		bhi	.L160
1453:../Generated_Code/UTIL1.c ****                 *hSecond = (uint8_t)((*p-'0')*10 + *(p+1)-'0');
 3750              		.loc 1 1453 0 is_stmt 1
 3751 00e2 7B69     		ldr	r3, [r7, #20]
 3752 00e4 1B78     		ldrb	r3, [r3]
 3753 00e6 303B     		sub	r3, r3, #48
 3754 00e8 DBB2     		uxtb	r3, r3
 3755 00ea 1A1C     		add	r2, r3, #0
 3756 00ec 9200     		lsl	r2, r2, #2
 3757 00ee D318     		add	r3, r2, r3
 3758 00f0 5B00     		lsl	r3, r3, #1
 3759 00f2 DAB2     		uxtb	r2, r3
 3760 00f4 7B69     		ldr	r3, [r7, #20]
 3761 00f6 0133     		add	r3, r3, #1
 3762 00f8 1B78     		ldrb	r3, [r3]
 3763 00fa D318     		add	r3, r2, r3
 3764 00fc DBB2     		uxtb	r3, r3
 3765 00fe 303B     		sub	r3, r3, #48
 3766 0100 DAB2     		uxtb	r2, r3
 3767 0102 3B6A     		ldr	r3, [r7, #32]
 3768 0104 1A70     		strb	r2, [r3]
1454:../Generated_Code/UTIL1.c ****                 p++; p++;
 3769              		.loc 1 1454 0
 3770 0106 7B69     		ldr	r3, [r7, #20]
 3771 0108 0133     		add	r3, r3, #1
 3772 010a 7B61     		str	r3, [r7, #20]
 3773 010c 7B69     		ldr	r3, [r7, #20]
 3774 010e 0133     		add	r3, r3, #1
 3775 0110 7B61     		str	r3, [r7, #20]
1455:../Generated_Code/UTIL1.c ****                 return ERR_OK;
 3776              		.loc 1 1455 0
 3777 0112 0023     		mov	r3, #0
 3778 0114 27E0     		b	.L161
 3779              	.L160:
1456:../Generated_Code/UTIL1.c ****               } else { /* ,z format */
1457:../Generated_Code/UTIL1.c ****                 *hSecond = (uint8_t)((*p-'0')*10);
 3780              		.loc 1 1457 0
 3781 0116 7B69     		ldr	r3, [r7, #20]
 3782 0118 1B78     		ldrb	r3, [r3]
 3783 011a 303B     		sub	r3, r3, #48
 3784 011c DBB2     		uxtb	r3, r3
 3785 011e 1A1C     		add	r2, r3, #0
 3786 0120 9200     		lsl	r2, r2, #2
 3787 0122 D318     		add	r3, r2, r3
 3788 0124 5B00     		lsl	r3, r3, #1
 3789 0126 DAB2     		uxtb	r2, r3
 3790 0128 3B6A     		ldr	r3, [r7, #32]
 3791 012a 1A70     		strb	r2, [r3]
1458:../Generated_Code/UTIL1.c ****                 p++;
 3792              		.loc 1 1458 0
 3793 012c 7B69     		ldr	r3, [r7, #20]
 3794 012e 0133     		add	r3, r3, #1
 3795 0130 7B61     		str	r3, [r7, #20]
1459:../Generated_Code/UTIL1.c ****                 *str = p; /* advance pointer for caller */
 3796              		.loc 1 1459 0
 3797 0132 7A69     		ldr	r2, [r7, #20]
 3798 0134 FB68     		ldr	r3, [r7, #12]
 3799 0136 1A60     		str	r2, [r3]
1460:../Generated_Code/UTIL1.c ****                 return ERR_OK;
 3800              		.loc 1 1460 0
 3801 0138 0023     		mov	r3, #0
 3802 013a 14E0     		b	.L161
 3803              	.L159:
1461:../Generated_Code/UTIL1.c ****               }
1462:../Generated_Code/UTIL1.c ****             } else {
1463:../Generated_Code/UTIL1.c ****               return ERR_FAILED; /* illegal format, not a number, e.g. ",x" */
 3804              		.loc 1 1463 0
 3805 013c 1B23     		mov	r3, #27
 3806 013e 12E0     		b	.L161
 3807              	.L158:
1464:../Generated_Code/UTIL1.c ****             }
1465:../Generated_Code/UTIL1.c ****           }
1466:../Generated_Code/UTIL1.c ****           *str = p; /* advance pointer for caller */
 3808              		.loc 1 1466 0
 3809 0140 7A69     		ldr	r2, [r7, #20]
 3810 0142 FB68     		ldr	r3, [r7, #12]
 3811 0144 1A60     		str	r2, [r3]
1467:../Generated_Code/UTIL1.c ****           return ERR_OK;
 3812              		.loc 1 1467 0
 3813 0146 0023     		mov	r3, #0
 3814 0148 0DE0     		b	.L161
 3815              	.L157:
1468:../Generated_Code/UTIL1.c ****         }
1469:../Generated_Code/UTIL1.c ****       } else if (*p==' ' || *p=='\0') { /* nothing more after the minute? Assume zero seconds */
 3816              		.loc 1 1469 0
 3817 014a 7B69     		ldr	r3, [r7, #20]
 3818 014c 1B78     		ldrb	r3, [r3]
 3819 014e 202B     		cmp	r3, #32
 3820 0150 03D0     		beq	.L162
 3821              		.loc 1 1469 0 is_stmt 0 discriminator 1
 3822 0152 7B69     		ldr	r3, [r7, #20]
 3823 0154 1B78     		ldrb	r3, [r3]
 3824 0156 002B     		cmp	r3, #0
 3825 0158 04D1     		bne	.L156
 3826              	.L162:
1470:../Generated_Code/UTIL1.c ****         *str = p; /* advance pointer for caller */
 3827              		.loc 1 1470 0 is_stmt 1
 3828 015a 7A69     		ldr	r2, [r7, #20]
 3829 015c FB68     		ldr	r3, [r7, #12]
 3830 015e 1A60     		str	r2, [r3]
1471:../Generated_Code/UTIL1.c ****         return ERR_OK;
 3831              		.loc 1 1471 0
 3832 0160 0023     		mov	r3, #0
 3833 0162 00E0     		b	.L161
 3834              	.L156:
1472:../Generated_Code/UTIL1.c ****       }
1473:../Generated_Code/UTIL1.c ****     }
1474:../Generated_Code/UTIL1.c ****   }
1475:../Generated_Code/UTIL1.c ****   return ERR_FAILED; /* wrong format */
 3835              		.loc 1 1475 0
 3836 0164 1B23     		mov	r3, #27
 3837              	.L161:
1476:../Generated_Code/UTIL1.c **** }
 3838              		.loc 1 1476 0
 3839 0166 181C     		mov	r0, r3
 3840 0168 BD46     		mov	sp, r7
 3841 016a 06B0     		add	sp, sp, #24
 3842              		@ sp needed for prologue
 3843 016c 80BD     		pop	{r7, pc}
 3844              		.cfi_endproc
 3845              	.LFE33:
 3847 016e C046     		.section	.text.UTIL1_ScanDecimal8uNumber,"ax",%progbits
 3848              		.align	2
 3849              		.global	UTIL1_ScanDecimal8uNumber
 3850              		.code	16
 3851              		.thumb_func
 3853              	UTIL1_ScanDecimal8uNumber:
 3854              	.LFB34:
1477:../Generated_Code/UTIL1.c **** 
1478:../Generated_Code/UTIL1.c **** /*
1479:../Generated_Code/UTIL1.c **** ** ===================================================================
1480:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal8uNumber (component Utility)
1481:../Generated_Code/UTIL1.c **** **
1482:../Generated_Code/UTIL1.c **** **     Description :
1483:../Generated_Code/UTIL1.c **** **         Scans a decimal 8bit unsigned number
1484:../Generated_Code/UTIL1.c **** **     Parameters  :
1485:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1486:../Generated_Code/UTIL1.c **** **         str             - String to scan. It returns as well until
1487:../Generated_Code/UTIL1.c **** **                           where it has scanned
1488:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1489:../Generated_Code/UTIL1.c **** **     Returns     :
1490:../Generated_Code/UTIL1.c **** **         ---             - Error code
1491:../Generated_Code/UTIL1.c **** ** ===================================================================
1492:../Generated_Code/UTIL1.c **** */
1493:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal8uNumber(const unsigned char **str, byte *val)
1494:../Generated_Code/UTIL1.c **** {
 3855              		.loc 1 1494 0
 3856              		.cfi_startproc
 3857 0000 80B5     		push	{r7, lr}
 3858              	.LCFI102:
 3859              		.cfi_def_cfa_offset 8
 3860              		.cfi_offset 7, -8
 3861              		.cfi_offset 14, -4
 3862 0002 84B0     		sub	sp, sp, #16
 3863              	.LCFI103:
 3864              		.cfi_def_cfa_offset 24
 3865 0004 00AF     		add	r7, sp, #0
 3866              	.LCFI104:
 3867              		.cfi_def_cfa_register 7
 3868 0006 7860     		str	r0, [r7, #4]
 3869 0008 3960     		str	r1, [r7]
1495:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1496:../Generated_Code/UTIL1.c ****   #define _8_NOF_DIGITS  (3+1)
1497:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = _8_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 3870              		.loc 1 1497 0
 3871 000a 3B1C     		mov	r3, r7
 3872 000c 0F33     		add	r3, r3, #15
 3873 000e 0422     		mov	r2, #4
 3874 0010 1A70     		strb	r2, [r3]
1498:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3875              		.loc 1 1498 0
 3876 0012 7B68     		ldr	r3, [r7, #4]
 3877 0014 1B68     		ldr	r3, [r3]
 3878 0016 BB60     		str	r3, [r7, #8]
1499:../Generated_Code/UTIL1.c **** 
1500:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 3879              		.loc 1 1500 0
 3880 0018 02E0     		b	.L164
 3881              	.L165:
1501:../Generated_Code/UTIL1.c ****     p++;
 3882              		.loc 1 1501 0
 3883 001a BB68     		ldr	r3, [r7, #8]
 3884 001c 0133     		add	r3, r3, #1
 3885 001e BB60     		str	r3, [r7, #8]
 3886              	.L164:
1500:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 3887              		.loc 1 1500 0 discriminator 1
 3888 0020 BB68     		ldr	r3, [r7, #8]
 3889 0022 1B78     		ldrb	r3, [r3]
 3890 0024 202B     		cmp	r3, #32
 3891 0026 F8D0     		beq	.L165
1502:../Generated_Code/UTIL1.c ****   }
1503:../Generated_Code/UTIL1.c ****   *val = 0;
 3892              		.loc 1 1503 0
 3893 0028 3B68     		ldr	r3, [r7]
 3894 002a 0022     		mov	r2, #0
 3895 002c 1A70     		strb	r2, [r3]
1504:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3896              		.loc 1 1504 0
 3897 002e 18E0     		b	.L166
 3898              	.L168:
1505:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*10 + *p-'0');
 3899              		.loc 1 1505 0
 3900 0030 3B68     		ldr	r3, [r7]
 3901 0032 1B78     		ldrb	r3, [r3]
 3902 0034 1A1C     		add	r2, r3, #0
 3903 0036 9200     		lsl	r2, r2, #2
 3904 0038 D318     		add	r3, r2, r3
 3905 003a 5B00     		lsl	r3, r3, #1
 3906 003c DAB2     		uxtb	r2, r3
 3907 003e BB68     		ldr	r3, [r7, #8]
 3908 0040 1B78     		ldrb	r3, [r3]
 3909 0042 D318     		add	r3, r2, r3
 3910 0044 DBB2     		uxtb	r3, r3
 3911 0046 303B     		sub	r3, r3, #48
 3912 0048 DAB2     		uxtb	r2, r3
 3913 004a 3B68     		ldr	r3, [r7]
 3914 004c 1A70     		strb	r2, [r3]
1506:../Generated_Code/UTIL1.c ****     nofDigits--;
 3915              		.loc 1 1506 0
 3916 004e 3B1C     		mov	r3, r7
 3917 0050 0F33     		add	r3, r3, #15
 3918 0052 3A1C     		mov	r2, r7
 3919 0054 0F32     		add	r2, r2, #15
 3920 0056 1278     		ldrb	r2, [r2]
 3921 0058 013A     		sub	r2, r2, #1
 3922 005a 1A70     		strb	r2, [r3]
1507:../Generated_Code/UTIL1.c ****     p++;
 3923              		.loc 1 1507 0
 3924 005c BB68     		ldr	r3, [r7, #8]
 3925 005e 0133     		add	r3, r3, #1
 3926 0060 BB60     		str	r3, [r7, #8]
 3927              	.L166:
1504:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3928              		.loc 1 1504 0 discriminator 1
 3929 0062 BB68     		ldr	r3, [r7, #8]
 3930 0064 1B78     		ldrb	r3, [r3]
 3931 0066 2F2B     		cmp	r3, #47
 3932 0068 08D9     		bls	.L167
1504:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3933              		.loc 1 1504 0 is_stmt 0 discriminator 2
 3934 006a BB68     		ldr	r3, [r7, #8]
 3935 006c 1B78     		ldrb	r3, [r3]
 3936 006e 392B     		cmp	r3, #57
 3937 0070 04D8     		bhi	.L167
1504:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3938              		.loc 1 1504 0 discriminator 1
 3939 0072 3B1C     		mov	r3, r7
 3940 0074 0F33     		add	r3, r3, #15
 3941 0076 1B78     		ldrb	r3, [r3]
 3942 0078 002B     		cmp	r3, #0
 3943 007a D9D1     		bne	.L168
 3944              	.L167:
1508:../Generated_Code/UTIL1.c ****   } /* while */
1509:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 3945              		.loc 1 1509 0 is_stmt 1
 3946 007c 3B1C     		mov	r3, r7
 3947 007e 0F33     		add	r3, r3, #15
 3948 0080 1B78     		ldrb	r3, [r3]
 3949 0082 002B     		cmp	r3, #0
 3950 0084 01D1     		bne	.L169
1510:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 3951              		.loc 1 1510 0
 3952 0086 0423     		mov	r3, #4
 3953 0088 0AE0     		b	.L170
 3954              	.L169:
1511:../Generated_Code/UTIL1.c ****   }
1512:../Generated_Code/UTIL1.c ****   if (nofDigits==_8_NOF_DIGITS) { /* no digits at all? */
 3955              		.loc 1 1512 0
 3956 008a 3B1C     		mov	r3, r7
 3957 008c 0F33     		add	r3, r3, #15
 3958 008e 1B78     		ldrb	r3, [r3]
 3959 0090 042B     		cmp	r3, #4
 3960 0092 01D1     		bne	.L171
1513:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 3961              		.loc 1 1513 0
 3962 0094 1B23     		mov	r3, #27
 3963 0096 03E0     		b	.L170
 3964              	.L171:
1514:../Generated_Code/UTIL1.c ****   }
1515:../Generated_Code/UTIL1.c ****   *str = p;
 3965              		.loc 1 1515 0
 3966 0098 7B68     		ldr	r3, [r7, #4]
 3967 009a BA68     		ldr	r2, [r7, #8]
 3968 009c 1A60     		str	r2, [r3]
1516:../Generated_Code/UTIL1.c ****   return ERR_OK;
 3969              		.loc 1 1516 0
 3970 009e 0023     		mov	r3, #0
 3971              	.L170:
1517:../Generated_Code/UTIL1.c **** }
 3972              		.loc 1 1517 0
 3973 00a0 181C     		mov	r0, r3
 3974 00a2 BD46     		mov	sp, r7
 3975 00a4 04B0     		add	sp, sp, #16
 3976              		@ sp needed for prologue
 3977 00a6 80BD     		pop	{r7, pc}
 3978              		.cfi_endproc
 3979              	.LFE34:
 3981              		.section	.text.UTIL1_ScanDecimal16uNumber,"ax",%progbits
 3982              		.align	2
 3983              		.global	UTIL1_ScanDecimal16uNumber
 3984              		.code	16
 3985              		.thumb_func
 3987              	UTIL1_ScanDecimal16uNumber:
 3988              	.LFB35:
1518:../Generated_Code/UTIL1.c **** 
1519:../Generated_Code/UTIL1.c **** /*
1520:../Generated_Code/UTIL1.c **** ** ===================================================================
1521:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal16uNumber (component Utility)
1522:../Generated_Code/UTIL1.c **** **
1523:../Generated_Code/UTIL1.c **** **     Description :
1524:../Generated_Code/UTIL1.c **** **         Scans a decimal 16bit unsigned number
1525:../Generated_Code/UTIL1.c **** **     Parameters  :
1526:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1527:../Generated_Code/UTIL1.c **** **         str             - String to scan. It returns as well until
1528:../Generated_Code/UTIL1.c **** **                           where it has scanned
1529:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1530:../Generated_Code/UTIL1.c **** **     Returns     :
1531:../Generated_Code/UTIL1.c **** **         ---             - Error code
1532:../Generated_Code/UTIL1.c **** ** ===================================================================
1533:../Generated_Code/UTIL1.c **** */
1534:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal16uNumber(const unsigned char **str, word *val)
1535:../Generated_Code/UTIL1.c **** {
 3989              		.loc 1 1535 0
 3990              		.cfi_startproc
 3991 0000 80B5     		push	{r7, lr}
 3992              	.LCFI105:
 3993              		.cfi_def_cfa_offset 8
 3994              		.cfi_offset 7, -8
 3995              		.cfi_offset 14, -4
 3996 0002 84B0     		sub	sp, sp, #16
 3997              	.LCFI106:
 3998              		.cfi_def_cfa_offset 24
 3999 0004 00AF     		add	r7, sp, #0
 4000              	.LCFI107:
 4001              		.cfi_def_cfa_register 7
 4002 0006 7860     		str	r0, [r7, #4]
 4003 0008 3960     		str	r1, [r7]
1536:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1537:../Generated_Code/UTIL1.c ****   #define _16_NOF_DIGITS  (5+1)
1538:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = _16_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 4004              		.loc 1 1538 0
 4005 000a 3B1C     		mov	r3, r7
 4006 000c 0F33     		add	r3, r3, #15
 4007 000e 0622     		mov	r2, #6
 4008 0010 1A70     		strb	r2, [r3]
1539:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4009              		.loc 1 1539 0
 4010 0012 7B68     		ldr	r3, [r7, #4]
 4011 0014 1B68     		ldr	r3, [r3]
 4012 0016 BB60     		str	r3, [r7, #8]
1540:../Generated_Code/UTIL1.c **** 
1541:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4013              		.loc 1 1541 0
 4014 0018 02E0     		b	.L173
 4015              	.L174:
1542:../Generated_Code/UTIL1.c ****     p++;
 4016              		.loc 1 1542 0
 4017 001a BB68     		ldr	r3, [r7, #8]
 4018 001c 0133     		add	r3, r3, #1
 4019 001e BB60     		str	r3, [r7, #8]
 4020              	.L173:
1541:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4021              		.loc 1 1541 0 discriminator 1
 4022 0020 BB68     		ldr	r3, [r7, #8]
 4023 0022 1B78     		ldrb	r3, [r3]
 4024 0024 202B     		cmp	r3, #32
 4025 0026 F8D0     		beq	.L174
1543:../Generated_Code/UTIL1.c ****   }
1544:../Generated_Code/UTIL1.c ****   *val = 0;
 4026              		.loc 1 1544 0
 4027 0028 3B68     		ldr	r3, [r7]
 4028 002a 0022     		mov	r2, #0
 4029 002c 1A80     		strh	r2, [r3]
1545:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4030              		.loc 1 1545 0
 4031 002e 18E0     		b	.L175
 4032              	.L177:
1546:../Generated_Code/UTIL1.c ****     *val = (uint16_t)((*val)*10 + *p-'0');
 4033              		.loc 1 1546 0
 4034 0030 3B68     		ldr	r3, [r7]
 4035 0032 1B88     		ldrh	r3, [r3]
 4036 0034 1A1C     		add	r2, r3, #0
 4037 0036 9200     		lsl	r2, r2, #2
 4038 0038 D318     		add	r3, r2, r3
 4039 003a 5B00     		lsl	r3, r3, #1
 4040 003c 9AB2     		uxth	r2, r3
 4041 003e BB68     		ldr	r3, [r7, #8]
 4042 0040 1B78     		ldrb	r3, [r3]
 4043 0042 D318     		add	r3, r2, r3
 4044 0044 9BB2     		uxth	r3, r3
 4045 0046 303B     		sub	r3, r3, #48
 4046 0048 9AB2     		uxth	r2, r3
 4047 004a 3B68     		ldr	r3, [r7]
 4048 004c 1A80     		strh	r2, [r3]
1547:../Generated_Code/UTIL1.c ****     nofDigits--;
 4049              		.loc 1 1547 0
 4050 004e 3B1C     		mov	r3, r7
 4051 0050 0F33     		add	r3, r3, #15
 4052 0052 3A1C     		mov	r2, r7
 4053 0054 0F32     		add	r2, r2, #15
 4054 0056 1278     		ldrb	r2, [r2]
 4055 0058 013A     		sub	r2, r2, #1
 4056 005a 1A70     		strb	r2, [r3]
1548:../Generated_Code/UTIL1.c ****     p++;
 4057              		.loc 1 1548 0
 4058 005c BB68     		ldr	r3, [r7, #8]
 4059 005e 0133     		add	r3, r3, #1
 4060 0060 BB60     		str	r3, [r7, #8]
 4061              	.L175:
1545:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4062              		.loc 1 1545 0 discriminator 1
 4063 0062 BB68     		ldr	r3, [r7, #8]
 4064 0064 1B78     		ldrb	r3, [r3]
 4065 0066 2F2B     		cmp	r3, #47
 4066 0068 08D9     		bls	.L176
1545:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4067              		.loc 1 1545 0 is_stmt 0 discriminator 2
 4068 006a BB68     		ldr	r3, [r7, #8]
 4069 006c 1B78     		ldrb	r3, [r3]
 4070 006e 392B     		cmp	r3, #57
 4071 0070 04D8     		bhi	.L176
1545:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4072              		.loc 1 1545 0 discriminator 1
 4073 0072 3B1C     		mov	r3, r7
 4074 0074 0F33     		add	r3, r3, #15
 4075 0076 1B78     		ldrb	r3, [r3]
 4076 0078 002B     		cmp	r3, #0
 4077 007a D9D1     		bne	.L177
 4078              	.L176:
1549:../Generated_Code/UTIL1.c ****   } /* while */
1550:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 4079              		.loc 1 1550 0 is_stmt 1
 4080 007c 3B1C     		mov	r3, r7
 4081 007e 0F33     		add	r3, r3, #15
 4082 0080 1B78     		ldrb	r3, [r3]
 4083 0082 002B     		cmp	r3, #0
 4084 0084 01D1     		bne	.L178
1551:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4085              		.loc 1 1551 0
 4086 0086 0423     		mov	r3, #4
 4087 0088 0AE0     		b	.L179
 4088              	.L178:
1552:../Generated_Code/UTIL1.c ****   }
1553:../Generated_Code/UTIL1.c ****   if (nofDigits==_16_NOF_DIGITS) { /* no digits at all? */
 4089              		.loc 1 1553 0
 4090 008a 3B1C     		mov	r3, r7
 4091 008c 0F33     		add	r3, r3, #15
 4092 008e 1B78     		ldrb	r3, [r3]
 4093 0090 062B     		cmp	r3, #6
 4094 0092 01D1     		bne	.L180
1554:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4095              		.loc 1 1554 0
 4096 0094 1B23     		mov	r3, #27
 4097 0096 03E0     		b	.L179
 4098              	.L180:
1555:../Generated_Code/UTIL1.c ****   }
1556:../Generated_Code/UTIL1.c ****   *str = p;
 4099              		.loc 1 1556 0
 4100 0098 7B68     		ldr	r3, [r7, #4]
 4101 009a BA68     		ldr	r2, [r7, #8]
 4102 009c 1A60     		str	r2, [r3]
1557:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4103              		.loc 1 1557 0
 4104 009e 0023     		mov	r3, #0
 4105              	.L179:
1558:../Generated_Code/UTIL1.c **** }
 4106              		.loc 1 1558 0
 4107 00a0 181C     		mov	r0, r3
 4108 00a2 BD46     		mov	sp, r7
 4109 00a4 04B0     		add	sp, sp, #16
 4110              		@ sp needed for prologue
 4111 00a6 80BD     		pop	{r7, pc}
 4112              		.cfi_endproc
 4113              	.LFE35:
 4115              		.section	.text.UTIL1_ScanDecimal32uNumber,"ax",%progbits
 4116              		.align	2
 4117              		.global	UTIL1_ScanDecimal32uNumber
 4118              		.code	16
 4119              		.thumb_func
 4121              	UTIL1_ScanDecimal32uNumber:
 4122              	.LFB36:
1559:../Generated_Code/UTIL1.c **** 
1560:../Generated_Code/UTIL1.c **** /*
1561:../Generated_Code/UTIL1.c **** ** ===================================================================
1562:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal32uNumber (component Utility)
1563:../Generated_Code/UTIL1.c **** **
1564:../Generated_Code/UTIL1.c **** **     Description :
1565:../Generated_Code/UTIL1.c **** **         Scans a decimal 32bit unsigned number
1566:../Generated_Code/UTIL1.c **** **     Parameters  :
1567:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1568:../Generated_Code/UTIL1.c **** **         str             - string to scan. It returns as well until
1569:../Generated_Code/UTIL1.c **** **                           where it has scanned
1570:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1571:../Generated_Code/UTIL1.c **** **     Returns     :
1572:../Generated_Code/UTIL1.c **** **         ---             - Error code
1573:../Generated_Code/UTIL1.c **** ** ===================================================================
1574:../Generated_Code/UTIL1.c **** */
1575:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal32uNumber(const unsigned char **str, dword *val)
1576:../Generated_Code/UTIL1.c **** {
 4123              		.loc 1 1576 0
 4124              		.cfi_startproc
 4125 0000 80B5     		push	{r7, lr}
 4126              	.LCFI108:
 4127              		.cfi_def_cfa_offset 8
 4128              		.cfi_offset 7, -8
 4129              		.cfi_offset 14, -4
 4130 0002 84B0     		sub	sp, sp, #16
 4131              	.LCFI109:
 4132              		.cfi_def_cfa_offset 24
 4133 0004 00AF     		add	r7, sp, #0
 4134              	.LCFI110:
 4135              		.cfi_def_cfa_register 7
 4136 0006 7860     		str	r0, [r7, #4]
 4137 0008 3960     		str	r1, [r7]
1577:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1578:../Generated_Code/UTIL1.c ****   #define _32_NOF_DIGITS  (10+1)
1579:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = _32_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 4138              		.loc 1 1579 0
 4139 000a 3B1C     		mov	r3, r7
 4140 000c 0F33     		add	r3, r3, #15
 4141 000e 0B22     		mov	r2, #11
 4142 0010 1A70     		strb	r2, [r3]
1580:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4143              		.loc 1 1580 0
 4144 0012 7B68     		ldr	r3, [r7, #4]
 4145 0014 1B68     		ldr	r3, [r3]
 4146 0016 BB60     		str	r3, [r7, #8]
1581:../Generated_Code/UTIL1.c **** 
1582:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4147              		.loc 1 1582 0
 4148 0018 02E0     		b	.L182
 4149              	.L183:
1583:../Generated_Code/UTIL1.c ****     p++;
 4150              		.loc 1 1583 0
 4151 001a BB68     		ldr	r3, [r7, #8]
 4152 001c 0133     		add	r3, r3, #1
 4153 001e BB60     		str	r3, [r7, #8]
 4154              	.L182:
1582:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4155              		.loc 1 1582 0 discriminator 1
 4156 0020 BB68     		ldr	r3, [r7, #8]
 4157 0022 1B78     		ldrb	r3, [r3]
 4158 0024 202B     		cmp	r3, #32
 4159 0026 F8D0     		beq	.L183
1584:../Generated_Code/UTIL1.c ****   }
1585:../Generated_Code/UTIL1.c ****   *val = 0;
 4160              		.loc 1 1585 0
 4161 0028 3B68     		ldr	r3, [r7]
 4162 002a 0022     		mov	r2, #0
 4163 002c 1A60     		str	r2, [r3]
1586:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4164              		.loc 1 1586 0
 4165 002e 17E0     		b	.L184
 4166              	.L186:
1587:../Generated_Code/UTIL1.c ****     *val = (uint32_t)((*val)*10 + *p-'0');
 4167              		.loc 1 1587 0
 4168 0030 3B68     		ldr	r3, [r7]
 4169 0032 1A68     		ldr	r2, [r3]
 4170 0034 131C     		mov	r3, r2
 4171 0036 9B00     		lsl	r3, r3, #2
 4172 0038 9B18     		add	r3, r3, r2
 4173 003a 5B00     		lsl	r3, r3, #1
 4174 003c 1A1C     		mov	r2, r3
 4175 003e BB68     		ldr	r3, [r7, #8]
 4176 0040 1B78     		ldrb	r3, [r3]
 4177 0042 D318     		add	r3, r2, r3
 4178 0044 1A1C     		mov	r2, r3
 4179 0046 303A     		sub	r2, r2, #48
 4180 0048 3B68     		ldr	r3, [r7]
 4181 004a 1A60     		str	r2, [r3]
1588:../Generated_Code/UTIL1.c ****     nofDigits--;
 4182              		.loc 1 1588 0
 4183 004c 3B1C     		mov	r3, r7
 4184 004e 0F33     		add	r3, r3, #15
 4185 0050 3A1C     		mov	r2, r7
 4186 0052 0F32     		add	r2, r2, #15
 4187 0054 1278     		ldrb	r2, [r2]
 4188 0056 013A     		sub	r2, r2, #1
 4189 0058 1A70     		strb	r2, [r3]
1589:../Generated_Code/UTIL1.c ****     p++;
 4190              		.loc 1 1589 0
 4191 005a BB68     		ldr	r3, [r7, #8]
 4192 005c 0133     		add	r3, r3, #1
 4193 005e BB60     		str	r3, [r7, #8]
 4194              	.L184:
1586:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4195              		.loc 1 1586 0 discriminator 1
 4196 0060 BB68     		ldr	r3, [r7, #8]
 4197 0062 1B78     		ldrb	r3, [r3]
 4198 0064 2F2B     		cmp	r3, #47
 4199 0066 08D9     		bls	.L185
1586:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4200              		.loc 1 1586 0 is_stmt 0 discriminator 2
 4201 0068 BB68     		ldr	r3, [r7, #8]
 4202 006a 1B78     		ldrb	r3, [r3]
 4203 006c 392B     		cmp	r3, #57
 4204 006e 04D8     		bhi	.L185
1586:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4205              		.loc 1 1586 0 discriminator 1
 4206 0070 3B1C     		mov	r3, r7
 4207 0072 0F33     		add	r3, r3, #15
 4208 0074 1B78     		ldrb	r3, [r3]
 4209 0076 002B     		cmp	r3, #0
 4210 0078 DAD1     		bne	.L186
 4211              	.L185:
1590:../Generated_Code/UTIL1.c ****   } /* while */
1591:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 4212              		.loc 1 1591 0 is_stmt 1
 4213 007a 3B1C     		mov	r3, r7
 4214 007c 0F33     		add	r3, r3, #15
 4215 007e 1B78     		ldrb	r3, [r3]
 4216 0080 002B     		cmp	r3, #0
 4217 0082 01D1     		bne	.L187
1592:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4218              		.loc 1 1592 0
 4219 0084 0423     		mov	r3, #4
 4220 0086 0AE0     		b	.L188
 4221              	.L187:
1593:../Generated_Code/UTIL1.c ****   }
1594:../Generated_Code/UTIL1.c ****   if (nofDigits==_32_NOF_DIGITS) { /* no digits at all? */
 4222              		.loc 1 1594 0
 4223 0088 3B1C     		mov	r3, r7
 4224 008a 0F33     		add	r3, r3, #15
 4225 008c 1B78     		ldrb	r3, [r3]
 4226 008e 0B2B     		cmp	r3, #11
 4227 0090 01D1     		bne	.L189
1595:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4228              		.loc 1 1595 0
 4229 0092 1B23     		mov	r3, #27
 4230 0094 03E0     		b	.L188
 4231              	.L189:
1596:../Generated_Code/UTIL1.c ****   }
1597:../Generated_Code/UTIL1.c ****   *str = p;
 4232              		.loc 1 1597 0
 4233 0096 7B68     		ldr	r3, [r7, #4]
 4234 0098 BA68     		ldr	r2, [r7, #8]
 4235 009a 1A60     		str	r2, [r3]
1598:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4236              		.loc 1 1598 0
 4237 009c 0023     		mov	r3, #0
 4238              	.L188:
1599:../Generated_Code/UTIL1.c **** }
 4239              		.loc 1 1599 0
 4240 009e 181C     		mov	r0, r3
 4241 00a0 BD46     		mov	sp, r7
 4242 00a2 04B0     		add	sp, sp, #16
 4243              		@ sp needed for prologue
 4244 00a4 80BD     		pop	{r7, pc}
 4245              		.cfi_endproc
 4246              	.LFE36:
 4248 00a6 C046     		.section	.text.PreScanHexNumber,"ax",%progbits
 4249              		.align	2
 4250              		.code	16
 4251              		.thumb_func
 4253              	PreScanHexNumber:
 4254              	.LFB37:
1600:../Generated_Code/UTIL1.c **** 
1601:../Generated_Code/UTIL1.c **** /*
1602:../Generated_Code/UTIL1.c **** ** ===================================================================
1603:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcmp (component Utility)
1604:../Generated_Code/UTIL1.c **** **
1605:../Generated_Code/UTIL1.c **** **     Description :
1606:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strcmp() routine
1607:../Generated_Code/UTIL1.c **** **     Parameters  :
1608:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1609:../Generated_Code/UTIL1.c **** **       * str1            - Pointer to string
1610:../Generated_Code/UTIL1.c **** **       * str2            - Pointer to string
1611:../Generated_Code/UTIL1.c **** **     Returns     :
1612:../Generated_Code/UTIL1.c **** **         ---             - Returns zero if the two strings are the
1613:../Generated_Code/UTIL1.c **** **                           same
1614:../Generated_Code/UTIL1.c **** ** ===================================================================
1615:../Generated_Code/UTIL1.c **** */
1616:../Generated_Code/UTIL1.c **** /***
1617:../Generated_Code/UTIL1.c **** int16_t UTIL1_strcmp(const char *, const char *)
1618:../Generated_Code/UTIL1.c **** {
1619:../Generated_Code/UTIL1.c ****   Method is implemented as macro in the header file as wrapper to the standard strcmp() function
1620:../Generated_Code/UTIL1.c **** }
1621:../Generated_Code/UTIL1.c **** */
1622:../Generated_Code/UTIL1.c **** 
1623:../Generated_Code/UTIL1.c **** /*
1624:../Generated_Code/UTIL1.c **** ** ===================================================================
1625:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strncmp (component Utility)
1626:../Generated_Code/UTIL1.c **** **
1627:../Generated_Code/UTIL1.c **** **     Description :
1628:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strncmp() routine
1629:../Generated_Code/UTIL1.c **** **     Parameters  :
1630:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1631:../Generated_Code/UTIL1.c **** **       * str1            - Pointer to string
1632:../Generated_Code/UTIL1.c **** **       * str2            - Pointer to string
1633:../Generated_Code/UTIL1.c **** **         size            - 
1634:../Generated_Code/UTIL1.c **** **     Returns     :
1635:../Generated_Code/UTIL1.c **** **         ---             - Returns zero if the two strings are the
1636:../Generated_Code/UTIL1.c **** **                           same
1637:../Generated_Code/UTIL1.c **** ** ===================================================================
1638:../Generated_Code/UTIL1.c **** */
1639:../Generated_Code/UTIL1.c **** /***
1640:../Generated_Code/UTIL1.c **** int16_t UTIL1_strncmp(const char *, const char *, size_t size)
1641:../Generated_Code/UTIL1.c **** {
1642:../Generated_Code/UTIL1.c ****   /Method is implemented as macro in the header file as wrapper to the standard strncmp() function
1643:../Generated_Code/UTIL1.c **** }
1644:../Generated_Code/UTIL1.c **** */
1645:../Generated_Code/UTIL1.c **** 
1646:../Generated_Code/UTIL1.c **** /*
1647:../Generated_Code/UTIL1.c **** ** ===================================================================
1648:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strlen (component Utility)
1649:../Generated_Code/UTIL1.c **** **
1650:../Generated_Code/UTIL1.c **** **     Description :
1651:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strlen() function.
1652:../Generated_Code/UTIL1.c **** **     Parameters  :
1653:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1654:../Generated_Code/UTIL1.c **** **         str             - 
1655:../Generated_Code/UTIL1.c **** **     Returns     :
1656:../Generated_Code/UTIL1.c **** **         ---             - size of strinig
1657:../Generated_Code/UTIL1.c **** ** ===================================================================
1658:../Generated_Code/UTIL1.c **** */
1659:../Generated_Code/UTIL1.c **** /***
1660:../Generated_Code/UTIL1.c **** word UTIL1_strlen(const char *)
1661:../Generated_Code/UTIL1.c **** {
1662:../Generated_Code/UTIL1.c ****   Method is implemented as macro in the header file as wrapper to the standard strlen() function
1663:../Generated_Code/UTIL1.c **** }
1664:../Generated_Code/UTIL1.c **** */
1665:../Generated_Code/UTIL1.c **** 
1666:../Generated_Code/UTIL1.c **** static byte PreScanHexNumber(const unsigned char **str)
1667:../Generated_Code/UTIL1.c **** {
 4255              		.loc 1 1667 0
 4256              		.cfi_startproc
 4257 0000 80B5     		push	{r7, lr}
 4258              	.LCFI111:
 4259              		.cfi_def_cfa_offset 8
 4260              		.cfi_offset 7, -8
 4261              		.cfi_offset 14, -4
 4262 0002 84B0     		sub	sp, sp, #16
 4263              	.LCFI112:
 4264              		.cfi_def_cfa_offset 24
 4265 0004 00AF     		add	r7, sp, #0
 4266              	.LCFI113:
 4267              		.cfi_def_cfa_register 7
 4268 0006 7860     		str	r0, [r7, #4]
1668:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4269              		.loc 1 1668 0
 4270 0008 7B68     		ldr	r3, [r7, #4]
 4271 000a 1B68     		ldr	r3, [r3]
 4272 000c FB60     		str	r3, [r7, #12]
1669:../Generated_Code/UTIL1.c **** 
1670:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4273              		.loc 1 1670 0
 4274 000e 02E0     		b	.L191
 4275              	.L192:
1671:../Generated_Code/UTIL1.c ****     p++; /* skip space */
 4276              		.loc 1 1671 0
 4277 0010 FB68     		ldr	r3, [r7, #12]
 4278 0012 0133     		add	r3, r3, #1
 4279 0014 FB60     		str	r3, [r7, #12]
 4280              	.L191:
1670:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4281              		.loc 1 1670 0 discriminator 1
 4282 0016 FB68     		ldr	r3, [r7, #12]
 4283 0018 1B78     		ldrb	r3, [r3]
 4284 001a 202B     		cmp	r3, #32
 4285 001c F8D0     		beq	.L192
1672:../Generated_Code/UTIL1.c ****   }
1673:../Generated_Code/UTIL1.c ****   if (*p!='0') { /* must start with 0x */
 4286              		.loc 1 1673 0
 4287 001e FB68     		ldr	r3, [r7, #12]
 4288 0020 1B78     		ldrb	r3, [r3]
 4289 0022 302B     		cmp	r3, #48
 4290 0024 01D0     		beq	.L193
1674:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4291              		.loc 1 1674 0
 4292 0026 1B23     		mov	r3, #27
 4293 0028 0FE0     		b	.L194
 4294              	.L193:
1675:../Generated_Code/UTIL1.c ****   }
1676:../Generated_Code/UTIL1.c ****   p++; /* skip '0' */
 4295              		.loc 1 1676 0
 4296 002a FB68     		ldr	r3, [r7, #12]
 4297 002c 0133     		add	r3, r3, #1
 4298 002e FB60     		str	r3, [r7, #12]
1677:../Generated_Code/UTIL1.c ****   if (*p!='x') { /* must start with 0x */
 4299              		.loc 1 1677 0
 4300 0030 FB68     		ldr	r3, [r7, #12]
 4301 0032 1B78     		ldrb	r3, [r3]
 4302 0034 782B     		cmp	r3, #120
 4303 0036 01D0     		beq	.L195
1678:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4304              		.loc 1 1678 0
 4305 0038 1B23     		mov	r3, #27
 4306 003a 06E0     		b	.L194
 4307              	.L195:
1679:../Generated_Code/UTIL1.c ****   }
1680:../Generated_Code/UTIL1.c ****   p++; /* skip 'x' */
 4308              		.loc 1 1680 0
 4309 003c FB68     		ldr	r3, [r7, #12]
 4310 003e 0133     		add	r3, r3, #1
 4311 0040 FB60     		str	r3, [r7, #12]
1681:../Generated_Code/UTIL1.c ****   *str = p;
 4312              		.loc 1 1681 0
 4313 0042 7B68     		ldr	r3, [r7, #4]
 4314 0044 FA68     		ldr	r2, [r7, #12]
 4315 0046 1A60     		str	r2, [r3]
1682:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4316              		.loc 1 1682 0
 4317 0048 0023     		mov	r3, #0
 4318              	.L194:
1683:../Generated_Code/UTIL1.c **** }
 4319              		.loc 1 1683 0
 4320 004a 181C     		mov	r0, r3
 4321 004c BD46     		mov	sp, r7
 4322 004e 04B0     		add	sp, sp, #16
 4323              		@ sp needed for prologue
 4324 0050 80BD     		pop	{r7, pc}
 4325              		.cfi_endproc
 4326              	.LFE37:
 4328 0052 C046     		.section	.text.HexToDec,"ax",%progbits
 4329              		.align	2
 4330              		.code	16
 4331              		.thumb_func
 4333              	HexToDec:
 4334              	.LFB38:
1684:../Generated_Code/UTIL1.c **** 
1685:../Generated_Code/UTIL1.c **** static byte HexToDec(const unsigned char **p, unsigned char *val) {
 4335              		.loc 1 1685 0
 4336              		.cfi_startproc
 4337 0000 80B5     		push	{r7, lr}
 4338              	.LCFI114:
 4339              		.cfi_def_cfa_offset 8
 4340              		.cfi_offset 7, -8
 4341              		.cfi_offset 14, -4
 4342 0002 84B0     		sub	sp, sp, #16
 4343              	.LCFI115:
 4344              		.cfi_def_cfa_offset 24
 4345 0004 00AF     		add	r7, sp, #0
 4346              	.LCFI116:
 4347              		.cfi_def_cfa_register 7
 4348 0006 7860     		str	r0, [r7, #4]
 4349 0008 3960     		str	r1, [r7]
1686:../Generated_Code/UTIL1.c ****   /* convert a hexadecimal character into a decimal value */
1687:../Generated_Code/UTIL1.c ****   unsigned char ch = **p;
 4350              		.loc 1 1687 0
 4351 000a 7B68     		ldr	r3, [r7, #4]
 4352 000c 1A68     		ldr	r2, [r3]
 4353 000e 3B1C     		mov	r3, r7
 4354 0010 0F33     		add	r3, r3, #15
 4355 0012 1278     		ldrb	r2, [r2]
 4356 0014 1A70     		strb	r2, [r3]
1688:../Generated_Code/UTIL1.c **** 
1689:../Generated_Code/UTIL1.c ****   if (ch>='0' && ch<='9') {
 4357              		.loc 1 1689 0
 4358 0016 3B1C     		mov	r3, r7
 4359 0018 0F33     		add	r3, r3, #15
 4360 001a 1B78     		ldrb	r3, [r3]
 4361 001c 2F2B     		cmp	r3, #47
 4362 001e 12D9     		bls	.L197
 4363              		.loc 1 1689 0 is_stmt 0 discriminator 1
 4364 0020 3B1C     		mov	r3, r7
 4365 0022 0F33     		add	r3, r3, #15
 4366 0024 1B78     		ldrb	r3, [r3]
 4367 0026 392B     		cmp	r3, #57
 4368 0028 0DD8     		bhi	.L197
1690:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'0');
 4369              		.loc 1 1690 0 is_stmt 1
 4370 002a 3B1C     		mov	r3, r7
 4371 002c 0F33     		add	r3, r3, #15
 4372 002e 1B78     		ldrb	r3, [r3]
 4373 0030 303B     		sub	r3, r3, #48
 4374 0032 DAB2     		uxtb	r2, r3
 4375 0034 3B68     		ldr	r3, [r7]
 4376 0036 1A70     		strb	r2, [r3]
1691:../Generated_Code/UTIL1.c ****     (*p)++;
 4377              		.loc 1 1691 0
 4378 0038 7B68     		ldr	r3, [r7, #4]
 4379 003a 1B68     		ldr	r3, [r3]
 4380 003c 5A1C     		add	r2, r3, #1
 4381 003e 7B68     		ldr	r3, [r7, #4]
 4382 0040 1A60     		str	r2, [r3]
1692:../Generated_Code/UTIL1.c ****     return ERR_OK;
 4383              		.loc 1 1692 0
 4384 0042 0023     		mov	r3, #0
 4385 0044 30E0     		b	.L198
 4386              	.L197:
1693:../Generated_Code/UTIL1.c ****   } else if (ch>='a' && ch<='f') {
 4387              		.loc 1 1693 0
 4388 0046 3B1C     		mov	r3, r7
 4389 0048 0F33     		add	r3, r3, #15
 4390 004a 1B78     		ldrb	r3, [r3]
 4391 004c 602B     		cmp	r3, #96
 4392 004e 12D9     		bls	.L199
 4393              		.loc 1 1693 0 is_stmt 0 discriminator 1
 4394 0050 3B1C     		mov	r3, r7
 4395 0052 0F33     		add	r3, r3, #15
 4396 0054 1B78     		ldrb	r3, [r3]
 4397 0056 662B     		cmp	r3, #102
 4398 0058 0DD8     		bhi	.L199
1694:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'a'+10);
 4399              		.loc 1 1694 0 is_stmt 1
 4400 005a 3B1C     		mov	r3, r7
 4401 005c 0F33     		add	r3, r3, #15
 4402 005e 1B78     		ldrb	r3, [r3]
 4403 0060 573B     		sub	r3, r3, #87
 4404 0062 DAB2     		uxtb	r2, r3
 4405 0064 3B68     		ldr	r3, [r7]
 4406 0066 1A70     		strb	r2, [r3]
1695:../Generated_Code/UTIL1.c ****     (*p)++;
 4407              		.loc 1 1695 0
 4408 0068 7B68     		ldr	r3, [r7, #4]
 4409 006a 1B68     		ldr	r3, [r3]
 4410 006c 5A1C     		add	r2, r3, #1
 4411 006e 7B68     		ldr	r3, [r7, #4]
 4412 0070 1A60     		str	r2, [r3]
1696:../Generated_Code/UTIL1.c ****     return ERR_OK;
 4413              		.loc 1 1696 0
 4414 0072 0023     		mov	r3, #0
 4415 0074 18E0     		b	.L198
 4416              	.L199:
1697:../Generated_Code/UTIL1.c ****   } else if (ch>='A' && ch<='F') {
 4417              		.loc 1 1697 0
 4418 0076 3B1C     		mov	r3, r7
 4419 0078 0F33     		add	r3, r3, #15
 4420 007a 1B78     		ldrb	r3, [r3]
 4421 007c 402B     		cmp	r3, #64
 4422 007e 12D9     		bls	.L200
 4423              		.loc 1 1697 0 is_stmt 0 discriminator 1
 4424 0080 3B1C     		mov	r3, r7
 4425 0082 0F33     		add	r3, r3, #15
 4426 0084 1B78     		ldrb	r3, [r3]
 4427 0086 462B     		cmp	r3, #70
 4428 0088 0DD8     		bhi	.L200
1698:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'A'+10);
 4429              		.loc 1 1698 0 is_stmt 1
 4430 008a 3B1C     		mov	r3, r7
 4431 008c 0F33     		add	r3, r3, #15
 4432 008e 1B78     		ldrb	r3, [r3]
 4433 0090 373B     		sub	r3, r3, #55
 4434 0092 DAB2     		uxtb	r2, r3
 4435 0094 3B68     		ldr	r3, [r7]
 4436 0096 1A70     		strb	r2, [r3]
1699:../Generated_Code/UTIL1.c ****     (*p)++;
 4437              		.loc 1 1699 0
 4438 0098 7B68     		ldr	r3, [r7, #4]
 4439 009a 1B68     		ldr	r3, [r3]
 4440 009c 5A1C     		add	r2, r3, #1
 4441 009e 7B68     		ldr	r3, [r7, #4]
 4442 00a0 1A60     		str	r2, [r3]
1700:../Generated_Code/UTIL1.c ****     return ERR_OK;
 4443              		.loc 1 1700 0
 4444 00a2 0023     		mov	r3, #0
 4445 00a4 00E0     		b	.L198
 4446              	.L200:
1701:../Generated_Code/UTIL1.c ****   }
1702:../Generated_Code/UTIL1.c ****   return ERR_FAILED;
 4447              		.loc 1 1702 0
 4448 00a6 1B23     		mov	r3, #27
 4449              	.L198:
1703:../Generated_Code/UTIL1.c **** }
 4450              		.loc 1 1703 0
 4451 00a8 181C     		mov	r0, r3
 4452 00aa BD46     		mov	sp, r7
 4453 00ac 04B0     		add	sp, sp, #16
 4454              		@ sp needed for prologue
 4455 00ae 80BD     		pop	{r7, pc}
 4456              		.cfi_endproc
 4457              	.LFE38:
 4459              		.section	.text.UTIL1_ScanHex32uNumber,"ax",%progbits
 4460              		.align	2
 4461              		.global	UTIL1_ScanHex32uNumber
 4462              		.code	16
 4463              		.thumb_func
 4465              	UTIL1_ScanHex32uNumber:
 4466              	.LFB39:
1704:../Generated_Code/UTIL1.c **** 
1705:../Generated_Code/UTIL1.c **** /*
1706:../Generated_Code/UTIL1.c **** ** ===================================================================
1707:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex32uNumber (component Utility)
1708:../Generated_Code/UTIL1.c **** **
1709:../Generated_Code/UTIL1.c **** **     Description :
1710:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 32bit number, starting with 0x
1711:../Generated_Code/UTIL1.c **** **     Parameters  :
1712:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1713:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1714:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1715:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1716:../Generated_Code/UTIL1.c **** **     Returns     :
1717:../Generated_Code/UTIL1.c **** **         ---             - Error code
1718:../Generated_Code/UTIL1.c **** ** ===================================================================
1719:../Generated_Code/UTIL1.c **** */
1720:../Generated_Code/UTIL1.c **** byte UTIL1_ScanHex32uNumber(const unsigned char **str, dword *val)
1721:../Generated_Code/UTIL1.c **** {
 4467              		.loc 1 1721 0
 4468              		.cfi_startproc
 4469 0000 80B5     		push	{r7, lr}
 4470              	.LCFI117:
 4471              		.cfi_def_cfa_offset 8
 4472              		.cfi_offset 7, -8
 4473              		.cfi_offset 14, -4
 4474 0002 86B0     		sub	sp, sp, #24
 4475              	.LCFI118:
 4476              		.cfi_def_cfa_offset 32
 4477 0004 00AF     		add	r7, sp, #0
 4478              	.LCFI119:
 4479              		.cfi_def_cfa_register 7
 4480 0006 7860     		str	r0, [r7, #4]
 4481 0008 3960     		str	r1, [r7]
1722:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1723:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 8+1; /* maximum number of digits to avoid overflow */
 4482              		.loc 1 1723 0
 4483 000a 3B1C     		mov	r3, r7
 4484 000c 1733     		add	r3, r3, #23
 4485 000e 0922     		mov	r2, #9
 4486 0010 1A70     		strb	r2, [r3]
1724:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4487              		.loc 1 1724 0
 4488 0012 7B68     		ldr	r3, [r7, #4]
 4489 0014 1B68     		ldr	r3, [r3]
 4490 0016 3B61     		str	r3, [r7, #16]
1725:../Generated_Code/UTIL1.c ****   byte v;
1726:../Generated_Code/UTIL1.c **** 
1727:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 4491              		.loc 1 1727 0
 4492 0018 3B1C     		mov	r3, r7
 4493 001a 1033     		add	r3, r3, #16
 4494 001c 181C     		mov	r0, r3
 4495 001e FFF7FEFF 		bl	PreScanHexNumber
 4496 0022 031C     		mov	r3, r0
 4497 0024 01D0     		beq	.L202
1728:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4498              		.loc 1 1728 0
 4499 0026 1B23     		mov	r3, #27
 4500 0028 2DE0     		b	.L203
 4501              	.L202:
1729:../Generated_Code/UTIL1.c ****   }
1730:../Generated_Code/UTIL1.c ****   *val = 0;
 4502              		.loc 1 1730 0
 4503 002a 3B68     		ldr	r3, [r7]
 4504 002c 0022     		mov	r2, #0
 4505 002e 1A60     		str	r2, [r3]
1731:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4506              		.loc 1 1731 0
 4507 0030 0FE0     		b	.L204
 4508              	.L206:
1732:../Generated_Code/UTIL1.c ****     *val = (uint32_t)((*val)*16 + v);
 4509              		.loc 1 1732 0
 4510 0032 3B68     		ldr	r3, [r7]
 4511 0034 1B68     		ldr	r3, [r3]
 4512 0036 1A01     		lsl	r2, r3, #4
 4513 0038 3B1C     		mov	r3, r7
 4514 003a 0F33     		add	r3, r3, #15
 4515 003c 1B78     		ldrb	r3, [r3]
 4516 003e D218     		add	r2, r2, r3
 4517 0040 3B68     		ldr	r3, [r7]
 4518 0042 1A60     		str	r2, [r3]
1733:../Generated_Code/UTIL1.c ****     nofDigits--;
 4519              		.loc 1 1733 0
 4520 0044 3B1C     		mov	r3, r7
 4521 0046 1733     		add	r3, r3, #23
 4522 0048 3A1C     		mov	r2, r7
 4523 004a 1732     		add	r2, r2, #23
 4524 004c 1278     		ldrb	r2, [r2]
 4525 004e 013A     		sub	r2, r2, #1
 4526 0050 1A70     		strb	r2, [r3]
 4527              	.L204:
1731:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4528              		.loc 1 1731 0 discriminator 1
 4529 0052 3A1C     		mov	r2, r7
 4530 0054 1032     		add	r2, r2, #16
 4531 0056 3B1C     		mov	r3, r7
 4532 0058 0F33     		add	r3, r3, #15
 4533 005a 101C     		mov	r0, r2
 4534 005c 191C     		mov	r1, r3
 4535 005e FFF7FEFF 		bl	HexToDec
 4536 0062 031C     		mov	r3, r0
 4537 0064 04D1     		bne	.L205
1731:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4538              		.loc 1 1731 0 is_stmt 0 discriminator 2
 4539 0066 3B1C     		mov	r3, r7
 4540 0068 1733     		add	r3, r3, #23
 4541 006a 1B78     		ldrb	r3, [r3]
 4542 006c 002B     		cmp	r3, #0
 4543 006e E0D1     		bne	.L206
 4544              	.L205:
1734:../Generated_Code/UTIL1.c ****   } /* while */
1735:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 4545              		.loc 1 1735 0 is_stmt 1
 4546 0070 3B1C     		mov	r3, r7
 4547 0072 1733     		add	r3, r3, #23
 4548 0074 1B78     		ldrb	r3, [r3]
 4549 0076 002B     		cmp	r3, #0
 4550 0078 01D1     		bne	.L207
1736:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4551              		.loc 1 1736 0
 4552 007a 0423     		mov	r3, #4
 4553 007c 03E0     		b	.L203
 4554              	.L207:
1737:../Generated_Code/UTIL1.c ****   }
1738:../Generated_Code/UTIL1.c ****   *str = p;
 4555              		.loc 1 1738 0
 4556 007e 3A69     		ldr	r2, [r7, #16]
 4557 0080 7B68     		ldr	r3, [r7, #4]
 4558 0082 1A60     		str	r2, [r3]
1739:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4559              		.loc 1 1739 0
 4560 0084 0023     		mov	r3, #0
 4561              	.L203:
1740:../Generated_Code/UTIL1.c **** }
 4562              		.loc 1 1740 0
 4563 0086 181C     		mov	r0, r3
 4564 0088 BD46     		mov	sp, r7
 4565 008a 06B0     		add	sp, sp, #24
 4566              		@ sp needed for prologue
 4567 008c 80BD     		pop	{r7, pc}
 4568              		.cfi_endproc
 4569              	.LFE39:
 4571 008e C046     		.section	.text.UTIL1_ScanHex16uNumber,"ax",%progbits
 4572              		.align	2
 4573              		.global	UTIL1_ScanHex16uNumber
 4574              		.code	16
 4575              		.thumb_func
 4577              	UTIL1_ScanHex16uNumber:
 4578              	.LFB40:
1741:../Generated_Code/UTIL1.c **** 
1742:../Generated_Code/UTIL1.c **** /*
1743:../Generated_Code/UTIL1.c **** ** ===================================================================
1744:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex16uNumber (component Utility)
1745:../Generated_Code/UTIL1.c **** **
1746:../Generated_Code/UTIL1.c **** **     Description :
1747:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 16bit number, starting with 0x
1748:../Generated_Code/UTIL1.c **** **     Parameters  :
1749:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1750:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x.. It
1751:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1752:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1753:../Generated_Code/UTIL1.c **** **     Returns     :
1754:../Generated_Code/UTIL1.c **** **         ---             - Error code
1755:../Generated_Code/UTIL1.c **** ** ===================================================================
1756:../Generated_Code/UTIL1.c **** */
1757:../Generated_Code/UTIL1.c **** byte UTIL1_ScanHex16uNumber(const unsigned char **str, word *val)
1758:../Generated_Code/UTIL1.c **** {
 4579              		.loc 1 1758 0
 4580              		.cfi_startproc
 4581 0000 80B5     		push	{r7, lr}
 4582              	.LCFI120:
 4583              		.cfi_def_cfa_offset 8
 4584              		.cfi_offset 7, -8
 4585              		.cfi_offset 14, -4
 4586 0002 86B0     		sub	sp, sp, #24
 4587              	.LCFI121:
 4588              		.cfi_def_cfa_offset 32
 4589 0004 00AF     		add	r7, sp, #0
 4590              	.LCFI122:
 4591              		.cfi_def_cfa_register 7
 4592 0006 7860     		str	r0, [r7, #4]
 4593 0008 3960     		str	r1, [r7]
1759:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1760:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 4+1; /* maximum number of digits to avoid overflow */
 4594              		.loc 1 1760 0
 4595 000a 3B1C     		mov	r3, r7
 4596 000c 1733     		add	r3, r3, #23
 4597 000e 0522     		mov	r2, #5
 4598 0010 1A70     		strb	r2, [r3]
1761:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4599              		.loc 1 1761 0
 4600 0012 7B68     		ldr	r3, [r7, #4]
 4601 0014 1B68     		ldr	r3, [r3]
 4602 0016 3B61     		str	r3, [r7, #16]
1762:../Generated_Code/UTIL1.c ****   byte v;
1763:../Generated_Code/UTIL1.c **** 
1764:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 4603              		.loc 1 1764 0
 4604 0018 3B1C     		mov	r3, r7
 4605 001a 1033     		add	r3, r3, #16
 4606 001c 181C     		mov	r0, r3
 4607 001e FFF7FEFF 		bl	PreScanHexNumber
 4608 0022 031C     		mov	r3, r0
 4609 0024 01D0     		beq	.L209
1765:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4610              		.loc 1 1765 0
 4611 0026 1B23     		mov	r3, #27
 4612 0028 2FE0     		b	.L210
 4613              	.L209:
1766:../Generated_Code/UTIL1.c ****   }
1767:../Generated_Code/UTIL1.c ****   *val = 0;
 4614              		.loc 1 1767 0
 4615 002a 3B68     		ldr	r3, [r7]
 4616 002c 0022     		mov	r2, #0
 4617 002e 1A80     		strh	r2, [r3]
1768:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4618              		.loc 1 1768 0
 4619 0030 11E0     		b	.L211
 4620              	.L213:
1769:../Generated_Code/UTIL1.c ****     *val = (uint16_t)((*val)*16 + v);
 4621              		.loc 1 1769 0
 4622 0032 3B68     		ldr	r3, [r7]
 4623 0034 1B88     		ldrh	r3, [r3]
 4624 0036 1B01     		lsl	r3, r3, #4
 4625 0038 9AB2     		uxth	r2, r3
 4626 003a 3B1C     		mov	r3, r7
 4627 003c 0F33     		add	r3, r3, #15
 4628 003e 1B78     		ldrb	r3, [r3]
 4629 0040 D318     		add	r3, r2, r3
 4630 0042 9AB2     		uxth	r2, r3
 4631 0044 3B68     		ldr	r3, [r7]
 4632 0046 1A80     		strh	r2, [r3]
1770:../Generated_Code/UTIL1.c ****     nofDigits--;
 4633              		.loc 1 1770 0
 4634 0048 3B1C     		mov	r3, r7
 4635 004a 1733     		add	r3, r3, #23
 4636 004c 3A1C     		mov	r2, r7
 4637 004e 1732     		add	r2, r2, #23
 4638 0050 1278     		ldrb	r2, [r2]
 4639 0052 013A     		sub	r2, r2, #1
 4640 0054 1A70     		strb	r2, [r3]
 4641              	.L211:
1768:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4642              		.loc 1 1768 0 discriminator 1
 4643 0056 3A1C     		mov	r2, r7
 4644 0058 1032     		add	r2, r2, #16
 4645 005a 3B1C     		mov	r3, r7
 4646 005c 0F33     		add	r3, r3, #15
 4647 005e 101C     		mov	r0, r2
 4648 0060 191C     		mov	r1, r3
 4649 0062 FFF7FEFF 		bl	HexToDec
 4650 0066 031C     		mov	r3, r0
 4651 0068 04D1     		bne	.L212
1768:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4652              		.loc 1 1768 0 is_stmt 0 discriminator 2
 4653 006a 3B1C     		mov	r3, r7
 4654 006c 1733     		add	r3, r3, #23
 4655 006e 1B78     		ldrb	r3, [r3]
 4656 0070 002B     		cmp	r3, #0
 4657 0072 DED1     		bne	.L213
 4658              	.L212:
1771:../Generated_Code/UTIL1.c ****   } /* while */
1772:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 4659              		.loc 1 1772 0 is_stmt 1
 4660 0074 3B1C     		mov	r3, r7
 4661 0076 1733     		add	r3, r3, #23
 4662 0078 1B78     		ldrb	r3, [r3]
 4663 007a 002B     		cmp	r3, #0
 4664 007c 01D1     		bne	.L214
1773:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4665              		.loc 1 1773 0
 4666 007e 0423     		mov	r3, #4
 4667 0080 03E0     		b	.L210
 4668              	.L214:
1774:../Generated_Code/UTIL1.c ****   }
1775:../Generated_Code/UTIL1.c ****   *str = p;
 4669              		.loc 1 1775 0
 4670 0082 3A69     		ldr	r2, [r7, #16]
 4671 0084 7B68     		ldr	r3, [r7, #4]
 4672 0086 1A60     		str	r2, [r3]
1776:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4673              		.loc 1 1776 0
 4674 0088 0023     		mov	r3, #0
 4675              	.L210:
1777:../Generated_Code/UTIL1.c **** }
 4676              		.loc 1 1777 0
 4677 008a 181C     		mov	r0, r3
 4678 008c BD46     		mov	sp, r7
 4679 008e 06B0     		add	sp, sp, #24
 4680              		@ sp needed for prologue
 4681 0090 80BD     		pop	{r7, pc}
 4682              		.cfi_endproc
 4683              	.LFE40:
 4685 0092 C046     		.section	.text.UTIL1_ScanHex8uNumber,"ax",%progbits
 4686              		.align	2
 4687              		.global	UTIL1_ScanHex8uNumber
 4688              		.code	16
 4689              		.thumb_func
 4691              	UTIL1_ScanHex8uNumber:
 4692              	.LFB41:
1778:../Generated_Code/UTIL1.c **** 
1779:../Generated_Code/UTIL1.c **** /*
1780:../Generated_Code/UTIL1.c **** ** ===================================================================
1781:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex8uNumber (component Utility)
1782:../Generated_Code/UTIL1.c **** **
1783:../Generated_Code/UTIL1.c **** **     Description :
1784:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 8bit number, starting with 0x
1785:../Generated_Code/UTIL1.c **** **     Parameters  :
1786:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1787:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1788:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1789:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1790:../Generated_Code/UTIL1.c **** **     Returns     :
1791:../Generated_Code/UTIL1.c **** **         ---             - Error code
1792:../Generated_Code/UTIL1.c **** ** ===================================================================
1793:../Generated_Code/UTIL1.c **** */
1794:../Generated_Code/UTIL1.c **** byte UTIL1_ScanHex8uNumber(const unsigned char **str, byte *val)
1795:../Generated_Code/UTIL1.c **** {
 4693              		.loc 1 1795 0
 4694              		.cfi_startproc
 4695 0000 80B5     		push	{r7, lr}
 4696              	.LCFI123:
 4697              		.cfi_def_cfa_offset 8
 4698              		.cfi_offset 7, -8
 4699              		.cfi_offset 14, -4
 4700 0002 86B0     		sub	sp, sp, #24
 4701              	.LCFI124:
 4702              		.cfi_def_cfa_offset 32
 4703 0004 00AF     		add	r7, sp, #0
 4704              	.LCFI125:
 4705              		.cfi_def_cfa_register 7
 4706 0006 7860     		str	r0, [r7, #4]
 4707 0008 3960     		str	r1, [r7]
1796:../Generated_Code/UTIL1.c ****   /* scans a hex number with 0x, and stops at any non-number. Number can have any preceding zeros o
1797:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
 4708              		.loc 1 1797 0
 4709 000a 3B1C     		mov	r3, r7
 4710 000c 1733     		add	r3, r3, #23
 4711 000e 0322     		mov	r2, #3
 4712 0010 1A70     		strb	r2, [r3]
1798:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4713              		.loc 1 1798 0
 4714 0012 7B68     		ldr	r3, [r7, #4]
 4715 0014 1B68     		ldr	r3, [r3]
 4716 0016 3B61     		str	r3, [r7, #16]
1799:../Generated_Code/UTIL1.c ****   byte v;
1800:../Generated_Code/UTIL1.c **** 
1801:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 4717              		.loc 1 1801 0
 4718 0018 3B1C     		mov	r3, r7
 4719 001a 1033     		add	r3, r3, #16
 4720 001c 181C     		mov	r0, r3
 4721 001e FFF7FEFF 		bl	PreScanHexNumber
 4722 0022 031C     		mov	r3, r0
 4723 0024 01D0     		beq	.L216
1802:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4724              		.loc 1 1802 0
 4725 0026 1B23     		mov	r3, #27
 4726 0028 2FE0     		b	.L217
 4727              	.L216:
1803:../Generated_Code/UTIL1.c ****   }
1804:../Generated_Code/UTIL1.c ****   *val = 0;
 4728              		.loc 1 1804 0
 4729 002a 3B68     		ldr	r3, [r7]
 4730 002c 0022     		mov	r2, #0
 4731 002e 1A70     		strb	r2, [r3]
1805:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4732              		.loc 1 1805 0
 4733 0030 11E0     		b	.L218
 4734              	.L220:
1806:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*16 + v);
 4735              		.loc 1 1806 0
 4736 0032 3B68     		ldr	r3, [r7]
 4737 0034 1B78     		ldrb	r3, [r3]
 4738 0036 1B01     		lsl	r3, r3, #4
 4739 0038 DAB2     		uxtb	r2, r3
 4740 003a 3B1C     		mov	r3, r7
 4741 003c 0F33     		add	r3, r3, #15
 4742 003e 1B78     		ldrb	r3, [r3]
 4743 0040 D318     		add	r3, r2, r3
 4744 0042 DAB2     		uxtb	r2, r3
 4745 0044 3B68     		ldr	r3, [r7]
 4746 0046 1A70     		strb	r2, [r3]
1807:../Generated_Code/UTIL1.c ****     nofDigits--;
 4747              		.loc 1 1807 0
 4748 0048 3B1C     		mov	r3, r7
 4749 004a 1733     		add	r3, r3, #23
 4750 004c 3A1C     		mov	r2, r7
 4751 004e 1732     		add	r2, r2, #23
 4752 0050 1278     		ldrb	r2, [r2]
 4753 0052 013A     		sub	r2, r2, #1
 4754 0054 1A70     		strb	r2, [r3]
 4755              	.L218:
1805:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4756              		.loc 1 1805 0 discriminator 1
 4757 0056 3A1C     		mov	r2, r7
 4758 0058 1032     		add	r2, r2, #16
 4759 005a 3B1C     		mov	r3, r7
 4760 005c 0F33     		add	r3, r3, #15
 4761 005e 101C     		mov	r0, r2
 4762 0060 191C     		mov	r1, r3
 4763 0062 FFF7FEFF 		bl	HexToDec
 4764 0066 031C     		mov	r3, r0
 4765 0068 04D1     		bne	.L219
1805:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4766              		.loc 1 1805 0 is_stmt 0 discriminator 2
 4767 006a 3B1C     		mov	r3, r7
 4768 006c 1733     		add	r3, r3, #23
 4769 006e 1B78     		ldrb	r3, [r3]
 4770 0070 002B     		cmp	r3, #0
 4771 0072 DED1     		bne	.L220
 4772              	.L219:
1808:../Generated_Code/UTIL1.c ****   } /* while */
1809:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 4773              		.loc 1 1809 0 is_stmt 1
 4774 0074 3B1C     		mov	r3, r7
 4775 0076 1733     		add	r3, r3, #23
 4776 0078 1B78     		ldrb	r3, [r3]
 4777 007a 002B     		cmp	r3, #0
 4778 007c 01D1     		bne	.L221
1810:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4779              		.loc 1 1810 0
 4780 007e 0423     		mov	r3, #4
 4781 0080 03E0     		b	.L217
 4782              	.L221:
1811:../Generated_Code/UTIL1.c ****   }
1812:../Generated_Code/UTIL1.c ****   *str = p;
 4783              		.loc 1 1812 0
 4784 0082 3A69     		ldr	r2, [r7, #16]
 4785 0084 7B68     		ldr	r3, [r7, #4]
 4786 0086 1A60     		str	r2, [r3]
1813:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4787              		.loc 1 1813 0
 4788 0088 0023     		mov	r3, #0
 4789              	.L217:
1814:../Generated_Code/UTIL1.c **** }
 4790              		.loc 1 1814 0
 4791 008a 181C     		mov	r0, r3
 4792 008c BD46     		mov	sp, r7
 4793 008e 06B0     		add	sp, sp, #24
 4794              		@ sp needed for prologue
 4795 0090 80BD     		pop	{r7, pc}
 4796              		.cfi_endproc
 4797              	.LFE41:
 4799 0092 C046     		.section	.text.UTIL1_ScanHex8uNumberNoPrefix,"ax",%progbits
 4800              		.align	2
 4801              		.global	UTIL1_ScanHex8uNumberNoPrefix
 4802              		.code	16
 4803              		.thumb_func
 4805              	UTIL1_ScanHex8uNumberNoPrefix:
 4806              	.LFB42:
1815:../Generated_Code/UTIL1.c **** 
1816:../Generated_Code/UTIL1.c **** /*
1817:../Generated_Code/UTIL1.c **** ** ===================================================================
1818:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex8uNumberNoPrefix (component Utility)
1819:../Generated_Code/UTIL1.c **** **
1820:../Generated_Code/UTIL1.c **** **     Description :
1821:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 8bit number, without 0x
1822:../Generated_Code/UTIL1.c **** **     Parameters  :
1823:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1824:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1825:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1826:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1827:../Generated_Code/UTIL1.c **** **     Returns     :
1828:../Generated_Code/UTIL1.c **** **         ---             - Error code
1829:../Generated_Code/UTIL1.c **** ** ===================================================================
1830:../Generated_Code/UTIL1.c **** */
1831:../Generated_Code/UTIL1.c **** byte UTIL1_ScanHex8uNumberNoPrefix(const unsigned char **str, byte *val)
1832:../Generated_Code/UTIL1.c **** {
 4807              		.loc 1 1832 0
 4808              		.cfi_startproc
 4809 0000 80B5     		push	{r7, lr}
 4810              	.LCFI126:
 4811              		.cfi_def_cfa_offset 8
 4812              		.cfi_offset 7, -8
 4813              		.cfi_offset 14, -4
 4814 0002 86B0     		sub	sp, sp, #24
 4815              	.LCFI127:
 4816              		.cfi_def_cfa_offset 32
 4817 0004 00AF     		add	r7, sp, #0
 4818              	.LCFI128:
 4819              		.cfi_def_cfa_register 7
 4820 0006 7860     		str	r0, [r7, #4]
 4821 0008 3960     		str	r1, [r7]
1833:../Generated_Code/UTIL1.c ****   /* scans a hex number without 0x, and stops at any non-number. Number can have any preceding zero
1834:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
 4822              		.loc 1 1834 0
 4823 000a 3B1C     		mov	r3, r7
 4824 000c 1733     		add	r3, r3, #23
 4825 000e 0322     		mov	r2, #3
 4826 0010 1A70     		strb	r2, [r3]
1835:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4827              		.loc 1 1835 0
 4828 0012 7B68     		ldr	r3, [r7, #4]
 4829 0014 1B68     		ldr	r3, [r3]
 4830 0016 3B61     		str	r3, [r7, #16]
1836:../Generated_Code/UTIL1.c ****   byte v;
1837:../Generated_Code/UTIL1.c **** 
1838:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4831              		.loc 1 1838 0
 4832 0018 02E0     		b	.L223
 4833              	.L224:
1839:../Generated_Code/UTIL1.c ****     p++; /* skip space */
 4834              		.loc 1 1839 0
 4835 001a 3B69     		ldr	r3, [r7, #16]
 4836 001c 0133     		add	r3, r3, #1
 4837 001e 3B61     		str	r3, [r7, #16]
 4838              	.L223:
1838:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4839              		.loc 1 1838 0 discriminator 1
 4840 0020 3B69     		ldr	r3, [r7, #16]
 4841 0022 1B78     		ldrb	r3, [r3]
 4842 0024 202B     		cmp	r3, #32
 4843 0026 F8D0     		beq	.L224
1840:../Generated_Code/UTIL1.c ****   }
1841:../Generated_Code/UTIL1.c ****   *val = 0;
 4844              		.loc 1 1841 0
 4845 0028 3B68     		ldr	r3, [r7]
 4846 002a 0022     		mov	r2, #0
 4847 002c 1A70     		strb	r2, [r3]
1842:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4848              		.loc 1 1842 0
 4849 002e 11E0     		b	.L225
 4850              	.L227:
1843:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*16 + v);
 4851              		.loc 1 1843 0
 4852 0030 3B68     		ldr	r3, [r7]
 4853 0032 1B78     		ldrb	r3, [r3]
 4854 0034 1B01     		lsl	r3, r3, #4
 4855 0036 DAB2     		uxtb	r2, r3
 4856 0038 3B1C     		mov	r3, r7
 4857 003a 0F33     		add	r3, r3, #15
 4858 003c 1B78     		ldrb	r3, [r3]
 4859 003e D318     		add	r3, r2, r3
 4860 0040 DAB2     		uxtb	r2, r3
 4861 0042 3B68     		ldr	r3, [r7]
 4862 0044 1A70     		strb	r2, [r3]
1844:../Generated_Code/UTIL1.c ****     nofDigits--;
 4863              		.loc 1 1844 0
 4864 0046 3B1C     		mov	r3, r7
 4865 0048 1733     		add	r3, r3, #23
 4866 004a 3A1C     		mov	r2, r7
 4867 004c 1732     		add	r2, r2, #23
 4868 004e 1278     		ldrb	r2, [r2]
 4869 0050 013A     		sub	r2, r2, #1
 4870 0052 1A70     		strb	r2, [r3]
 4871              	.L225:
1842:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4872              		.loc 1 1842 0 discriminator 1
 4873 0054 3A1C     		mov	r2, r7
 4874 0056 1032     		add	r2, r2, #16
 4875 0058 3B1C     		mov	r3, r7
 4876 005a 0F33     		add	r3, r3, #15
 4877 005c 101C     		mov	r0, r2
 4878 005e 191C     		mov	r1, r3
 4879 0060 FFF7FEFF 		bl	HexToDec
 4880 0064 031C     		mov	r3, r0
 4881 0066 04D1     		bne	.L226
1842:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 4882              		.loc 1 1842 0 is_stmt 0 discriminator 2
 4883 0068 3B1C     		mov	r3, r7
 4884 006a 1733     		add	r3, r3, #23
 4885 006c 1B78     		ldrb	r3, [r3]
 4886 006e 002B     		cmp	r3, #0
 4887 0070 DED1     		bne	.L227
 4888              	.L226:
1845:../Generated_Code/UTIL1.c ****   } /* while */
1846:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 4889              		.loc 1 1846 0 is_stmt 1
 4890 0072 3B1C     		mov	r3, r7
 4891 0074 1733     		add	r3, r3, #23
 4892 0076 1B78     		ldrb	r3, [r3]
 4893 0078 002B     		cmp	r3, #0
 4894 007a 01D1     		bne	.L228
1847:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4895              		.loc 1 1847 0
 4896 007c 0423     		mov	r3, #4
 4897 007e 03E0     		b	.L229
 4898              	.L228:
1848:../Generated_Code/UTIL1.c ****   }
1849:../Generated_Code/UTIL1.c ****   *str = p;
 4899              		.loc 1 1849 0
 4900 0080 3A69     		ldr	r2, [r7, #16]
 4901 0082 7B68     		ldr	r3, [r7, #4]
 4902 0084 1A60     		str	r2, [r3]
1850:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4903              		.loc 1 1850 0
 4904 0086 0023     		mov	r3, #0
 4905              	.L229:
1851:../Generated_Code/UTIL1.c **** }
 4906              		.loc 1 1851 0
 4907 0088 181C     		mov	r0, r3
 4908 008a BD46     		mov	sp, r7
 4909 008c 06B0     		add	sp, sp, #24
 4910              		@ sp needed for prologue
 4911 008e 80BD     		pop	{r7, pc}
 4912              		.cfi_endproc
 4913              	.LFE42:
 4915              		.section	.text.UTIL1_strtailcmp,"ax",%progbits
 4916              		.align	2
 4917              		.global	UTIL1_strtailcmp
 4918              		.code	16
 4919              		.thumb_func
 4921              	UTIL1_strtailcmp:
 4922              	.LFB43:
1852:../Generated_Code/UTIL1.c **** 
1853:../Generated_Code/UTIL1.c **** /*
1854:../Generated_Code/UTIL1.c **** ** ===================================================================
1855:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strtailcmp (component Utility)
1856:../Generated_Code/UTIL1.c **** **
1857:../Generated_Code/UTIL1.c **** **     Description :
1858:../Generated_Code/UTIL1.c **** **         Compares the tail of a string and returns 0 if it matches, 1
1859:../Generated_Code/UTIL1.c **** **         otherwise
1860:../Generated_Code/UTIL1.c **** **     Parameters  :
1861:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1862:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string. This string is compared
1863:../Generated_Code/UTIL1.c **** **                           if it contains the tail.
1864:../Generated_Code/UTIL1.c **** **       * tail            - Pointer to tail string.
1865:../Generated_Code/UTIL1.c **** **     Returns     :
1866:../Generated_Code/UTIL1.c **** **         ---             - returns 0 if tail matches, -1 otherwise
1867:../Generated_Code/UTIL1.c **** ** ===================================================================
1868:../Generated_Code/UTIL1.c **** */
1869:../Generated_Code/UTIL1.c **** byte UTIL1_strtailcmp(byte *str, byte *tail)
1870:../Generated_Code/UTIL1.c **** {
 4923              		.loc 1 1870 0
 4924              		.cfi_startproc
 4925 0000 80B5     		push	{r7, lr}
 4926              	.LCFI129:
 4927              		.cfi_def_cfa_offset 8
 4928              		.cfi_offset 7, -8
 4929              		.cfi_offset 14, -4
 4930 0002 84B0     		sub	sp, sp, #16
 4931              	.LCFI130:
 4932              		.cfi_def_cfa_offset 24
 4933 0004 00AF     		add	r7, sp, #0
 4934              	.LCFI131:
 4935              		.cfi_def_cfa_register 7
 4936 0006 7860     		str	r0, [r7, #4]
 4937 0008 3960     		str	r1, [r7]
1871:../Generated_Code/UTIL1.c ****   int i, j;
1872:../Generated_Code/UTIL1.c **** 
1873:../Generated_Code/UTIL1.c ****   i = (int)UTIL1_strlen((char*)str);
 4938              		.loc 1 1873 0
 4939 000a 7B68     		ldr	r3, [r7, #4]
 4940 000c 181C     		mov	r0, r3
 4941 000e FFF7FEFF 		bl	strlen
 4942 0012 031C     		mov	r3, r0
 4943 0014 FB60     		str	r3, [r7, #12]
1874:../Generated_Code/UTIL1.c ****   j = (int)UTIL1_strlen((char*)tail);
 4944              		.loc 1 1874 0
 4945 0016 3B68     		ldr	r3, [r7]
 4946 0018 181C     		mov	r0, r3
 4947 001a FFF7FEFF 		bl	strlen
 4948 001e 031C     		mov	r3, r0
 4949 0020 BB60     		str	r3, [r7, #8]
1875:../Generated_Code/UTIL1.c ****   if (j>i) { /* str is smaller than tail */
 4950              		.loc 1 1875 0
 4951 0022 BA68     		ldr	r2, [r7, #8]
 4952 0024 FB68     		ldr	r3, [r7, #12]
 4953 0026 9A42     		cmp	r2, r3
 4954 0028 0CDD     		ble	.L235
1876:../Generated_Code/UTIL1.c ****     return 1; /* cannot match */
 4955              		.loc 1 1876 0
 4956 002a 0123     		mov	r3, #1
 4957 002c 16E0     		b	.L232
 4958              	.L234:
1877:../Generated_Code/UTIL1.c ****   }
1878:../Generated_Code/UTIL1.c ****   /* compare strings */
1879:../Generated_Code/UTIL1.c ****   while(str[i]==tail[j]) {
1880:../Generated_Code/UTIL1.c ****     i--;
 4959              		.loc 1 1880 0
 4960 002e FB68     		ldr	r3, [r7, #12]
 4961 0030 013B     		sub	r3, r3, #1
 4962 0032 FB60     		str	r3, [r7, #12]
1881:../Generated_Code/UTIL1.c ****     j--;
 4963              		.loc 1 1881 0
 4964 0034 BB68     		ldr	r3, [r7, #8]
 4965 0036 013B     		sub	r3, r3, #1
 4966 0038 BB60     		str	r3, [r7, #8]
1882:../Generated_Code/UTIL1.c ****     if (j<0) {
 4967              		.loc 1 1882 0
 4968 003a BB68     		ldr	r3, [r7, #8]
 4969 003c 002B     		cmp	r3, #0
 4970 003e 02DA     		bge	.L233
1883:../Generated_Code/UTIL1.c ****       return 0; /* match */
 4971              		.loc 1 1883 0
 4972 0040 0023     		mov	r3, #0
 4973 0042 0BE0     		b	.L232
 4974              	.L235:
1879:../Generated_Code/UTIL1.c ****   while(str[i]==tail[j]) {
 4975              		.loc 1 1879 0
 4976 0044 C046     		mov	r8, r8
 4977              	.L233:
1879:../Generated_Code/UTIL1.c ****   while(str[i]==tail[j]) {
 4978              		.loc 1 1879 0 is_stmt 0 discriminator 1
 4979 0046 FB68     		ldr	r3, [r7, #12]
 4980 0048 7A68     		ldr	r2, [r7, #4]
 4981 004a D318     		add	r3, r2, r3
 4982 004c 1A78     		ldrb	r2, [r3]
 4983 004e BB68     		ldr	r3, [r7, #8]
 4984 0050 3968     		ldr	r1, [r7]
 4985 0052 CB18     		add	r3, r1, r3
 4986 0054 1B78     		ldrb	r3, [r3]
 4987 0056 9A42     		cmp	r2, r3
 4988 0058 E9D0     		beq	.L234
1884:../Generated_Code/UTIL1.c ****     }
1885:../Generated_Code/UTIL1.c ****   }
1886:../Generated_Code/UTIL1.c ****   return 1; /* !=0 means no match */
 4989              		.loc 1 1886 0 is_stmt 1
 4990 005a 0123     		mov	r3, #1
 4991              	.L232:
1887:../Generated_Code/UTIL1.c **** }
 4992              		.loc 1 1887 0
 4993 005c 181C     		mov	r0, r3
 4994 005e BD46     		mov	sp, r7
 4995 0060 04B0     		add	sp, sp, #16
 4996              		@ sp needed for prologue
 4997 0062 80BD     		pop	{r7, pc}
 4998              		.cfi_endproc
 4999              	.LFE43:
 5001              		.section	.text.UTIL1_strCutTail,"ax",%progbits
 5002              		.align	2
 5003              		.global	UTIL1_strCutTail
 5004              		.code	16
 5005              		.thumb_func
 5007              	UTIL1_strCutTail:
 5008              	.LFB44:
1888:../Generated_Code/UTIL1.c **** 
1889:../Generated_Code/UTIL1.c **** /*
1890:../Generated_Code/UTIL1.c **** ** ===================================================================
1891:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strCutTail (component Utility)
1892:../Generated_Code/UTIL1.c **** **
1893:../Generated_Code/UTIL1.c **** **     Description :
1894:../Generated_Code/UTIL1.c **** **         Removes a tailing substring from a string. The string passed
1895:../Generated_Code/UTIL1.c **** **         will be modified (the tail is cut by writing a zero byte to
1896:../Generated_Code/UTIL1.c **** **         the string!)
1897:../Generated_Code/UTIL1.c **** **     Parameters  :
1898:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1899:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string where to remove the tail
1900:../Generated_Code/UTIL1.c **** **       * tail            - Pointer to substring to remove
1901:../Generated_Code/UTIL1.c **** **     Returns     :
1902:../Generated_Code/UTIL1.c **** **         ---             - Error code, ERR_OK if no error, otherwise
1903:../Generated_Code/UTIL1.c **** **                           ERR_FAIL if tail is not found
1904:../Generated_Code/UTIL1.c **** ** ===================================================================
1905:../Generated_Code/UTIL1.c **** */
1906:../Generated_Code/UTIL1.c **** byte UTIL1_strCutTail(byte *str, byte *tail)
1907:../Generated_Code/UTIL1.c **** {
 5009              		.loc 1 1907 0
 5010              		.cfi_startproc
 5011 0000 80B5     		push	{r7, lr}
 5012              	.LCFI132:
 5013              		.cfi_def_cfa_offset 8
 5014              		.cfi_offset 7, -8
 5015              		.cfi_offset 14, -4
 5016 0002 84B0     		sub	sp, sp, #16
 5017              	.LCFI133:
 5018              		.cfi_def_cfa_offset 24
 5019 0004 00AF     		add	r7, sp, #0
 5020              	.LCFI134:
 5021              		.cfi_def_cfa_register 7
 5022 0006 7860     		str	r0, [r7, #4]
 5023 0008 3960     		str	r1, [r7]
1908:../Generated_Code/UTIL1.c ****   /* cut the tail from the string */
1909:../Generated_Code/UTIL1.c ****   size_t strLen, tailLen;
1910:../Generated_Code/UTIL1.c **** 
1911:../Generated_Code/UTIL1.c ****   if (UTIL1_strtailcmp(str, tail)!=0) { /* check if tail is present */
 5024              		.loc 1 1911 0
 5025 000a 7A68     		ldr	r2, [r7, #4]
 5026 000c 3B68     		ldr	r3, [r7]
 5027 000e 101C     		mov	r0, r2
 5028 0010 191C     		mov	r1, r3
 5029 0012 FFF7FEFF 		bl	UTIL1_strtailcmp
 5030 0016 031C     		mov	r3, r0
 5031 0018 01D0     		beq	.L237
1912:../Generated_Code/UTIL1.c ****     return ERR_FAILED; /* tail not found */
 5032              		.loc 1 1912 0
 5033 001a 1B23     		mov	r3, #27
 5034 001c 13E0     		b	.L238
 5035              	.L237:
1913:../Generated_Code/UTIL1.c ****   }
1914:../Generated_Code/UTIL1.c ****   tailLen = UTIL1_strlen((char*)tail);
 5036              		.loc 1 1914 0
 5037 001e 3B68     		ldr	r3, [r7]
 5038 0020 181C     		mov	r0, r3
 5039 0022 FFF7FEFF 		bl	strlen
 5040 0026 031C     		mov	r3, r0
 5041 0028 FB60     		str	r3, [r7, #12]
1915:../Generated_Code/UTIL1.c ****   strLen = UTIL1_strlen((char*)str);
 5042              		.loc 1 1915 0
 5043 002a 7B68     		ldr	r3, [r7, #4]
 5044 002c 181C     		mov	r0, r3
 5045 002e FFF7FEFF 		bl	strlen
 5046 0032 031C     		mov	r3, r0
 5047 0034 BB60     		str	r3, [r7, #8]
1916:../Generated_Code/UTIL1.c ****   /* write \0 to cut the tail */
1917:../Generated_Code/UTIL1.c ****   str[strLen-tailLen] = '\0';
 5048              		.loc 1 1917 0
 5049 0036 BA68     		ldr	r2, [r7, #8]
 5050 0038 FB68     		ldr	r3, [r7, #12]
 5051 003a D31A     		sub	r3, r2, r3
 5052 003c 7A68     		ldr	r2, [r7, #4]
 5053 003e D318     		add	r3, r2, r3
 5054 0040 0022     		mov	r2, #0
 5055 0042 1A70     		strb	r2, [r3]
1918:../Generated_Code/UTIL1.c ****   return ERR_OK;
 5056              		.loc 1 1918 0
 5057 0044 0023     		mov	r3, #0
 5058              	.L238:
1919:../Generated_Code/UTIL1.c **** }
 5059              		.loc 1 1919 0
 5060 0046 181C     		mov	r0, r3
 5061 0048 BD46     		mov	sp, r7
 5062 004a 04B0     		add	sp, sp, #16
 5063              		@ sp needed for prologue
 5064 004c 80BD     		pop	{r7, pc}
 5065              		.cfi_endproc
 5066              	.LFE44:
 5068 004e C046     		.section	.rodata.skew.6198,"a",%progbits
 5069              		.align	2
 5072              	skew.6198:
 5073 0000 00       		.byte	0
 5074 0001 03       		.byte	3
 5075 0002 03       		.byte	3
 5076 0003 06       		.byte	6
 5077 0004 01       		.byte	1
 5078 0005 04       		.byte	4
 5079 0006 06       		.byte	6
 5080 0007 02       		.byte	2
 5081 0008 05       		.byte	5
 5082 0009 00       		.byte	0
 5083 000a 03       		.byte	3
 5084 000b 05       		.byte	5
 5085              		.text
 5086              	.Letext0:
 5087              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 5088              		.file 3 "../Generated_Code/PE_Types.h"
 5089              		.file 4 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
DEFINED SYMBOLS
                            *ABS*:00000000 UTIL1.c
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:18     .text.UTIL1_strcpy:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:23     .text.UTIL1_strcpy:00000000 UTIL1_strcpy
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:88     .text.UTIL1_strcat:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:93     .text.UTIL1_strcat:00000000 UTIL1_strcat
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:178    .text.UTIL1_chcat:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:183    .text.UTIL1_chcat:00000000 UTIL1_chcat
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:254    .text.UTIL1_Num8uToStr:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:259    .text.UTIL1_Num8uToStr:00000000 UTIL1_Num8uToStr
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:349    .text.UTIL1_Num16uToStr:00000000 UTIL1_Num16uToStr
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:297    .text.UTIL1_Num8sToStr:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:302    .text.UTIL1_Num8sToStr:00000000 UTIL1_Num8sToStr
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:554    .text.UTIL1_Num16sToStr:00000000 UTIL1_Num16sToStr
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:344    .text.UTIL1_Num16uToStr:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:549    .text.UTIL1_Num16sToStr:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:807    .text.ShiftRightAndFill:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:811    .text.ShiftRightAndFill:00000000 ShiftRightAndFill
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:964    .text.UTIL1_Num16sToStrFormatted:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:969    .text.UTIL1_Num16sToStrFormatted:00000000 UTIL1_Num16sToStrFormatted
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1022   .text.UTIL1_Num16uToStrFormatted:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1027   .text.UTIL1_Num16uToStrFormatted:00000000 UTIL1_Num16uToStrFormatted
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1079   .text.UTIL1_Num32uToStrFormatted:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1084   .text.UTIL1_Num32uToStrFormatted:00000000 UTIL1_Num32uToStrFormatted
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2396   .text.UTIL1_Num32uToStr:00000000 UTIL1_Num32uToStr
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1133   .text.UTIL1_Num32sToStrFormatted:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1138   .text.UTIL1_Num32sToStrFormatted:00000000 UTIL1_Num32sToStrFormatted
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2153   .text.UTIL1_Num32sToStr:00000000 UTIL1_Num32sToStr
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1187   .text.UTIL1_strcatNum8u:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1192   .text.UTIL1_strcatNum8u:00000000 UTIL1_strcatNum8u
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1238   .text.UTIL1_strcatNum8s:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1243   .text.UTIL1_strcatNum8s:00000000 UTIL1_strcatNum8s
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1290   .text.UTIL1_strcatNum16u:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1295   .text.UTIL1_strcatNum16u:00000000 UTIL1_strcatNum16u
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1341   .text.UTIL1_strcatNum16s:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1346   .text.UTIL1_strcatNum16s:00000000 UTIL1_strcatNum16s
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1393   .text.UTIL1_strcatNum16uFormatted:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1398   .text.UTIL1_strcatNum16uFormatted:00000000 UTIL1_strcatNum16uFormatted
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1453   .text.UTIL1_strcatNum16sFormatted:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1458   .text.UTIL1_strcatNum16sFormatted:00000000 UTIL1_strcatNum16sFormatted
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1514   .text.UTIL1_strcatNum32uFormatted:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1519   .text.UTIL1_strcatNum32uFormatted:00000000 UTIL1_strcatNum32uFormatted
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1571   .text.UTIL1_strcatNum32sFormatted:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1576   .text.UTIL1_strcatNum32sFormatted:00000000 UTIL1_strcatNum32sFormatted
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1628   .text.UTIL1_strcatNum8Hex:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1633   .text.UTIL1_strcatNum8Hex:00000000 UTIL1_strcatNum8Hex
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1734   .text.UTIL1_strcatNum16Hex:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1739   .text.UTIL1_strcatNum16Hex:00000000 UTIL1_strcatNum16Hex
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1842   .text.UTIL1_strcatNum24Hex:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1847   .text.UTIL1_strcatNum24Hex:00000000 UTIL1_strcatNum24Hex
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1946   .text.UTIL1_strcatNum32Hex:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:1951   .text.UTIL1_strcatNum32Hex:00000000 UTIL1_strcatNum32Hex
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2050   .text.UTIL1_strcatNum32s:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2055   .text.UTIL1_strcatNum32s:00000000 UTIL1_strcatNum32s
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2099   .text.UTIL1_strcatNum32u:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2104   .text.UTIL1_strcatNum32u:00000000 UTIL1_strcatNum32u
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2148   .text.UTIL1_Num32sToStr:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2391   .text.UTIL1_Num32uToStr:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2587   .text.UTIL1_IsLeapYear:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2592   .text.UTIL1_IsLeapYear:00000000 UTIL1_IsLeapYear
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2659   .text.UTIL1_WeekDay:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2664   .text.UTIL1_WeekDay:00000000 UTIL1_WeekDay
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2805   .text.UTIL1_WeekDay:000000e4 $d
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:5072   .rodata.skew.6198:00000000 skew.6198
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2811   .rodata:00000000 $d
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2815   .text.UTIL1_ReadEscapedName:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:2820   .text.UTIL1_ReadEscapedName:00000000 UTIL1_ReadEscapedName
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3066   .text.UTIL1_ReadEscapedName:00000158 $d
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3071   .text.UTIL1_xatoi:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3076   .text.UTIL1_xatoi:00000000 UTIL1_xatoi
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3411   .text.UTIL1_ScanDate:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3416   .text.UTIL1_ScanDate:00000000 UTIL1_ScanDate
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3853   .text.UTIL1_ScanDecimal8uNumber:00000000 UTIL1_ScanDecimal8uNumber
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3987   .text.UTIL1_ScanDecimal16uNumber:00000000 UTIL1_ScanDecimal16uNumber
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3587   .text.UTIL1_ScanDate:000000f8 $d
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3592   .text.UTIL1_ScanTime:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3597   .text.UTIL1_ScanTime:00000000 UTIL1_ScanTime
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3848   .text.UTIL1_ScanDecimal8uNumber:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:3982   .text.UTIL1_ScanDecimal16uNumber:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4116   .text.UTIL1_ScanDecimal32uNumber:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4121   .text.UTIL1_ScanDecimal32uNumber:00000000 UTIL1_ScanDecimal32uNumber
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4249   .text.PreScanHexNumber:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4253   .text.PreScanHexNumber:00000000 PreScanHexNumber
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4329   .text.HexToDec:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4333   .text.HexToDec:00000000 HexToDec
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4460   .text.UTIL1_ScanHex32uNumber:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4465   .text.UTIL1_ScanHex32uNumber:00000000 UTIL1_ScanHex32uNumber
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4572   .text.UTIL1_ScanHex16uNumber:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4577   .text.UTIL1_ScanHex16uNumber:00000000 UTIL1_ScanHex16uNumber
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4686   .text.UTIL1_ScanHex8uNumber:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4691   .text.UTIL1_ScanHex8uNumber:00000000 UTIL1_ScanHex8uNumber
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4800   .text.UTIL1_ScanHex8uNumberNoPrefix:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4805   .text.UTIL1_ScanHex8uNumberNoPrefix:00000000 UTIL1_ScanHex8uNumberNoPrefix
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4916   .text.UTIL1_strtailcmp:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:4921   .text.UTIL1_strtailcmp:00000000 UTIL1_strtailcmp
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:5002   .text.UTIL1_strCutTail:00000000 $t
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:5007   .text.UTIL1_strCutTail:00000000 UTIL1_strCutTail
C:\Users\LARM\AppData\Local\Temp\ccvkNSXz.s:5069   .rodata.skew.6198:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_uidivmod
__aeabi_uidiv
__aeabi_idivmod
__aeabi_idiv
strchr
strlen
